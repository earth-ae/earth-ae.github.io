/*!
 * Project-specific code is Copyright (c) 2018 Cameron Beccario
 *
 * See https://earth.nullschool.net/js/bundle.js for a readable version of this source, including licenses.
 * See https://github.com/cambecc/earth for a free version of this project.
 *
 */

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./public/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/backbone/backbone.js":
/*!*******************************************!*\
  !*** ./node_modules/backbone/backbone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//     Backbone.js 1.1.2
//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org
(function (root, factory) {
  // Set up Backbone appropriately for the environment. Start with AMD.

  /*if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });
   // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else*/
  if (true) {
    var _ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");

    factory(root, exports, _); // Finally, as a browser global.
  } else {}
})(this, function (root, Backbone, _, $) {
  // Initial Setup
  // -------------
  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone; // Create local references to array methods we'll want to use later.

  var array = [];
  var push = array.push;
  var _slice = array.slice;
  var splice = array.splice; // Current version of the library. Keep in sync with `package.json`.

  Backbone.VERSION = '1.1.2'; // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.

  Backbone.$ = $; // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.

  Backbone.noConflict = function () {
    root.Backbone = previousBackbone;
    return this;
  }; // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.


  Backbone.emulateHTTP = false; // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.

  Backbone.emulateJSON = false; // Backbone.Events
  // ---------------
  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //

  var Events = Backbone.Events = {
    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function on(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({
        callback: callback,
        context: context,
        ctx: context || this
      });
      return this;
    },
    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function once(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;

      var once = _.once(function () {
        self.off(name, once);
        callback.apply(this, arguments);
      });

      once._callback = callback;
      return this.on(name, once, context);
    },
    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function off(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;

      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }

      names = name ? [name] : _.keys(this._events);

      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];

        if (events = this._events[name]) {
          this._events[name] = retain = [];

          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];

              if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
                retain.push(ev);
              }
            }
          }

          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },
    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function trigger(name) {
      if (!this._events) return this;

      var args = _slice.call(arguments, 1);

      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },
    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function stopListening(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && _typeof(name) === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;

      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }

      return this;
    }
  }; // Regular expression used to split event strings.

  var eventSplitter = /\s+/; // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.

  var eventsApi = function eventsApi(obj, action, name, rest) {
    if (!name) return true; // Handle event maps.

    if (_typeof(name) === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }

      return false;
    } // Handle space separated event names.


    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);

      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }

      return false;
    }

    return true;
  }; // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).


  var triggerEvents = function triggerEvents(events, args) {
    var ev,
        i = -1,
        l = events.length,
        a1 = args[0],
        a2 = args[1],
        a3 = args[2];

    switch (args.length) {
      case 0:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx);
        }

        return;

      case 1:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, a1);
        }

        return;

      case 2:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, a1, a2);
        }

        return;

      case 3:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
        }

        return;

      default:
        while (++i < l) {
          (ev = events[i]).callback.apply(ev.ctx, args);
        }

        return;
    }
  };

  var listenMethods = {
    listenTo: 'on',
    listenToOnce: 'once'
  }; // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.

  _.each(listenMethods, function (implementation, method) {
    Events[method] = function (obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});

      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));

      listeningTo[id] = obj;
      if (!callback && _typeof(name) === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  }); // Aliases for backwards compatibility.


  Events.bind = Events.on;
  Events.unbind = Events.off; // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.

  _.extend(Backbone, Events); // Backbone.Model
  // --------------
  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.
  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.


  var Model = Backbone.Model = function (attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  }; // Attach all inheritable methods to the Model prototype.


  _.extend(Model.prototype, Events, {
    // A hash of attributes whose current and previous value differ.
    changed: null,
    // The value returned during the last failed validation.
    validationError: null,
    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',
    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},
    // Return a copy of the model's `attributes` object.
    toJSON: function toJSON(options) {
      return _.clone(this.attributes);
    },
    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function sync() {
      return Backbone.sync.apply(this, arguments);
    },
    // Get the value of an attribute.
    get: function get(attr) {
      return this.attributes[attr];
    },
    // Get the HTML-escaped value of an attribute.
    escape: function escape(attr) {
      return _.escape(this.get(attr));
    },
    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function has(attr) {
      return this.get(attr) != null;
    },
    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function set(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this; // Handle both `"key", value` and `{key: value}` -style arguments.

      if (_typeof(key) === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {}); // Run validation.

      if (!this._validate(attrs, options)) return false; // Extract attributes and options.

      unset = options.unset;
      silent = options.silent;
      changes = [];
      changing = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      current = this.attributes, prev = this._previousAttributes; // Check for changes of `id`.

      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute]; // For each `set` attribute, update or delete the current value.

      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);

        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }

        unset ? delete current[attr] : current[attr] = val;
      } // Trigger all relevant attribute changes.


      if (!silent) {
        if (changes.length) this._pending = options;

        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      } // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.


      if (changing) return this;

      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }

      this._pending = false;
      this._changing = false;
      return this;
    },
    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function unset(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {
        unset: true
      }));
    },
    // Clear all attributes on the model, firing `"change"`.
    clear: function clear(options) {
      var attrs = {};

      for (var key in this.attributes) {
        attrs[key] = void 0;
      }

      return this.set(attrs, _.extend({}, options, {
        unset: true
      }));
    },
    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function hasChanged(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },
    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function changedAttributes(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val,
          changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;

      for (var attr in diff) {
        if (_.isEqual(old[attr], val = diff[attr])) continue;
        (changed || (changed = {}))[attr] = val;
      }

      return changed;
    },
    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function previous(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },
    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function previousAttributes() {
      return _.clone(this._previousAttributes);
    },
    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function fetch(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;

      options.success = function (resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };

      wrapError(this, options);
      return this.sync('read', this, options);
    },
    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function save(key, val, options) {
      var attrs,
          method,
          xhr,
          attributes = this.attributes; // Handle both `"key", value` and `{key: value}` -style arguments.

      if (key == null || _typeof(key) === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({
        validate: true
      }, options); // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.

      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      } // Set temporary attributes if `{wait: true}`.


      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      } // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.


      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;

      options.success = function (resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);

        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }

        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };

      wrapError(this, options);
      method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options); // Restore attributes.

      if (attrs && options.wait) this.attributes = attributes;
      return xhr;
    },
    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function destroy(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function destroy() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function (resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }

      wrapError(this, options);
      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },
    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function url() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },
    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function parse(resp, options) {
      return resp;
    },
    // Create a new model with identical attributes to this one.
    clone: function clone() {
      return new this.constructor(this.attributes);
    },
    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function isNew() {
      return !this.has(this.idAttribute);
    },
    // Check if the model is currently in a valid state.
    isValid: function isValid(options) {
      return this._validate({}, _.extend(options || {}, {
        validate: true
      }));
    },
    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function _validate(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {
        validationError: error
      }));
      return false;
    }
  }); // Underscore methods that we want to implement on the Model.


  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit']; // Mix in each Underscore method as a proxy to `Model#attributes`.

  _.each(modelMethods, function (method) {
    Model.prototype[method] = function () {
      var args = _slice.call(arguments);

      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  }); // Backbone.Collection
  // -------------------
  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.
  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.


  var Collection = Backbone.Collection = function (models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;

    this._reset();

    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({
      silent: true
    }, options));
  }; // Default options for `Collection#set`.


  var setOptions = {
    add: true,
    remove: true,
    merge: true
  };
  var addOptions = {
    add: true,
    remove: false
  }; // Define the Collection's inheritable methods.

  _.extend(Collection.prototype, Events, {
    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,
    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},
    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function toJSON(options) {
      return this.map(function (model) {
        return model.toJSON(options);
      });
    },
    // Proxy `Backbone.sync` by default.
    sync: function sync() {
      return Backbone.sync.apply(this, arguments);
    },
    // Add a model, or list of models to the set.
    add: function add(models, options) {
      return this.set(models, _.extend({
        merge: false
      }, options, addOptions));
    },
    // Remove a model, or a list of models from the set.
    remove: function remove(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;

      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        this._removeReference(model, options);
      }

      return singular ? models[0] : models;
    },
    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function set(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? models ? [models] : [] : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && at == null && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [],
          toRemove = [],
          modelMap = {};
      var add = options.add,
          merge = options.merge,
          remove = options.remove;
      var order = !sortable && add && remove ? [] : false; // Turn bare objects into model references, and prevent invalid models
      // from being added.

      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};

        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        } // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.


        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;

          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

          models[i] = existing; // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);

          this._addReference(model, options);
        } // Do not add multiple models with the same `id`.


        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      } // Remove nonexistent models if appropriate.


      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }

        if (toRemove.length) this.remove(toRemove, options);
      } // See if sorting is needed, update `length` and splice in new models.


      if (toAdd.length || order && order.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;

        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;

          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      } // Silently sort the collection if appropriate.


      if (sort) this.sort({
        silent: true
      }); // Unless silenced, it's time to fire all appropriate add/sort events.

      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }

        if (sort || order && order.length) this.trigger('sort', this, options);
      } // Return the added (or merged) model (or models).


      return singular ? models[0] : models;
    },
    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function reset(models, options) {
      options || (options = {});

      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }

      options.previousModels = this.models;

      this._reset();

      models = this.add(models, _.extend({
        silent: true
      }, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },
    // Add a model to the end of the collection.
    push: function push(model, options) {
      return this.add(model, _.extend({
        at: this.length
      }, options));
    },
    // Remove a model from the end of the collection.
    pop: function pop(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },
    // Add a model to the beginning of the collection.
    unshift: function unshift(model, options) {
      return this.add(model, _.extend({
        at: 0
      }, options));
    },
    // Remove a model from the beginning of the collection.
    shift: function shift(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },
    // Slice out a sub-array of models from the collection.
    slice: function slice() {
      return _slice.apply(this.models, arguments);
    },
    // Get a model from the set by id.
    get: function get(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },
    // Get the model at the given index.
    at: function at(index) {
      return this.models[index];
    },
    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function where(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function (model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }

        return true;
      });
    },
    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function findWhere(attrs) {
      return this.where(attrs, true);
    },
    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function sort(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {}); // Run sort based on type of `comparator`.

      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },
    // Pluck an attribute from each model in the collection.
    pluck: function pluck(attr) {
      return _.invoke(this.models, 'get', attr);
    },
    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function fetch(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;

      options.success = function (resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };

      wrapError(this, options);
      return this.sync('read', this, options);
    },
    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function create(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;

      options.success = function (model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };

      model.save(null, options);
      return model;
    },
    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function parse(resp, options) {
      return resp;
    },
    // Create a new collection with an identical list of models as this one.
    clone: function clone() {
      return new this.constructor(this.models);
    },
    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function _reset() {
      this.length = 0;
      this.models = [];
      this._byId = {};
    },
    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function _prepareModel(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },
    // Internal method to create a model's ties to a collection.
    _addReference: function _addReference(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },
    // Internal method to sever a model's ties to a collection.
    _removeReference: function _removeReference(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },
    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function _onModelEvent(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);

      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }

      this.trigger.apply(this, arguments);
    }
  }); // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:


  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl', 'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest', 'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'chain', 'sample']; // Mix in each Underscore method as a proxy to `Collection#models`.

  _.each(methods, function (method) {
    Collection.prototype[method] = function () {
      var args = _slice.call(arguments);

      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  }); // Underscore methods that take a property name as an argument.


  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy']; // Use attributes instead of properties.

  _.each(attributeMethods, function (method) {
    Collection.prototype[method] = function (value, context) {
      var iterator = _.isFunction(value) ? value : function (model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  }); // Backbone.View
  // -------------
  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.
  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...


  var View = Backbone.View = function (options) {
    this.cid = _.uniqueId('view');
    options || (options = {});

    _.extend(this, _.pick(options, viewOptions));

    this._ensureElement();

    this.initialize.apply(this, arguments);
    this.delegateEvents();
  }; // Cached regex to split keys for `delegate`.


  var delegateEventSplitter = /^(\S+)\s*(.*)$/; // List of view options to be merged as properties.

  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events']; // Set up all inheritable **Backbone.View** properties and methods.

  _.extend(View.prototype, Events, {
    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',
    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function $(selector) {
      return this.$el.find(selector);
    },
    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},
    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function render() {
      return this;
    },
    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function remove() {
      this.$el.remove();
      this.stopListening();
      return this;
    },
    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function setElement(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },
    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function delegateEvents(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();

      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        var eventName = match[1],
            selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;

        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }

      return this;
    },
    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function undelegateEvents() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },
    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function _ensureElement() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));

        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }
  }); // Backbone.sync
  // -------------
  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.


  Backbone.sync = function (method, model, options) {
    var type = methodMap[method]; // Default options, unless specified.

    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    }); // Default JSON-request options.


    var params = {
      type: type,
      dataType: 'json'
    }; // Ensure that we have a URL.

    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    } // Ensure that we have the appropriate request data.


    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    } // For older servers, emulate JSON by encoding the request into an HTML-form.


    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {
        model: params.data
      } : {};
    } // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.


    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;

      options.beforeSend = function (xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    } // Don't process data on a non-GET request.


    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    } // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.


    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function () {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    } // Make the request, allowing the user to override any Ajax options.


    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch = typeof window !== 'undefined' && !!window.ActiveXObject && !(window.XMLHttpRequest && new XMLHttpRequest().dispatchEvent); // Map from CRUD to HTTP for our default `Backbone.sync` implementation.

  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch': 'PATCH',
    'delete': 'DELETE',
    'read': 'GET'
  }; // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.

  Backbone.ajax = function () {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  }; // Backbone.Router
  // ---------------
  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.


  var Router = Backbone.Router = function (options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;

    this._bindRoutes();

    this.initialize.apply(this, arguments);
  }; // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.


  var optionalParam = /\((.*?)\)/g;
  var namedParam = /(\(\?)?:\w+/g;
  var splatParam = /\*\w+/g;
  var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g; // Set up all inheritable **Backbone.Router** properties and methods.

  _.extend(Router.prototype, Events, {
    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},
    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function route(_route, name, callback) {
      if (!_.isRegExp(_route)) _route = this._routeToRegExp(_route);

      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }

      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(_route, function (fragment) {
        var args = router._extractParameters(_route, fragment);

        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },
    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function execute(callback, args) {
      if (callback) callback.apply(this, args);
    },
    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function navigate(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },
    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function _bindRoutes() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');

      var route,
          routes = _.keys(this.routes);

      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },
    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function _routeToRegExp(route) {
      route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {
        return optional ? match : '([^/?]+)';
      }).replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },
    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function _extractParameters(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function (param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }
  }); // Backbone.History
  // ----------------
  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.


  var History = Backbone.History = function () {
    this.handlers = [];

    _.bindAll(this, 'checkUrl'); // Ensure that `History` can be used outside of the browser.


    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  }; // Cached regex for stripping a leading hash/slash and trailing space.


  var routeStripper = /^[#\/]|\s+$/g; // Cached regex for stripping leading and trailing slashes.

  var rootStripper = /^\/+|\/+$/g; // Cached regex for detecting MSIE.

  var isExplorer = /msie [\w.]+/; // Cached regex for removing a trailing slash.

  var trailingSlash = /\/$/; // Cached regex for stripping urls of hash.

  var pathStripper = /#.*$/; // Has the history handling already been started?

  History.started = false; // Set up all inheritable **Backbone.History** properties and methods.

  _.extend(History.prototype, Events, {
    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,
    // Are we at the app root?
    atRoot: function atRoot() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },
    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function getHash(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },
    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function getFragment(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }

      return fragment.replace(routeStripper, '');
    },
    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function start(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true; // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?

      this.options = _.extend({
        root: '/'
      }, this.options, options);
      this.root = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState = !!this.options.pushState;
      this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment = this.getFragment();
      var docMode = document.documentMode;
      var oldIE = isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7); // Normalize root to always include a leading and trailing slash.

      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      } // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.


      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && 'onhashchange' in window && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      } // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.


      this.fragment = fragment;
      var loc = this.location; // Transition from hashChange to pushState or vice versa if both are
      // requested.

      if (this._wantsHashChange && this._wantsPushState) {
        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment); // Return immediately as browser will do redirect to new url

          return true; // Or if we've started out with a hash-based route, but we're currently
          // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }
      }

      if (!this.options.silent) return this.loadUrl();
    },
    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function stop() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },
    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function route(_route2, callback) {
      this.handlers.unshift({
        route: _route2,
        callback: callback
      });
    },
    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function checkUrl(e) {
      var current = this.getFragment();

      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },
    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function loadUrl(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function (handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },
    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function navigate(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {
        trigger: !!options
      };
      var url = this.root + (fragment = this.getFragment(fragment || '')); // Strip the hash for matching.

      fragment = fragment.replace(pathStripper, '');
      if (this.fragment === fragment) return;
      this.fragment = fragment; // Don't include a trailing slash on the root.

      if (fragment === '' && url !== '/') url = url.slice(0, -1); // If pushState is available, we use it to set the fragment as a real URL.

      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url); // If hash changes haven't been explicitly disabled, update the hash
        // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);

        if (this.iframe && fragment !== this.getFragment(this.getHash(this.iframe))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) this.iframe.document.open().close();

          this._updateHash(this.iframe.location, fragment, options.replace);
        } // If you've told us that you explicitly don't want fallback hashchange-
        // based history, then `navigate` becomes a page refresh.

      } else {
        return this.location.assign(url);
      }

      if (options.trigger) return this.loadUrl(fragment);
    },
    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function _updateHash(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }
  }); // Create the default Backbone.history.


  Backbone.history = new History(); // Helpers
  // -------
  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.

  var extend = function extend(protoProps, staticProps) {
    var parent = this;
    var child; // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.

    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function child() {
        return parent.apply(this, arguments);
      };
    } // Add static properties to the constructor function, if supplied.


    _.extend(child, parent, staticProps); // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.


    var Surrogate = function Surrogate() {
      this.constructor = child;
    };

    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate(); // Add prototype properties (instance properties) to the subclass,
    // if supplied.

    if (protoProps) _.extend(child.prototype, protoProps); // Set a convenience property in case the parent's prototype is needed
    // later.

    child.__super__ = parent.prototype;
    return child;
  }; // Set up inheritance for the model, collection, router, view and history.


  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend; // Throw an error when a URL is needed, and none is supplied.

  var urlError = function urlError() {
    throw new Error('A "url" property or function must be specified');
  }; // Wrap an optional error callback with a fallback error event.


  var wrapError = function wrapError(model, options) {
    var error = options.error;

    options.error = function (resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;
});

/***/ }),

/***/ "./node_modules/chroma-js/chroma.js":
/*!******************************************!*\
  !*** ./node_modules/chroma-js/chroma.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 *
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2015, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
    chroma.js

    Copyright (c) 2011-2013, Gregor Aisch
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, this
      list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.

    * The name Gregor Aisch may not be used to endorse or promote products
      derived from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
    OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

    @source: https://github.com/gka/chroma.js
 */
(function () {
  var Color,
      LAB_CONSTANTS,
      PI,
      PITHIRD,
      TWOPI,
      _guess_formats,
      _guess_formats_sorted,
      _input,
      _interpolators,
      abs,
      atan2,
      _bezier,
      _blend,
      blend_f,
      brewer,
      burn,
      chroma,
      clip_rgb,
      cmyk2rgb,
      colors,
      cos,
      css2rgb,
      darken,
      dodge,
      each,
      floor,
      hex2rgb,
      hsi2rgb,
      hsl2css,
      hsl2rgb,
      hsv2rgb,
      interpolate,
      interpolate_hsx,
      interpolate_lab,
      interpolate_num,
      interpolate_rgb,
      lab2lch,
      lab2rgb,
      lab_xyz,
      lch2lab,
      lch2rgb,
      lighten,
      limit,
      log,
      luminance_x,
      m,
      max,
      multiply,
      normal,
      num2rgb,
      overlay,
      pow,
      rgb2cmyk,
      rgb2css,
      rgb2hex,
      rgb2hsi,
      rgb2hsl,
      rgb2hsv,
      rgb2lab,
      rgb2lch,
      rgb2luminance,
      rgb2num,
      rgb2temperature,
      rgb2xyz,
      rgb_xyz,
      rnd,
      root,
      round,
      screen,
      sin,
      sqrt,
      temperature2rgb,
      type,
      unpack,
      w3cx11,
      xyz_lab,
      xyz_rgb,
      slice = [].slice;

  type = function () {
    /*
    for browser-safe type checking+
    ported from jQuery's $.type
     */
    var classToType, len, name, o, ref;
    classToType = {};
    ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");

    for (o = 0, len = ref.length; o < len; o++) {
      name = ref[o];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }

    return function (obj) {
      var strType;
      strType = Object.prototype.toString.call(obj);
      return classToType[strType] || "object";
    };
  }();

  limit = function limit(x, min, max) {
    if (min == null) {
      min = 0;
    }

    if (max == null) {
      max = 1;
    }

    if (x < min) {
      x = min;
    }

    if (x > max) {
      x = max;
    }

    return x;
  };

  unpack = function unpack(args) {
    if (args.length >= 3) {
      return [].slice.call(args);
    } else {
      return args[0];
    }
  };

  clip_rgb = function clip_rgb(rgb) {
    var i;

    for (i in rgb) {
      if (i < 3) {
        if (rgb[i] < 0) {
          rgb[i] = 0;
        }

        if (rgb[i] > 255) {
          rgb[i] = 255;
        }
      } else if (i === 3) {
        if (rgb[i] < 0) {
          rgb[i] = 0;
        }

        if (rgb[i] > 1) {
          rgb[i] = 1;
        }
      }
    }

    return rgb;
  };

  PI = Math.PI, round = Math.round, cos = Math.cos, floor = Math.floor, pow = Math.pow, log = Math.log, sin = Math.sin, sqrt = Math.sqrt, atan2 = Math.atan2, max = Math.max, abs = Math.abs;
  TWOPI = PI * 2;
  PITHIRD = PI / 3;

  chroma = function chroma() {
    if (arguments[0] instanceof Color) {
      return arguments[0];
    }

    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, arguments, function () {});
  };

  _interpolators = [];

  if (typeof module !== "undefined" && module !== null && module.exports != null) {
    module.exports = chroma;
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return chroma;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

  chroma.version = '1.0.1';
  /**
      chroma.js

      Copyright (c) 2011-2013, Gregor Aisch
      All rights reserved.

      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright notice, this
        list of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation
        and/or other materials provided with the distribution.

      * The name Gregor Aisch may not be used to endorse or promote products
        derived from this software without specific prior written permission.

      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

      @source: https://github.com/gka/chroma.js
   */

  _input = {};
  _guess_formats = [];
  _guess_formats_sorted = false;

  Color = function () {
    function Color() {
      var arg, args, chk, len, len1, me, mode, o, w;
      me = this;
      args = [];

      for (o = 0, len = arguments.length; o < len; o++) {
        arg = arguments[o];

        if (arg != null) {
          args.push(arg);
        }
      }

      mode = args[args.length - 1];

      if (_input[mode] != null) {
        me._rgb = clip_rgb(_input[mode](unpack(args.slice(0, -1))));
      } else {
        if (!_guess_formats_sorted) {
          _guess_formats = _guess_formats.sort(function (a, b) {
            return b.p - a.p;
          });
          _guess_formats_sorted = true;
        }

        for (w = 0, len1 = _guess_formats.length; w < len1; w++) {
          chk = _guess_formats[w];
          mode = chk.test.apply(chk, args);

          if (mode) {
            break;
          }
        }

        if (mode) {
          me._rgb = clip_rgb(_input[mode].apply(_input, args));
        }
      }

      if (me._rgb == null) {
        console.warn('unknown format: ' + args);
      }

      if (me._rgb == null) {
        me._rgb = [0, 0, 0];
      }

      if (me._rgb.length === 3) {
        me._rgb.push(1);
      }
    }

    Color.prototype.alpha = function (alpha) {
      if (arguments.length) {
        this._rgb[3] = alpha;
        return this;
      }

      return this._rgb[3];
    };

    Color.prototype.toString = function () {
      return this.name();
    };

    return Color;
  }();
  /**
  	ColorBrewer colors for chroma.js

  	Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The
  	Pennsylvania State University.

  	Licensed under the Apache License, Version 2.0 (the "License");
  	you may not use this file except in compliance with the License.
  	You may obtain a copy of the License at
  	http://www.apache.org/licenses/LICENSE-2.0

  	Unless required by applicable law or agreed to in writing, software distributed
  	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
  	CONDITIONS OF ANY KIND, either express or implied. See the License for the
  	specific language governing permissions and limitations under the License.

      @preserve
   */


  chroma.brewer = brewer = {
    OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
    PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
    BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
    Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
    BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
    YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
    YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
    Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
    RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
    Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
    YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
    Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
    GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
    Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
    YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
    PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
    Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
    PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
    Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
    RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
    RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
    PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
    PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
    RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
    BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
    RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
    PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
    Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
    Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
    Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
    Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
    Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
    Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
    Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
    Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']
  };
  /**
  	X11 color names

  	http://www.w3.org/TR/css3-color/#svg-color
   */

  w3cx11 = {
    indigo: "#4b0082",
    gold: "#ffd700",
    hotpink: "#ff69b4",
    firebrick: "#b22222",
    indianred: "#cd5c5c",
    yellow: "#ffff00",
    mistyrose: "#ffe4e1",
    darkolivegreen: "#556b2f",
    olive: "#808000",
    darkseagreen: "#8fbc8f",
    pink: "#ffc0cb",
    tomato: "#ff6347",
    lightcoral: "#f08080",
    orangered: "#ff4500",
    navajowhite: "#ffdead",
    lime: "#00ff00",
    palegreen: "#98fb98",
    darkslategrey: "#2f4f4f",
    greenyellow: "#adff2f",
    burlywood: "#deb887",
    seashell: "#fff5ee",
    mediumspringgreen: "#00fa9a",
    fuchsia: "#ff00ff",
    papayawhip: "#ffefd5",
    blanchedalmond: "#ffebcd",
    chartreuse: "#7fff00",
    dimgray: "#696969",
    black: "#000000",
    peachpuff: "#ffdab9",
    springgreen: "#00ff7f",
    aquamarine: "#7fffd4",
    white: "#ffffff",
    orange: "#ffa500",
    lightsalmon: "#ffa07a",
    darkslategray: "#2f4f4f",
    brown: "#a52a2a",
    ivory: "#fffff0",
    dodgerblue: "#1e90ff",
    peru: "#cd853f",
    lawngreen: "#7cfc00",
    chocolate: "#d2691e",
    crimson: "#dc143c",
    forestgreen: "#228b22",
    darkgrey: "#a9a9a9",
    lightseagreen: "#20b2aa",
    cyan: "#00ffff",
    mintcream: "#f5fffa",
    silver: "#c0c0c0",
    antiquewhite: "#faebd7",
    mediumorchid: "#ba55d3",
    skyblue: "#87ceeb",
    gray: "#808080",
    darkturquoise: "#00ced1",
    goldenrod: "#daa520",
    darkgreen: "#006400",
    floralwhite: "#fffaf0",
    darkviolet: "#9400d3",
    darkgray: "#a9a9a9",
    moccasin: "#ffe4b5",
    saddlebrown: "#8b4513",
    grey: "#808080",
    darkslateblue: "#483d8b",
    lightskyblue: "#87cefa",
    lightpink: "#ffb6c1",
    mediumvioletred: "#c71585",
    slategrey: "#708090",
    red: "#ff0000",
    deeppink: "#ff1493",
    limegreen: "#32cd32",
    darkmagenta: "#8b008b",
    palegoldenrod: "#eee8aa",
    plum: "#dda0dd",
    turquoise: "#40e0d0",
    lightgrey: "#d3d3d3",
    lightgoldenrodyellow: "#fafad2",
    darkgoldenrod: "#b8860b",
    lavender: "#e6e6fa",
    maroon: "#800000",
    yellowgreen: "#9acd32",
    sandybrown: "#f4a460",
    thistle: "#d8bfd8",
    violet: "#ee82ee",
    navy: "#000080",
    magenta: "#ff00ff",
    dimgrey: "#696969",
    tan: "#d2b48c",
    rosybrown: "#bc8f8f",
    olivedrab: "#6b8e23",
    blue: "#0000ff",
    lightblue: "#add8e6",
    ghostwhite: "#f8f8ff",
    honeydew: "#f0fff0",
    cornflowerblue: "#6495ed",
    slateblue: "#6a5acd",
    linen: "#faf0e6",
    darkblue: "#00008b",
    powderblue: "#b0e0e6",
    seagreen: "#2e8b57",
    darkkhaki: "#bdb76b",
    snow: "#fffafa",
    sienna: "#a0522d",
    mediumblue: "#0000cd",
    royalblue: "#4169e1",
    lightcyan: "#e0ffff",
    green: "#008000",
    mediumpurple: "#9370db",
    midnightblue: "#191970",
    cornsilk: "#fff8dc",
    paleturquoise: "#afeeee",
    bisque: "#ffe4c4",
    slategray: "#708090",
    darkcyan: "#008b8b",
    khaki: "#f0e68c",
    wheat: "#f5deb3",
    teal: "#008080",
    darkorchid: "#9932cc",
    deepskyblue: "#00bfff",
    salmon: "#fa8072",
    darkred: "#8b0000",
    steelblue: "#4682b4",
    palevioletred: "#db7093",
    lightslategray: "#778899",
    aliceblue: "#f0f8ff",
    lightslategrey: "#778899",
    lightgreen: "#90ee90",
    orchid: "#da70d6",
    gainsboro: "#dcdcdc",
    mediumseagreen: "#3cb371",
    lightgray: "#d3d3d3",
    mediumturquoise: "#48d1cc",
    lemonchiffon: "#fffacd",
    cadetblue: "#5f9ea0",
    lightyellow: "#ffffe0",
    lavenderblush: "#fff0f5",
    coral: "#ff7f50",
    purple: "#800080",
    aqua: "#00ffff",
    whitesmoke: "#f5f5f5",
    mediumslateblue: "#7b68ee",
    darkorange: "#ff8c00",
    mediumaquamarine: "#66cdaa",
    darksalmon: "#e9967a",
    beige: "#f5f5dc",
    blueviolet: "#8a2be2",
    azure: "#f0ffff",
    lightsteelblue: "#b0c4de",
    oldlace: "#fdf5e6",
    rebeccapurple: "#663399"
  };
  chroma.colors = colors = w3cx11;

  lab2rgb = function lab2rgb() {
    var a, b, g, l, r, ref, ref1, ref2, x, y, z;
    ref = unpack(arguments), l = ref[0], a = ref[1], b = ref[2];
    /*
    adapted to match d3 implementation
     */

    if (l !== void 0 && l.length === 3) {
      ref1 = l, l = ref1[0], a = ref1[1], b = ref1[2];
    }

    if (l !== void 0 && l.length === 3) {
      ref2 = l, l = ref2[0], a = ref2[1], b = ref2[2];
    }

    y = (l + 16) / 116;
    x = y + a / 500;
    z = y - b / 200;
    x = lab_xyz(x) * LAB_CONSTANTS.X;
    y = lab_xyz(y) * LAB_CONSTANTS.Y;
    z = lab_xyz(z) * LAB_CONSTANTS.Z;
    r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
    g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
    b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), 1];
  };

  lab_xyz = function lab_xyz(x) {
    if (x > 0.206893034) {
      return x * x * x;
    } else {
      return (x - 4 / 29) / 7.787037;
    }
  };

  xyz_rgb = function xyz_rgb(r) {
    return round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow(r, 1 / 2.4) - 0.055));
  };

  LAB_CONSTANTS = {
    K: 18,
    X: 0.950470,
    Y: 1,
    Z: 1.088830
  };

  rgb2lab = function rgb2lab() {
    var b, g, r, ref, ref1, x, y, z;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    ref1 = rgb2xyz(r, g, b), x = ref1[0], y = ref1[1], z = ref1[2];
    return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
  };

  rgb_xyz = function rgb_xyz(r) {
    if ((r /= 255) <= 0.04045) {
      return r / 12.92;
    } else {
      return pow((r + 0.055) / 1.055, 2.4);
    }
  };

  xyz_lab = function xyz_lab(x) {
    if (x > 0.008856) {
      return pow(x, 1 / 3);
    } else {
      return 7.787037 * x + 4 / 29;
    }
  };

  rgb2xyz = function rgb2xyz() {
    var b, g, r, ref, x, y, z;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    r = rgb_xyz(r);
    g = rgb_xyz(g);
    b = rgb_xyz(b);
    x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.X);
    y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS.Y);
    z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS.Z);
    return [x, y, z];
  };

  chroma.lab = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['lab']), function () {});
  };

  _input.lab = lab2rgb;

  Color.prototype.lab = function () {
    return rgb2lab(this._rgb);
  };

  _bezier = function bezier(colors) {
    var I, I0, I1, c, lab0, lab1, lab2, lab3, ref, ref1, ref2;

    colors = function () {
      var len, o, results;
      results = [];

      for (o = 0, len = colors.length; o < len; o++) {
        c = colors[o];
        results.push(chroma(c));
      }

      return results;
    }();

    if (colors.length === 2) {
      ref = function () {
        var len, o, results;
        results = [];

        for (o = 0, len = colors.length; o < len; o++) {
          c = colors[o];
          results.push(c.lab());
        }

        return results;
      }(), lab0 = ref[0], lab1 = ref[1];

      I = function I(t) {
        var i, lab;

        lab = function () {
          var o, results;
          results = [];

          for (i = o = 0; o <= 2; i = ++o) {
            results.push(lab0[i] + t * (lab1[i] - lab0[i]));
          }

          return results;
        }();

        return chroma.lab.apply(chroma, lab);
      };
    } else if (colors.length === 3) {
      ref1 = function () {
        var len, o, results;
        results = [];

        for (o = 0, len = colors.length; o < len; o++) {
          c = colors[o];
          results.push(c.lab());
        }

        return results;
      }(), lab0 = ref1[0], lab1 = ref1[1], lab2 = ref1[2];

      I = function I(t) {
        var i, lab;

        lab = function () {
          var o, results;
          results = [];

          for (i = o = 0; o <= 2; i = ++o) {
            results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);
          }

          return results;
        }();

        return chroma.lab.apply(chroma, lab);
      };
    } else if (colors.length === 4) {
      ref2 = function () {
        var len, o, results;
        results = [];

        for (o = 0, len = colors.length; o < len; o++) {
          c = colors[o];
          results.push(c.lab());
        }

        return results;
      }(), lab0 = ref2[0], lab1 = ref2[1], lab2 = ref2[2], lab3 = ref2[3];

      I = function I(t) {
        var i, lab;

        lab = function () {
          var o, results;
          results = [];

          for (i = o = 0; o <= 2; i = ++o) {
            results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);
          }

          return results;
        }();

        return chroma.lab.apply(chroma, lab);
      };
    } else if (colors.length === 5) {
      I0 = _bezier(colors.slice(0, 3));
      I1 = _bezier(colors.slice(2, 5));

      I = function I(t) {
        if (t < 0.5) {
          return I0(t * 2);
        } else {
          return I1((t - 0.5) * 2);
        }
      };
    }

    return I;
  };

  chroma.bezier = _bezier;
  /*
      chroma.js

      Copyright (c) 2011-2013, Gregor Aisch
      All rights reserved.

      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright notice, this
        list of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation
        and/or other materials provided with the distribution.

      * The name Gregor Aisch may not be used to endorse or promote products
        derived from this software without specific prior written permission.

      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

      @source: https://github.com/gka/chroma.js
   */

  chroma.cubehelix = function (start, rotations, hue, gamma, lightness) {
    var dh, dl;

    if (start == null) {
      start = 300;
    }

    if (rotations == null) {
      rotations = -1.5;
    }

    if (hue == null) {
      hue = 1;
    }

    if (gamma == null) {
      gamma = 1;
    }

    if (lightness == null) {
      lightness = [0, 1];
    }

    dl = lightness[1] - lightness[0];

    if (type(hue) === 'array') {
      dh = hue[1] - hue[0];

      if (dh === 0) {
        hue = hue[1];
      }
    } else {
      dh = 0;
    }

    return function (fract) {
      var a, amp, b, cos_a, g, h, l, r, sin_a;
      a = TWOPI * ((start + 120) / 360 + rotations * fract);
      l = pow(lightness[0] + dl * fract, gamma);
      h = dh !== 0 ? hue[0] + fract * dh : hue;
      amp = h * l * (1 - l) / 2;
      cos_a = cos(a);
      sin_a = sin(a);
      r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
      g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
      b = l + amp * (+1.97294 * cos_a);
      return chroma(clip_rgb([r * 255, g * 255, b * 255]));
    };
  };

  chroma.random = function () {
    var code, digits, i, o;
    digits = '0123456789abcdef';
    code = '#';

    for (i = o = 0; o < 6; i = ++o) {
      code += digits.charAt(floor(Math.random() * 16));
    }

    return new Color(code);
  };

  _input.rgb = function () {
    var k, ref, results, v;
    ref = unpack(arguments);
    results = [];

    for (k in ref) {
      v = ref[k];
      results.push(v);
    }

    return results;
  };

  chroma.rgb = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['rgb']), function () {});
  };

  Color.prototype.rgb = function () {
    return this._rgb.slice(0, 3);
  };

  Color.prototype.rgba = function () {
    return this._rgb;
  };

  _guess_formats.push({
    p: 15,
    test: function test(n) {
      var a;
      a = unpack(arguments);

      if (type(a) === 'array' && a.length === 3) {
        return 'rgb';
      }

      if (a.length === 4 && type(a[3]) === "number" && a[3] >= 0 && a[3] <= 1) {
        return 'rgb';
      }
    }
  });

  hex2rgb = function hex2rgb(hex) {
    var a, b, g, r, rgb, u;

    if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
      if (hex.length === 4 || hex.length === 7) {
        hex = hex.substr(1);
      }

      if (hex.length === 3) {
        hex = hex.split("");
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }

      u = parseInt(hex, 16);
      r = u >> 16;
      g = u >> 8 & 0xFF;
      b = u & 0xFF;
      return [r, g, b, 1];
    }

    if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {
      if (hex.length === 9) {
        hex = hex.substr(1);
      }

      u = parseInt(hex, 16);
      r = u >> 24 & 0xFF;
      g = u >> 16 & 0xFF;
      b = u >> 8 & 0xFF;
      a = round((u & 0xFF) / 0xFF * 100) / 100;
      return [r, g, b, a];
    }

    if (_input.css != null && (rgb = _input.css(hex))) {
      return rgb;
    }

    throw "unknown color: " + hex;
  };

  rgb2hex = function rgb2hex(channels, mode) {
    var a, b, g, hxa, r, str, u;

    if (mode == null) {
      mode = 'rgb';
    }

    r = channels[0], g = channels[1], b = channels[2], a = channels[3];
    u = r << 16 | g << 8 | b;
    str = "000000" + u.toString(16);
    str = str.substr(str.length - 6);
    hxa = '0' + round(a * 255).toString(16);
    hxa = hxa.substr(hxa.length - 2);
    return "#" + function () {
      switch (mode.toLowerCase()) {
        case 'rgba':
          return str + hxa;

        case 'argb':
          return hxa + str;

        default:
          return str;
      }
    }();
  };

  _input.hex = function (h) {
    return hex2rgb(h);
  };

  chroma.hex = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hex']), function () {});
  };

  Color.prototype.hex = function (mode) {
    if (mode == null) {
      mode = 'rgb';
    }

    return rgb2hex(this._rgb, mode);
  };

  _guess_formats.push({
    p: 10,
    test: function test(n) {
      if (arguments.length === 1 && type(n) === "string") {
        return 'hex';
      }
    }
  });

  hsl2rgb = function hsl2rgb() {
    var b, c, g, h, i, l, o, r, ref, ref1, s, t1, t2, t3;
    ref = unpack(arguments), h = ref[0], s = ref[1], l = ref[2];

    if (s === 0) {
      r = g = b = l * 255;
    } else {
      t3 = [0, 0, 0];
      c = [0, 0, 0];
      t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
      t1 = 2 * l - t2;
      h /= 360;
      t3[0] = h + 1 / 3;
      t3[1] = h;
      t3[2] = h - 1 / 3;

      for (i = o = 0; o <= 2; i = ++o) {
        if (t3[i] < 0) {
          t3[i] += 1;
        }

        if (t3[i] > 1) {
          t3[i] -= 1;
        }

        if (6 * t3[i] < 1) {
          c[i] = t1 + (t2 - t1) * 6 * t3[i];
        } else if (2 * t3[i] < 1) {
          c[i] = t2;
        } else if (3 * t3[i] < 2) {
          c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;
        } else {
          c[i] = t1;
        }
      }

      ref1 = [round(c[0] * 255), round(c[1] * 255), round(c[2] * 255)], r = ref1[0], g = ref1[1], b = ref1[2];
    }

    if (arguments.length === 4) {
      return [r, g, b, arguments[3]];
    } else {
      return [r, g, b];
    }
  };

  rgb2hsl = function rgb2hsl(r, g, b) {
    var h, l, min, ref, s;

    if (r !== void 0 && r.length >= 3) {
      ref = r, r = ref[0], g = ref[1], b = ref[2];
    }

    r /= 255;
    g /= 255;
    b /= 255;
    min = Math.min(r, g, b);
    max = Math.max(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      s = 0;
      h = Number.NaN;
    } else {
      s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
    }

    if (r === max) {
      h = (g - b) / (max - min);
    } else if (g === max) {
      h = 2 + (b - r) / (max - min);
    } else if (b === max) {
      h = 4 + (r - g) / (max - min);
    }

    h *= 60;

    if (h < 0) {
      h += 360;
    }

    return [h, s, l];
  };

  chroma.hsl = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hsl']), function () {});
  };

  _input.hsl = hsl2rgb;

  Color.prototype.hsl = function () {
    return rgb2hsl(this._rgb);
  };

  hsv2rgb = function hsv2rgb() {
    var b, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, t, v;
    ref = unpack(arguments), h = ref[0], s = ref[1], v = ref[2];
    v *= 255;

    if (s === 0) {
      r = g = b = v;
    } else {
      if (h === 360) {
        h = 0;
      }

      if (h > 360) {
        h -= 360;
      }

      if (h < 0) {
        h += 360;
      }

      h /= 60;
      i = floor(h);
      f = h - i;
      p = v * (1 - s);
      q = v * (1 - s * f);
      t = v * (1 - s * (1 - f));

      switch (i) {
        case 0:
          ref1 = [v, t, p], r = ref1[0], g = ref1[1], b = ref1[2];
          break;

        case 1:
          ref2 = [q, v, p], r = ref2[0], g = ref2[1], b = ref2[2];
          break;

        case 2:
          ref3 = [p, v, t], r = ref3[0], g = ref3[1], b = ref3[2];
          break;

        case 3:
          ref4 = [p, q, v], r = ref4[0], g = ref4[1], b = ref4[2];
          break;

        case 4:
          ref5 = [t, p, v], r = ref5[0], g = ref5[1], b = ref5[2];
          break;

        case 5:
          ref6 = [v, p, q], r = ref6[0], g = ref6[1], b = ref6[2];
      }
    }

    r = round(r);
    g = round(g);
    b = round(b);
    return [r, g, b];
  };

  rgb2hsv = function rgb2hsv() {
    var b, delta, g, h, min, r, ref, s, v;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    min = Math.min(r, g, b);
    max = Math.max(r, g, b);
    delta = max - min;
    v = max / 255.0;

    if (max === 0) {
      h = Number.NaN;
      s = 0;
    } else {
      s = delta / max;

      if (r === max) {
        h = (g - b) / delta;
      }

      if (g === max) {
        h = 2 + (b - r) / delta;
      }

      if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h *= 60;

      if (h < 0) {
        h += 360;
      }
    }

    return [h, s, v];
  };

  chroma.hsv = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hsv']), function () {});
  };

  _input.hsv = hsv2rgb;

  Color.prototype.hsv = function () {
    return rgb2hsv(this._rgb);
  };

  num2rgb = function num2rgb(num) {
    var b, g, r;

    if (type(num) === "number" && num >= 0 && num <= 0xFFFFFF) {
      r = num >> 16;
      g = num >> 8 & 0xFF;
      b = num & 0xFF;
      return [r, g, b, 1];
    }

    console.warn("unknown num color: " + num);
    return [0, 0, 0, 1];
  };

  rgb2num = function rgb2num() {
    var b, g, r, ref;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    return (r << 16) + (g << 8) + b;
  };

  chroma.num = function (num) {
    return new Color(num, 'num');
  };

  Color.prototype.num = function () {
    return rgb2num(this._rgb);
  };

  _input.num = num2rgb;

  _guess_formats.push({
    p: 10,
    test: function test(n) {
      if (arguments.length === 1 && type(n) === "number" && n >= 0 && n <= 0xFFFFFF) {
        return 'num';
      }
    }
  });

  css2rgb = function css2rgb(css) {
    var aa, ab, hsl, i, m, o, rgb, w;
    css = css.toLowerCase();

    if (chroma.colors != null && chroma.colors[css]) {
      return hex2rgb(chroma.colors[css]);
    }

    if (m = css.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
      rgb = m.slice(1, 4);

      for (i = o = 0; o <= 2; i = ++o) {
        rgb[i] = +rgb[i];
      }

      rgb[3] = 1;
    } else if (m = css.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/)) {
      rgb = m.slice(1, 5);

      for (i = w = 0; w <= 3; i = ++w) {
        rgb[i] = +rgb[i];
      }
    } else if (m = css.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
      rgb = m.slice(1, 4);

      for (i = aa = 0; aa <= 2; i = ++aa) {
        rgb[i] = round(rgb[i] * 2.55);
      }

      rgb[3] = 1;
    } else if (m = css.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
      rgb = m.slice(1, 5);

      for (i = ab = 0; ab <= 2; i = ++ab) {
        rgb[i] = round(rgb[i] * 2.55);
      }

      rgb[3] = +rgb[3];
    } else if (m = css.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
      hsl = m.slice(1, 4);
      hsl[1] *= 0.01;
      hsl[2] *= 0.01;
      rgb = hsl2rgb(hsl);
      rgb[3] = 1;
    } else if (m = css.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
      hsl = m.slice(1, 4);
      hsl[1] *= 0.01;
      hsl[2] *= 0.01;
      rgb = hsl2rgb(hsl);
      rgb[3] = +m[4];
    }

    return rgb;
  };

  rgb2css = function rgb2css(rgba) {
    var mode;
    mode = rgba[3] < 1 ? 'rgba' : 'rgb';

    if (mode === 'rgb') {
      return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ')';
    } else if (mode === 'rgba') {
      return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ',' + rgba[3] + ')';
    } else {}
  };

  rnd = function rnd(a) {
    return round(a * 100) / 100;
  };

  hsl2css = function hsl2css(hsl, alpha) {
    var mode;
    mode = alpha < 1 ? 'hsla' : 'hsl';
    hsl[0] = rnd(hsl[0] || 0);
    hsl[1] = rnd(hsl[1] * 100) + '%';
    hsl[2] = rnd(hsl[2] * 100) + '%';

    if (mode === 'hsla') {
      hsl[3] = alpha;
    }

    return mode + '(' + hsl.join(',') + ')';
  };

  _input.css = function (h) {
    return css2rgb(h);
  };

  chroma.css = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['css']), function () {});
  };

  Color.prototype.css = function (mode) {
    if (mode == null) {
      mode = 'rgb';
    }

    if (mode.slice(0, 3) === 'rgb') {
      return rgb2css(this._rgb);
    } else if (mode.slice(0, 3) === 'hsl') {
      return hsl2css(this.hsl(), this.alpha());
    }
  };

  _input.named = function (name) {
    return hex2rgb(w3cx11[name]);
  };

  _guess_formats.push({
    p: 20,
    test: function test(n) {
      if (arguments.length === 1 && w3cx11[n] != null) {
        return 'named';
      }
    }
  });

  Color.prototype.name = function (n) {
    var h, k;

    if (arguments.length) {
      if (w3cx11[n]) {
        this._rgb = hex2rgb(w3cx11[n]);
      }

      this._rgb[3] = 1;
      this;
    }

    h = this.hex();

    for (k in w3cx11) {
      if (h === w3cx11[k]) {
        return k;
      }
    }

    return h;
  };

  lch2lab = function lch2lab() {
    /*
    Convert from a qualitative parameter h and a quantitative parameter l to a 24-bit pixel.
    These formulas were invented by David Dalrymple to obtain maximum contrast without going
    out of gamut if the parameters are in the range 0-1.

    A saturation multiplier was added by Gregor Aisch
     */
    var c, h, l, ref;
    ref = unpack(arguments), l = ref[0], c = ref[1], h = ref[2];
    h = h * PI / 180;
    return [l, cos(h) * c, sin(h) * c];
  };

  lch2rgb = function lch2rgb() {
    var L, a, b, c, g, h, l, r, ref, ref1, ref2;
    ref = unpack(arguments), l = ref[0], c = ref[1], h = ref[2];
    ref1 = lch2lab(l, c, h), L = ref1[0], a = ref1[1], b = ref1[2];
    ref2 = lab2rgb(L, a, b), r = ref2[0], g = ref2[1], b = ref2[2];
    return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255)];
  };

  lab2lch = function lab2lch() {
    var a, b, c, h, l, ref;
    ref = unpack(arguments), l = ref[0], a = ref[1], b = ref[2];
    c = sqrt(a * a + b * b);
    h = (atan2(b, a) / PI * 180 + 360) % 360;
    return [l, c, h];
  };

  rgb2lch = function rgb2lch() {
    var a, b, g, l, r, ref, ref1;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    ref1 = rgb2lab(r, g, b), l = ref1[0], a = ref1[1], b = ref1[2];
    return lab2lch(l, a, b);
  };

  chroma.lch = function () {
    var args;
    args = unpack(arguments);
    return new Color(args, 'lch');
  };

  chroma.hcl = function () {
    var args;
    args = unpack(arguments);
    return new Color(args, 'hcl');
  };

  _input.lch = lch2rgb;

  _input.hcl = function () {
    var c, h, l, ref;
    ref = unpack(arguments), h = ref[0], c = ref[1], l = ref[2];
    return lch2rgb([l, c, h]);
  };

  Color.prototype.lch = function () {
    return rgb2lch(this._rgb);
  };

  Color.prototype.hcl = function () {
    return rgb2lch(this._rgb).reverse();
  };

  rgb2cmyk = function rgb2cmyk(mode) {
    var b, c, f, g, k, m, r, ref, y;

    if (mode == null) {
      mode = 'rgb';
    }

    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    r = r / 255;
    g = g / 255;
    b = b / 255;
    k = 1 - Math.max(r, Math.max(g, b));
    f = k < 1 ? 1 / (1 - k) : 0;
    c = (1 - r - k) * f;
    m = (1 - g - k) * f;
    y = (1 - b - k) * f;
    return [c, m, y, k];
  };

  cmyk2rgb = function cmyk2rgb() {
    var b, c, g, k, m, r, ref, y;
    ref = unpack(arguments), c = ref[0], m = ref[1], y = ref[2], k = ref[3];

    if (k === 1) {
      return [0, 0, 0];
    }

    r = c >= 1 ? 0 : round(255 * (1 - c) * (1 - k));
    g = m >= 1 ? 0 : round(255 * (1 - m) * (1 - k));
    b = y >= 1 ? 0 : round(255 * (1 - y) * (1 - k));
    return [r, g, b];
  };

  _input.cmyk = function () {
    var c, k, m, ref, y;
    ref = unpack(arguments), c = ref[0], m = ref[1], y = ref[2], k = ref[3];
    return cmyk2rgb(c, m, y, k);
  };

  chroma.cmyk = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['cmyk']), function () {});
  };

  Color.prototype.cmyk = function () {
    return rgb2cmyk(this._rgb);
  };

  _input.gl = function () {
    var i, k, o, rgb, v;

    rgb = function () {
      var ref, results;
      ref = unpack(arguments);
      results = [];

      for (k in ref) {
        v = ref[k];
        results.push(v);
      }

      return results;
    }.apply(this, arguments);

    for (i = o = 0; o <= 2; i = ++o) {
      rgb[i] *= 255;
    }

    return rgb;
  };

  chroma.gl = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['gl']), function () {});
  };

  Color.prototype.gl = function () {
    var rgb;
    rgb = this._rgb;
    return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];
  };

  rgb2luminance = function rgb2luminance(r, g, b) {
    var ref;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    r = luminance_x(r);
    g = luminance_x(g);
    b = luminance_x(b);
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  };

  luminance_x = function luminance_x(x) {
    x /= 255;

    if (x <= 0.03928) {
      return x / 12.92;
    } else {
      return pow((x + 0.055) / 1.055, 2.4);
    }
  };

  _interpolators = [];

  interpolate = function interpolate(col1, col2, f, m) {
    var interpol, len, o, res;

    if (f == null) {
      f = 0.5;
    }

    if (m == null) {
      m = 'rgb';
    }
    /*
    interpolates between colors
    f = 0 --> me
    f = 1 --> col
     */


    if (type(col1) !== 'object') {
      col1 = chroma(col1);
    }

    if (type(col2) !== 'object') {
      col2 = chroma(col2);
    }

    for (o = 0, len = _interpolators.length; o < len; o++) {
      interpol = _interpolators[o];

      if (m === interpol[0]) {
        res = interpol[1](col1, col2, f, m);
        break;
      }
    }

    if (res == null) {
      throw "color mode " + m + " is not supported";
    }

    res.alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
    return res;
  };

  chroma.interpolate = interpolate;

  Color.prototype.interpolate = function (col2, f, m) {
    return interpolate(this, col2, f, m);
  };

  chroma.mix = interpolate;
  Color.prototype.mix = Color.prototype.interpolate;

  interpolate_rgb = function interpolate_rgb(col1, col2, f, m) {
    var xyz0, xyz1;
    xyz0 = col1._rgb;
    xyz1 = col2._rgb;
    return new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
  };

  _interpolators.push(['rgb', interpolate_rgb]);

  Color.prototype.luminance = function (lum, mode) {
    var cur_lum, eps, max_iter, _test;

    if (mode == null) {
      mode = 'rgb';
    }

    if (!arguments.length) {
      return rgb2luminance(this._rgb);
    }

    if (lum === 0) {
      this._rgb = [0, 0, 0, this._rgb[3]];
    } else if (lum === 1) {
      this._rgb = [255, 255, 255, this._rgb[3]];
    } else {
      eps = 1e-7;
      max_iter = 20;

      _test = function test(l, h) {
        var lm, m;
        m = l.interpolate(h, 0.5, mode);
        lm = m.luminance();

        if (Math.abs(lum - lm) < eps || !max_iter--) {
          return m;
        }

        if (lm > lum) {
          return _test(l, m);
        }

        return _test(m, h);
      };

      cur_lum = rgb2luminance(this._rgb);
      this._rgb = (cur_lum > lum ? _test(chroma('black'), this) : _test(this, chroma('white'))).rgba();
    }

    return this;
  };

  temperature2rgb = function temperature2rgb(kelvin) {
    var b, g, r, temp;
    temp = kelvin / 100;

    if (temp < 66) {
      r = 255;
      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);
      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);
    } else {
      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);
      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);
      b = 255;
    }

    return clip_rgb([r, g, b]);
  };

  rgb2temperature = function rgb2temperature() {
    var b, eps, g, maxTemp, minTemp, r, ref, rgb, temp;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    minTemp = 1000;
    maxTemp = 40000;
    eps = 0.4;

    while (maxTemp - minTemp > eps) {
      temp = (maxTemp + minTemp) * 0.5;
      rgb = temperature2rgb(temp);

      if (rgb[2] / rgb[0] >= b / r) {
        maxTemp = temp;
      } else {
        minTemp = temp;
      }
    }

    return round(temp);
  };

  chroma.temperature = chroma.kelvin = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['temperature']), function () {});
  };

  _input.temperature = _input.kelvin = _input.K = temperature2rgb;

  Color.prototype.temperature = function () {
    return rgb2temperature(this._rgb);
  };

  Color.prototype.kelvin = Color.prototype.temperature;

  chroma.contrast = function (a, b) {
    var l1, l2, ref, ref1;

    if ((ref = type(a)) === 'string' || ref === 'number') {
      a = new Color(a);
    }

    if ((ref1 = type(b)) === 'string' || ref1 === 'number') {
      b = new Color(b);
    }

    l1 = a.luminance();
    l2 = b.luminance();

    if (l1 > l2) {
      return (l1 + 0.05) / (l2 + 0.05);
    } else {
      return (l2 + 0.05) / (l1 + 0.05);
    }
  };

  Color.prototype.darken = function (amount) {
    var lch, me;

    if (amount == null) {
      amount = 20;
    }

    me = this;
    lch = me.lch();
    lch[0] -= amount;
    return chroma.lch(lch).alpha(me.alpha());
  };

  Color.prototype.darker = Color.prototype.darken;

  Color.prototype.brighten = function (amount) {
    if (amount == null) {
      amount = 20;
    }

    return this.darken(-amount);
  };

  Color.prototype.brighter = Color.prototype.brighten;

  Color.prototype.saturate = function (amount) {
    var lch, me;

    if (amount == null) {
      amount = 20;
    }

    me = this;
    lch = me.lch();
    lch[1] += amount;

    if (lch[1] < 0) {
      lch[1] = 0;
    }

    return chroma.lch(lch).alpha(me.alpha());
  };

  Color.prototype.desaturate = function (amount) {
    if (amount == null) {
      amount = 20;
    }

    return this.saturate(-amount);
  };

  Color.prototype.premultiply = function () {
    var a, rgb;
    rgb = this.rgb();
    a = this.alpha();
    return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);
  };

  _blend = function blend(bottom, top, mode) {
    if (!_blend[mode]) {
      throw 'unknown blend mode ' + mode;
    }

    return _blend[mode](bottom, top);
  };

  blend_f = function blend_f(f) {
    return function (bottom, top) {
      var c0, c1;
      c0 = chroma(top).rgb();
      c1 = chroma(bottom).rgb();
      return chroma(f(c0, c1), 'rgb');
    };
  };

  each = function each(f) {
    return function (c0, c1) {
      var i, o, out;
      out = [];

      for (i = o = 0; o <= 3; i = ++o) {
        out[i] = f(c0[i], c1[i]);
      }

      return out;
    };
  };

  normal = function normal(a, b) {
    return a;
  };

  multiply = function multiply(a, b) {
    return a * b / 255;
  };

  darken = function darken(a, b) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  };

  lighten = function lighten(a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };

  screen = function screen(a, b) {
    return 255 * (1 - (1 - a / 255) * (1 - b / 255));
  };

  overlay = function overlay(a, b) {
    if (b < 128) {
      return 2 * a * b / 255;
    } else {
      return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
    }
  };

  burn = function burn(a, b) {
    return 255 * (1 - (1 - b / 255) / (a / 255));
  };

  dodge = function dodge(a, b) {
    if (a === 255) {
      return 255;
    }

    a = 255 * (b / 255) / (1 - a / 255);

    if (a > 255) {
      return 255;
    } else {
      return a;
    }
  };

  _blend.normal = blend_f(each(normal));
  _blend.multiply = blend_f(each(multiply));
  _blend.screen = blend_f(each(screen));
  _blend.overlay = blend_f(each(overlay));
  _blend.darken = blend_f(each(darken));
  _blend.lighten = blend_f(each(lighten));
  _blend.dodge = blend_f(each(dodge));
  _blend.burn = blend_f(each(burn));
  chroma.blend = _blend;
  /*
      chroma.js

      Copyright (c) 2011-2013, Gregor Aisch
      All rights reserved.

      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright notice, this
        list of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation
        and/or other materials provided with the distribution.

      * The name Gregor Aisch may not be used to endorse or promote products
        derived from this software without specific prior written permission.

      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

      @source: https://github.com/gka/chroma.js
   */

  chroma.scale = function (colors, positions) {
    var _colorCache, _colors, _correctLightness, _domain, _fixed, _max, _min, _mode, _nacol, _numClasses, _out, _pos, _spread, classifyValue, f, getClass, getColor, resetCache, setColors, setDomain, tmap;

    _mode = 'rgb';
    _nacol = chroma('#ccc');
    _spread = 0;
    _fixed = false;
    _domain = [0, 1];
    _colors = [];
    _out = false;
    _pos = [];
    _min = 0;
    _max = 1;
    _correctLightness = false;
    _numClasses = 0;
    _colorCache = {};

    setColors = function setColors(colors, positions) {
      var c, col, o, ref, ref1, ref2, w;

      if (colors == null) {
        colors = ['#ddd', '#222'];
      }

      if (colors != null && type(colors) === 'string' && ((ref = chroma.brewer) != null ? ref[colors] : void 0) != null) {
        colors = chroma.brewer[colors];
      }

      if (type(colors) === 'array') {
        colors = colors.slice(0);

        for (c = o = 0, ref1 = colors.length - 1; 0 <= ref1 ? o <= ref1 : o >= ref1; c = 0 <= ref1 ? ++o : --o) {
          col = colors[c];

          if (type(col) === "string") {
            colors[c] = chroma(col);
          }
        }

        if (positions != null) {
          _pos = positions;
        } else {
          _pos = [];

          for (c = w = 0, ref2 = colors.length - 1; 0 <= ref2 ? w <= ref2 : w >= ref2; c = 0 <= ref2 ? ++w : --w) {
            _pos.push(c / (colors.length - 1));
          }
        }
      }

      resetCache();
      return _colors = colors;
    };

    setDomain = function setDomain(domain) {
      if (domain == null) {
        domain = [];
      }
      /*
       * use this if you want to display a limited number of data classes
       * possible methods are "equalinterval", "quantiles", "custom"
       */


      _domain = domain;
      _min = domain[0];
      _max = domain[domain.length - 1];
      resetCache();

      if (domain.length === 2) {
        return _numClasses = 0;
      } else {
        return _numClasses = domain.length - 1;
      }
    };

    getClass = function getClass(value) {
      var i, n;

      if (_domain != null) {
        n = _domain.length - 1;
        i = 0;

        while (i < n && value >= _domain[i]) {
          i++;
        }

        return i - 1;
      }

      return 0;
    };

    tmap = function tmap(t) {
      return t;
    };

    classifyValue = function classifyValue(value) {
      var i, maxc, minc, n, val;
      val = value;

      if (_domain.length > 2) {
        n = _domain.length - 1;
        i = getClass(value);
        minc = _domain[0] + (_domain[1] - _domain[0]) * (0 + _spread * 0.5);
        maxc = _domain[n - 1] + (_domain[n] - _domain[n - 1]) * (1 - _spread * 0.5);
        val = _min + (_domain[i] + (_domain[i + 1] - _domain[i]) * 0.5 - minc) / (maxc - minc) * (_max - _min);
      }

      return val;
    };

    getColor = function getColor(val, bypassMap) {
      var c, col, f0, i, k, o, p, ref, t;

      if (bypassMap == null) {
        bypassMap = false;
      }

      if (isNaN(val)) {
        return _nacol;
      }

      if (!bypassMap) {
        if (_domain.length > 2) {
          c = getClass(val);
          t = c / (_numClasses - 1);
        } else {
          t = f0 = _min !== _max ? (val - _min) / (_max - _min) : 0;
          t = f0 = (val - _min) / (_max - _min);
          t = Math.min(1, Math.max(0, t));
        }
      } else {
        t = val;
      }

      if (!bypassMap) {
        t = tmap(t);
      }

      k = Math.floor(t * 10000);

      if (_colorCache[k]) {
        col = _colorCache[k];
      } else {
        if (type(_colors) === 'array') {
          for (i = o = 0, ref = _pos.length - 1; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
            p = _pos[i];

            if (t <= p) {
              col = _colors[i];
              break;
            }

            if (t >= p && i === _pos.length - 1) {
              col = _colors[i];
              break;
            }

            if (t > p && t < _pos[i + 1]) {
              t = (t - p) / (_pos[i + 1] - p);
              col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);
              break;
            }
          }
        } else if (type(_colors) === 'function') {
          col = _colors(t);
        }

        _colorCache[k] = col;
      }

      return col;
    };

    resetCache = function resetCache() {
      return _colorCache = {};
    };

    setColors(colors, positions);

    f = function f(v) {
      var c;
      c = getColor(v);

      if (_out && c[_out]) {
        return c[_out]();
      } else {
        return c;
      }
    };

    f.domain = function (domain, classes, mode, key) {
      var d;

      if (mode == null) {
        mode = 'e';
      }

      if (!arguments.length) {
        return _domain;
      }

      if (classes != null) {
        d = chroma.analyze(domain, key);

        if (classes === 0) {
          domain = [d.min, d.max];
        } else {
          domain = chroma.limits(d, mode, classes);
        }
      }

      setDomain(domain);
      return f;
    };

    f.mode = function (_m) {
      if (!arguments.length) {
        return _mode;
      }

      _mode = _m;
      resetCache();
      return f;
    };

    f.range = function (colors, _pos) {
      setColors(colors, _pos);
      return f;
    };

    f.out = function (_o) {
      _out = _o;
      return f;
    };

    f.spread = function (val) {
      if (!arguments.length) {
        return _spread;
      }

      _spread = val;
      return f;
    };

    f.correctLightness = function (v) {
      if (!arguments.length) {
        return _correctLightness;
      }

      _correctLightness = v;
      resetCache();

      if (_correctLightness) {
        tmap = function tmap(t) {
          var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;
          L0 = getColor(0, true).lab()[0];
          L1 = getColor(1, true).lab()[0];
          pol = L0 > L1;
          L_actual = getColor(t, true).lab()[0];
          L_ideal = L0 + (L1 - L0) * t;
          L_diff = L_actual - L_ideal;
          t0 = 0;
          t1 = 1;
          max_iter = 20;

          while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {
            (function () {
              if (pol) {
                L_diff *= -1;
              }

              if (L_diff < 0) {
                t0 = t;
                t += (t1 - t) * 0.5;
              } else {
                t1 = t;
                t += (t0 - t) * 0.5;
              }

              L_actual = getColor(t, true).lab()[0];
              return L_diff = L_actual - L_ideal;
            })();
          }

          return t;
        };
      } else {
        tmap = function tmap(t) {
          return t;
        };
      }

      return f;
    };

    f.colors = function () {
      var aa, i, len, numColors, o, out, ref, results, samples, w;
      numColors = 0;
      out = 'hex';

      if (arguments.length === 1) {
        if (type(arguments[0]) === 'string') {
          out = arguments[0];
        } else {
          numColors = arguments[0];
        }
      }

      if (arguments.length === 2) {
        numColors = arguments[0], out = arguments[1];
      }

      if (numColors) {
        return function () {
          results = [];

          for (var o = 0; 0 <= numColors ? o < numColors : o > numColors; 0 <= numColors ? o++ : o--) {
            results.push(o);
          }

          return results;
        }.apply(this).map(function (i) {
          return f(i / (numColors - 1))[out]();
        });
      }

      colors = [];
      samples = [];

      if (_domain.length > 2) {
        for (i = w = 1, ref = _domain.length; 1 <= ref ? w < ref : w > ref; i = 1 <= ref ? ++w : --w) {
          samples.push((_domain[i - 1] + _domain[i]) * 0.5);
        }
      } else {
        samples = _domain;
      }

      for (aa = 0, len = samples.length; aa < len; aa++) {
        i = samples[aa];
        colors.push(f(i)[out]());
      }

      return colors;
    };

    return f;
  };

  if (chroma.scales == null) {
    chroma.scales = {};
  }

  chroma.scales.cool = function () {
    return chroma.scale([chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4)]);
  };

  chroma.scales.hot = function () {
    return chroma.scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');
  };
  /*
      chroma.js

      Copyright (c) 2011-2013, Gregor Aisch
      All rights reserved.

      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:

      * Redistributions of source code must retain the above copyright notice, this
        list of conditions and the following disclaimer.

      * Redistributions in binary form must reproduce the above copyright notice,
        this list of conditions and the following disclaimer in the documentation
        and/or other materials provided with the distribution.

      * The name Gregor Aisch may not be used to endorse or promote products
        derived from this software without specific prior written permission.

      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
      INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
      BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
      DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
      OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
      EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

      @source: https://github.com/gka/chroma.js
   */


  chroma.analyze = function (data, key, filter) {
    var add, k, len, o, r, val, visit;
    r = {
      min: Number.MAX_VALUE,
      max: Number.MAX_VALUE * -1,
      sum: 0,
      values: [],
      count: 0
    };

    if (filter == null) {
      filter = function filter() {
        return true;
      };
    }

    add = function add(val) {
      if (val != null && !isNaN(val)) {
        r.values.push(val);
        r.sum += val;

        if (val < r.min) {
          r.min = val;
        }

        if (val > r.max) {
          r.max = val;
        }

        r.count += 1;
      }
    };

    visit = function visit(val, k) {
      if (filter(val, k)) {
        if (key != null && type(key) === 'function') {
          return add(key(val));
        } else if (key != null && type(key) === 'string' || type(key) === 'number') {
          return add(val[key]);
        } else {
          return add(val);
        }
      }
    };

    if (type(data) === 'array') {
      for (o = 0, len = data.length; o < len; o++) {
        val = data[o];
        visit(val);
      }
    } else {
      for (k in data) {
        val = data[k];
        visit(val, k);
      }
    }

    r.domain = [r.min, r.max];

    r.limits = function (mode, num) {
      return chroma.limits(r, mode, num);
    };

    return r;
  };

  chroma.limits = function (data, mode, num) {
    var aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max_log, min, min_log, mindist, n, nb_iters, newCentroids, o, p, pb, pr, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, repeat, sum, tmpKMeansBreaks, value, values, w;

    if (mode == null) {
      mode = 'equal';
    }

    if (num == null) {
      num = 7;
    }

    if (type(data) === 'array') {
      data = chroma.analyze(data);
    }

    min = data.min;
    max = data.max;
    sum = data.sum;
    values = data.values.sort(function (a, b) {
      return a - b;
    });
    limits = [];

    if (mode.substr(0, 1) === 'c') {
      limits.push(min);
      limits.push(max);
    }

    if (mode.substr(0, 1) === 'e') {
      limits.push(min);

      for (i = o = 1, ref = num - 1; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {
        limits.push(min + i / num * (max - min));
      }

      limits.push(max);
    } else if (mode.substr(0, 1) === 'l') {
      if (min <= 0) {
        throw 'Logarithmic scales are only possible for values > 0';
      }

      min_log = Math.LOG10E * log(min);
      max_log = Math.LOG10E * log(max);
      limits.push(min);

      for (i = w = 1, ref1 = num - 1; 1 <= ref1 ? w <= ref1 : w >= ref1; i = 1 <= ref1 ? ++w : --w) {
        limits.push(pow(10, min_log + i / num * (max_log - min_log)));
      }

      limits.push(max);
    } else if (mode.substr(0, 1) === 'q') {
      limits.push(min);

      for (i = aa = 1, ref2 = num - 1; 1 <= ref2 ? aa <= ref2 : aa >= ref2; i = 1 <= ref2 ? ++aa : --aa) {
        p = values.length * i / num;
        pb = floor(p);

        if (pb === p) {
          limits.push(values[pb]);
        } else {
          pr = p - pb;
          limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));
        }
      }

      limits.push(max);
    } else if (mode.substr(0, 1) === 'k') {
      /*
      implementation based on
      http://code.google.com/p/figue/source/browse/trunk/figue.js#336
      simplified for 1-d input values
       */
      n = values.length;
      assignments = new Array(n);
      clusterSizes = new Array(num);
      repeat = true;
      nb_iters = 0;
      centroids = null;
      centroids = [];
      centroids.push(min);

      for (i = ab = 1, ref3 = num - 1; 1 <= ref3 ? ab <= ref3 : ab >= ref3; i = 1 <= ref3 ? ++ab : --ab) {
        centroids.push(min + i / num * (max - min));
      }

      centroids.push(max);

      while (repeat) {
        for (j = ac = 0, ref4 = num - 1; 0 <= ref4 ? ac <= ref4 : ac >= ref4; j = 0 <= ref4 ? ++ac : --ac) {
          clusterSizes[j] = 0;
        }

        for (i = ad = 0, ref5 = n - 1; 0 <= ref5 ? ad <= ref5 : ad >= ref5; i = 0 <= ref5 ? ++ad : --ad) {
          value = values[i];
          mindist = Number.MAX_VALUE;

          for (j = ae = 0, ref6 = num - 1; 0 <= ref6 ? ae <= ref6 : ae >= ref6; j = 0 <= ref6 ? ++ae : --ae) {
            dist = abs(centroids[j] - value);

            if (dist < mindist) {
              mindist = dist;
              best = j;
            }
          }

          clusterSizes[best]++;
          assignments[i] = best;
        }

        newCentroids = new Array(num);

        for (j = af = 0, ref7 = num - 1; 0 <= ref7 ? af <= ref7 : af >= ref7; j = 0 <= ref7 ? ++af : --af) {
          newCentroids[j] = null;
        }

        for (i = ag = 0, ref8 = n - 1; 0 <= ref8 ? ag <= ref8 : ag >= ref8; i = 0 <= ref8 ? ++ag : --ag) {
          cluster = assignments[i];

          if (newCentroids[cluster] === null) {
            newCentroids[cluster] = values[i];
          } else {
            newCentroids[cluster] += values[i];
          }
        }

        for (j = ah = 0, ref9 = num - 1; 0 <= ref9 ? ah <= ref9 : ah >= ref9; j = 0 <= ref9 ? ++ah : --ah) {
          newCentroids[j] *= 1 / clusterSizes[j];
        }

        repeat = false;

        for (j = ai = 0, ref10 = num - 1; 0 <= ref10 ? ai <= ref10 : ai >= ref10; j = 0 <= ref10 ? ++ai : --ai) {
          if (newCentroids[j] !== centroids[i]) {
            repeat = true;
            break;
          }
        }

        centroids = newCentroids;
        nb_iters++;

        if (nb_iters > 200) {
          repeat = false;
        }
      }

      kClusters = {};

      for (j = aj = 0, ref11 = num - 1; 0 <= ref11 ? aj <= ref11 : aj >= ref11; j = 0 <= ref11 ? ++aj : --aj) {
        kClusters[j] = [];
      }

      for (i = ak = 0, ref12 = n - 1; 0 <= ref12 ? ak <= ref12 : ak >= ref12; i = 0 <= ref12 ? ++ak : --ak) {
        cluster = assignments[i];
        kClusters[cluster].push(values[i]);
      }

      tmpKMeansBreaks = [];

      for (j = al = 0, ref13 = num - 1; 0 <= ref13 ? al <= ref13 : al >= ref13; j = 0 <= ref13 ? ++al : --al) {
        tmpKMeansBreaks.push(kClusters[j][0]);
        tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
      }

      tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) {
        return a - b;
      });
      limits.push(tmpKMeansBreaks[0]);

      for (i = am = 1, ref14 = tmpKMeansBreaks.length - 1; am <= ref14; i = am += 2) {
        if (!isNaN(tmpKMeansBreaks[i])) {
          limits.push(tmpKMeansBreaks[i]);
        }
      }
    }

    return limits;
  };

  hsi2rgb = function hsi2rgb(h, s, i) {
    /*
    borrowed from here:
    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/hsi2rgb.cpp
     */
    var b, g, r, ref;
    ref = unpack(arguments), h = ref[0], s = ref[1], i = ref[2];
    h /= 360;

    if (h < 1 / 3) {
      b = (1 - s) / 3;
      r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      g = 1 - (b + r);
    } else if (h < 2 / 3) {
      h -= 1 / 3;
      r = (1 - s) / 3;
      g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      b = 1 - (r + g);
    } else {
      h -= 2 / 3;
      g = (1 - s) / 3;
      b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
      r = 1 - (g + b);
    }

    r = limit(i * r * 3);
    g = limit(i * g * 3);
    b = limit(i * b * 3);
    return [r * 255, g * 255, b * 255];
  };

  rgb2hsi = function rgb2hsi() {
    /*
    borrowed from here:
    http://hummer.stanford.edu/museinfo/doc/examples/humdrum/keyscape2/rgb2hsi.cpp
     */
    var b, g, h, i, min, r, ref, s;
    ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
    TWOPI = Math.PI * 2;
    r /= 255;
    g /= 255;
    b /= 255;
    min = Math.min(r, g, b);
    i = (r + g + b) / 3;
    s = 1 - min / i;

    if (s === 0) {
      h = 0;
    } else {
      h = (r - g + (r - b)) / 2;
      h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
      h = Math.acos(h);

      if (b > g) {
        h = TWOPI - h;
      }

      h /= TWOPI;
    }

    return [h * 360, s, i];
  };

  chroma.hsi = function () {
    return function (func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor(),
          result = func.apply(child, args);
      return Object(result) === result ? result : child;
    }(Color, slice.call(arguments).concat(['hsi']), function () {});
  };

  _input.hsi = hsi2rgb;

  Color.prototype.hsi = function () {
    return rgb2hsi(this._rgb);
  };

  interpolate_hsx = function interpolate_hsx(col1, col2, f, m) {
    var dh, hue, hue0, hue1, lbv, lbv0, lbv1, res, sat, sat0, sat1, xyz0, xyz1;

    if (m === 'hsl') {
      xyz0 = col1.hsl();
      xyz1 = col2.hsl();
    } else if (m === 'hsv') {
      xyz0 = col1.hsv();
      xyz1 = col2.hsv();
    } else if (m === 'hsi') {
      xyz0 = col1.hsi();
      xyz1 = col2.hsi();
    } else if (m === 'lch') {
      xyz0 = col1.lch();
      xyz1 = col2.lch();
    }

    if (m.substr(0, 1) === 'h') {
      hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
      hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
    } else {
      lbv0 = xyz0[0], sat0 = xyz0[1], hue0 = xyz0[2];
      lbv1 = xyz1[0], sat1 = xyz1[1], hue1 = xyz1[2];
    }

    if (!isNaN(hue0) && !isNaN(hue1)) {
      if (hue1 > hue0 && hue1 - hue0 > 180) {
        dh = hue1 - (hue0 + 360);
      } else if (hue1 < hue0 && hue0 - hue1 > 180) {
        dh = hue1 + 360 - hue0;
      } else {
        dh = hue1 - hue0;
      }

      hue = hue0 + f * dh;
    } else if (!isNaN(hue0)) {
      hue = hue0;

      if ((lbv1 === 1 || lbv1 === 0) && m !== 'hsv') {
        sat = sat0;
      }
    } else if (!isNaN(hue1)) {
      hue = hue1;

      if ((lbv0 === 1 || lbv0 === 0) && m !== 'hsv') {
        sat = sat1;
      }
    } else {
      hue = Number.NaN;
    }

    if (sat == null) {
      sat = sat0 + f * (sat1 - sat0);
    }

    lbv = lbv0 + f * (lbv1 - lbv0);

    if (m.substr(0, 1) === 'h') {
      return res = new Color(hue, sat, lbv, m);
    } else {
      return res = new Color(lbv, sat, hue, m);
    }
  };

  _interpolators = _interpolators.concat(function () {
    var len, o, ref, results;
    ref = ['hsv', 'hsl', 'hsi', 'lch'];
    results = [];

    for (o = 0, len = ref.length; o < len; o++) {
      m = ref[o];
      results.push([m, interpolate_hsx]);
    }

    return results;
  }());

  interpolate_num = function interpolate_num(col1, col2, f, m) {
    var n1, n2;
    n1 = col1.num();
    n2 = col2.num();
    return chroma.num(n1 + (n2 - n1) * f, 'num');
  };

  _interpolators.push(['num', interpolate_num]);

  interpolate_lab = function interpolate_lab(col1, col2, f, m) {
    var res, xyz0, xyz1;
    xyz0 = col1.lab();
    xyz1 = col2.lab();
    return res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
  };

  _interpolators.push(['lab', interpolate_lab]);
}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/d3-array/index.js":
/*!****************************************!*\
  !*** ./node_modules/d3-array/index.js ***!
  \****************************************/
/*! exports provided: bisect, bisectRight, bisectLeft, ascending, bisector, cross, descending, deviation, extent, histogram, thresholdFreedmanDiaconis, thresholdScott, thresholdSturges, max, mean, median, merge, min, pairs, permute, quantile, range, scan, shuffle, sum, ticks, tickIncrement, tickStep, transpose, variance, zip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisect", function() { return _src_bisect__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return _src_bisect__WEBPACK_IMPORTED_MODULE_0__["bisectRight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return _src_bisect__WEBPACK_IMPORTED_MODULE_0__["bisectLeft"]; });

/* harmony import */ var _src_ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ascending", function() { return _src_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_bisector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/bisector */ "./node_modules/d3-array/src/bisector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bisector", function() { return _src_bisector__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_cross__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/cross */ "./node_modules/d3-array/src/cross.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return _src_cross__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_descending__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/descending */ "./node_modules/d3-array/src/descending.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "descending", function() { return _src_descending__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_deviation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/deviation */ "./node_modules/d3-array/src/deviation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deviation", function() { return _src_deviation__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_extent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/extent */ "./node_modules/d3-array/src/extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "extent", function() { return _src_extent__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_histogram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/histogram */ "./node_modules/d3-array/src/histogram.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "histogram", function() { return _src_histogram__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/threshold/freedmanDiaconis */ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdFreedmanDiaconis", function() { return _src_threshold_freedmanDiaconis__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_threshold_scott__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/threshold/scott */ "./node_modules/d3-array/src/threshold/scott.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdScott", function() { return _src_threshold_scott__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_threshold_sturges__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "thresholdSturges", function() { return _src_threshold_sturges__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_max__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/max */ "./node_modules/d3-array/src/max.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "max", function() { return _src_max__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_mean__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/mean */ "./node_modules/d3-array/src/mean.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mean", function() { return _src_mean__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_median__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/median */ "./node_modules/d3-array/src/median.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "median", function() { return _src_median__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_merge__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/merge */ "./node_modules/d3-array/src/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _src_merge__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _src_min__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/min */ "./node_modules/d3-array/src/min.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "min", function() { return _src_min__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _src_pairs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/pairs */ "./node_modules/d3-array/src/pairs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pairs", function() { return _src_pairs__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _src_permute__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/permute */ "./node_modules/d3-array/src/permute.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "permute", function() { return _src_permute__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _src_quantile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/quantile */ "./node_modules/d3-array/src/quantile.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantile", function() { return _src_quantile__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _src_range__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/range */ "./node_modules/d3-array/src/range.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "range", function() { return _src_range__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _src_scan__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/scan */ "./node_modules/d3-array/src/scan.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scan", function() { return _src_scan__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _src_shuffle__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/shuffle */ "./node_modules/d3-array/src/shuffle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return _src_shuffle__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _src_sum__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/sum */ "./node_modules/d3-array/src/sum.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sum", function() { return _src_sum__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _src_ticks__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ticks", function() { return _src_ticks__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return _src_ticks__WEBPACK_IMPORTED_MODULE_23__["tickIncrement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return _src_ticks__WEBPACK_IMPORTED_MODULE_23__["tickStep"]; });

/* harmony import */ var _src_transpose__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/transpose */ "./node_modules/d3-array/src/transpose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return _src_transpose__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _src_variance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/variance */ "./node_modules/d3-array/src/variance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return _src_variance__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _src_zip__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/zip */ "./node_modules/d3-array/src/zip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return _src_zip__WEBPACK_IMPORTED_MODULE_26__["default"]; });





























/***/ }),

/***/ "./node_modules/d3-array/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/array.js ***!
  \********************************************/
/*! exports provided: slice, map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "map", function() { return map; });
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

/***/ }),

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
});

/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/*! exports provided: bisectRight, bisectLeft, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectRight", function() { return bisectRight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bisectLeft", function() { return bisectLeft; });
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisector */ "./node_modules/d3-array/src/bisector.js");


var ascendingBisect = Object(_bisector__WEBPACK_IMPORTED_MODULE_1__["default"])(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
/* harmony default export */ __webpack_exports__["default"] = (bisectRight);

/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");

/* harmony default export */ __webpack_exports__["default"] = (function (compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function left(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }

      return lo;
    },
    right: function right(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }

      return lo;
    }
  };
});

function ascendingComparator(f) {
  return function (d, x) {
    return Object(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"])(f(d), x);
  };
}

/***/ }),

/***/ "./node_modules/d3-array/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/constant.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-array/src/cross.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/cross.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pairs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pairs */ "./node_modules/d3-array/src/pairs.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;
  if (reduce == null) reduce = _pairs__WEBPACK_IMPORTED_MODULE_0__["pair"];

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
});

/***/ }),

/***/ "./node_modules/d3-array/src/descending.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-array/src/descending.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
});

/***/ }),

/***/ "./node_modules/d3-array/src/deviation.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/deviation.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _variance__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance */ "./node_modules/d3-array/src/variance.js");

/* harmony default export */ __webpack_exports__["default"] = (function (array, f) {
  var v = Object(_variance__WEBPACK_IMPORTED_MODULE_0__["default"])(array, f);
  return v ? Math.sqrt(v) : v;
});

/***/ }),

/***/ "./node_modules/d3-array/src/extent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/extent.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
});

/***/ }),

/***/ "./node_modules/d3-array/src/histogram.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/histogram.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bisect */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-array/src/constant.js");
/* harmony import */ var _extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./extent */ "./node_modules/d3-array/src/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./identity */ "./node_modules/d3-array/src/identity.js");
/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _ticks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ticks */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./threshold/sturges */ "./node_modules/d3-array/src/threshold/sturges.js");








/* harmony default export */ __webpack_exports__["default"] = (function () {
  var value = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      domain = _extent__WEBPACK_IMPORTED_MODULE_3__["default"],
      threshold = _threshold_sturges__WEBPACK_IMPORTED_MODULE_7__["default"];

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      tz = Object(_ticks__WEBPACK_IMPORTED_MODULE_6__["tickStep"])(x0, x1, tz);
      tz = Object(_range__WEBPACK_IMPORTED_MODULE_5__["default"])(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) {
      tz.shift(), --m;
    }

    while (tz[m - 1] > x1) {
      tz.pop(), --m;
    }

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x0 <= x && x <= x1) {
        bins[Object(_bisect__WEBPACK_IMPORTED_MODULE_1__["default"])(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_array__WEBPACK_IMPORTED_MODULE_0__["slice"].call(_)) : Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(_), histogram) : threshold;
  };

  return histogram;
});

/***/ }),

/***/ "./node_modules/d3-array/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/identity.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x;
});

/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
});

/***/ }),

/***/ "./node_modules/d3-array/src/mean.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/mean.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) sum += value;else --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) sum += value;else --m;
    }
  }

  if (m) return sum / m;
});

/***/ }),

/***/ "./node_modules/d3-array/src/median.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/median.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./quantile */ "./node_modules/d3-array/src/quantile.js");



/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(values[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_1__["default"])(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return Object(_quantile__WEBPACK_IMPORTED_MODULE_2__["default"])(numbers.sort(_ascending__WEBPACK_IMPORTED_MODULE_0__["default"]), 0.5);
});

/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) {
    j += arrays[i].length;
  }

  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;

    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
});

/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
});

/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x === null ? NaN : +x;
});

/***/ }),

/***/ "./node_modules/d3-array/src/pairs.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/pairs.js ***!
  \********************************************/
/*! exports provided: default, pair */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pair", function() { return pair; });
/* harmony default export */ __webpack_exports__["default"] = (function (array, f) {
  if (f == null) f = pair;
  var i = 0,
      n = array.length - 1,
      p = array[0],
      pairs = new Array(n < 0 ? 0 : n);

  while (i < n) {
    pairs[i] = f(p, p = array[++i]);
  }

  return pairs;
});
function pair(a, b) {
  return [a, b];
}

/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array, indexes) {
  var i = indexes.length,
      permutes = new Array(i);

  while (i--) {
    permutes[i] = array[indexes[i]];
  }

  return permutes;
});

/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, p, valueof) {
  if (valueof == null) valueof = _number__WEBPACK_IMPORTED_MODULE_0__["default"];
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
});

/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
});

/***/ }),

/***/ "./node_modules/d3-array/src/scan.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/scan.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending */ "./node_modules/d3-array/src/ascending.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];
  if (compare == null) compare = _ascending__WEBPACK_IMPORTED_MODULE_0__["default"];

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
});

/***/ }),

/***/ "./node_modules/d3-array/src/shuffle.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/shuffle.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
});

/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
});

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/freedmanDiaconis.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/freedmanDiaconis.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array */ "./node_modules/d3-array/src/array.js");
/* harmony import */ var _ascending__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ascending */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../number */ "./node_modules/d3-array/src/number.js");
/* harmony import */ var _quantile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../quantile */ "./node_modules/d3-array/src/quantile.js");




/* harmony default export */ __webpack_exports__["default"] = (function (values, min, max) {
  values = _array__WEBPACK_IMPORTED_MODULE_0__["map"].call(values, _number__WEBPACK_IMPORTED_MODULE_2__["default"]).sort(_ascending__WEBPACK_IMPORTED_MODULE_1__["default"]);
  return Math.ceil((max - min) / (2 * (Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.75) - Object(_quantile__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 0.25)) * Math.pow(values.length, -1 / 3)));
});

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/scott.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/scott.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _deviation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../deviation */ "./node_modules/d3-array/src/deviation.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, min, max) {
  return Math.ceil((max - min) / (3.5 * Object(_deviation__WEBPACK_IMPORTED_MODULE_0__["default"])(values) * Math.pow(values.length, -1 / 3)));
});

/***/ }),

/***/ "./node_modules/d3-array/src/threshold/sturges.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-array/src/threshold/sturges.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
});

/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/*! exports provided: default, tickIncrement, tickStep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickIncrement", function() { return tickIncrement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tickStep", function() { return tickStep; });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);
/* harmony default export */ __webpack_exports__["default"] = (function (start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));

    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }

  if (reverse) ticks.reverse();
  return ticks;
});
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

/***/ }),

/***/ "./node_modules/d3-array/src/transpose.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/transpose.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./min */ "./node_modules/d3-array/src/min.js");

/* harmony default export */ __webpack_exports__["default"] = (function (matrix) {
  if (!(n = matrix.length)) return [];

  for (var i = -1, m = Object(_min__WEBPACK_IMPORTED_MODULE_0__["default"])(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }

  return transpose;
});

function length(d) {
  return d.length;
}

/***/ }),

/***/ "./node_modules/d3-array/src/variance.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/variance.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-array/src/number.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
});

/***/ }),

/***/ "./node_modules/d3-array/src/zip.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/zip.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpose */ "./node_modules/d3-array/src/transpose.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_transpose__WEBPACK_IMPORTED_MODULE_0__["default"])(arguments);
});

/***/ }),

/***/ "./node_modules/d3-collection/index.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-collection/index.js ***!
  \*********************************************/
/*! exports provided: nest, set, map, keys, values, entries */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_nest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/nest */ "./node_modules/d3-collection/src/nest.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return _src_nest__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/set */ "./node_modules/d3-collection/src/set.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return _src_set__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/map */ "./node_modules/d3-collection/src/map.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return _src_map__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_keys__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/keys */ "./node_modules/d3-collection/src/keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return _src_keys__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_values__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/values */ "./node_modules/d3-collection/src/values.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return _src_values__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_entries__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/entries */ "./node_modules/d3-collection/src/entries.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return _src_entries__WEBPACK_IMPORTED_MODULE_5__["default"]; });








/***/ }),

/***/ "./node_modules/d3-collection/src/entries.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-collection/src/entries.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (map) {
  var entries = [];

  for (var key in map) {
    entries.push({
      key: key,
      value: map[key]
    });
  }

  return entries;
});

/***/ }),

/***/ "./node_modules/d3-collection/src/keys.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/keys.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (map) {
  var keys = [];

  for (var key in map) {
    keys.push(key);
  }

  return keys;
});

/***/ }),

/***/ "./node_modules/d3-collection/src/map.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/map.js ***!
  \***********************************************/
/*! exports provided: prefix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prefix", function() { return prefix; });
var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function has(key) {
    return prefix + key in this;
  },
  get: function get(key) {
    return this[prefix + key];
  },
  set: function set(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function remove(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function clear() {
    for (var property in this) {
      if (property[0] === prefix) delete this[property];
    }
  },
  keys: function keys() {
    var keys = [];

    for (var property in this) {
      if (property[0] === prefix) keys.push(property.slice(1));
    }

    return keys;
  },
  values: function values() {
    var values = [];

    for (var property in this) {
      if (property[0] === prefix) values.push(this[property]);
    }

    return values;
  },
  entries: function entries() {
    var entries = [];

    for (var property in this) {
      if (property[0] === prefix) entries.push({
        key: property.slice(1),
        value: this[property]
      });
    }

    return entries;
  },
  size: function size() {
    var size = 0;

    for (var property in this) {
      if (property[0] === prefix) ++size;
    }

    return size;
  },
  empty: function empty() {
    for (var property in this) {
      if (property[0] === prefix) return false;
    }

    return true;
  },
  each: function each(f) {
    for (var property in this) {
      if (property[0] === prefix) f(this[property], property.slice(1), this);
    }
  }
};

function map(object, f) {
  var map = new Map(); // Copy constructor.

  if (object instanceof Map) object.each(function (value, key) {
    map.set(key, value);
  }); // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;
      if (f == null) while (++i < n) {
        map.set(i, object[i]);
      } else while (++i < n) {
        map.set(f(o = object[i], i, object), o);
      }
    } // Convert object to map.
    else if (object) for (var key in object) {
        map.set(key, object[key]);
      }
  return map;
}

/* harmony default export */ __webpack_exports__["default"] = (map);

/***/ }),

/***/ "./node_modules/d3-collection/src/nest.js":
/*!************************************************!*\
  !*** ./node_modules/d3-collection/src/nest.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var keys = [],
      _sortKeys = [],
      _sortValues,
      _rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) return _rollup != null ? _rollup(array) : _sortValues != null ? array.sort(_sortValues) : array;
    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function (values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });
    return result;
  }

  function _entries(map, depth) {
    if (++depth > keys.length) return map;
    var array,
        sortKey = _sortKeys[depth - 1];
    if (_rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
      array.push({
        key: k,
        values: _entries(v, depth)
      });
    });
    return sortKey != null ? array.sort(function (a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }

  return nest = {
    object: function object(array) {
      return apply(array, 0, createObject, setObject);
    },
    map: function map(array) {
      return apply(array, 0, createMap, setMap);
    },
    entries: function entries(array) {
      return _entries(apply(array, 0, createMap, setMap), 0);
    },
    key: function key(d) {
      keys.push(d);
      return nest;
    },
    sortKeys: function sortKeys(order) {
      _sortKeys[keys.length - 1] = order;
      return nest;
    },
    sortValues: function sortValues(order) {
      _sortValues = order;
      return nest;
    },
    rollup: function rollup(f) {
      _rollup = f;
      return nest;
    }
  };
});

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return Object(_map__WEBPACK_IMPORTED_MODULE_0__["default"])();
}

function setMap(map, key, value) {
  map.set(key, value);
}

/***/ }),

/***/ "./node_modules/d3-collection/src/set.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-collection/src/set.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ "./node_modules/d3-collection/src/map.js");


function Set() {}

var proto = _map__WEBPACK_IMPORTED_MODULE_0__["default"].prototype;
Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function add(value) {
    value += "";
    this[_map__WEBPACK_IMPORTED_MODULE_0__["prefix"] + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set(); // Copy constructor.

  if (object instanceof Set) object.each(function (value) {
    set.add(value);
  }); // Otherwise, assume it’s an array.
  else if (object) {
      var i = -1,
          n = object.length;
      if (f == null) while (++i < n) {
        set.add(object[i]);
      } else while (++i < n) {
        set.add(f(object[i], i, object));
      }
    }
  return set;
}

/* harmony default export */ __webpack_exports__["default"] = (set);

/***/ }),

/***/ "./node_modules/d3-collection/src/values.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-collection/src/values.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (map) {
  var values = [];

  for (var key in map) {
    values.push(map[key]);
  }

  return values;
});

/***/ }),

/***/ "./node_modules/d3-color/index.js":
/*!****************************************!*\
  !*** ./node_modules/d3-color/index.js ***!
  \****************************************/
/*! exports provided: color, rgb, hsl, lab, hcl, cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/color */ "./node_modules/d3-color/src/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "color", function() { return _src_color__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return _src_color__WEBPACK_IMPORTED_MODULE_0__["rgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return _src_color__WEBPACK_IMPORTED_MODULE_0__["hsl"]; });

/* harmony import */ var _src_lab__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/lab */ "./node_modules/d3-color/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lab", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_1__["hcl"]; });

/* harmony import */ var _src_cubehelix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/cubehelix */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cubehelix", function() { return _src_cubehelix__WEBPACK_IMPORTED_MODULE_2__["default"]; });





/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/*! exports provided: Color, darker, brighter, default, rgbConvert, rgb, Rgb, hslConvert, hsl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darker", function() { return _darker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "brighter", function() { return _brighter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return color; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbConvert", function() { return rgbConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Rgb", function() { return Rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslConvert", function() { return hslConvert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./node_modules/d3-color/src/define.js");

function Color() {}
var _darker = 0.7;


var _brighter = 1 / _darker;


var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Color, color, {
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  toString: function toString() {
    return this.rgb() + "";
  }
});
function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  ) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
  : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Rgb, rgb, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  displayable: function displayable() {
    return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
  },
  toString: function toString() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;

  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }

  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Hsl, hsl, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  }
}));
/* From FvD 13.37, CSS Color Module Level 3 */

function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/*! exports provided: default, Cubehelix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return cubehelix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubehelix", function() { return Cubehelix; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-color/src/math.js");



var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
      // NaN if l=0 or l=1
  h = s ? Math.atan2(k, bl) * _math__WEBPACK_IMPORTED_MODULE_2__["rad2deg"] - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Cubehelix, cubehelix, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function brighter(k) {
    k = k == null ? _color__WEBPACK_IMPORTED_MODULE_1__["brighter"] : Math.pow(_color__WEBPACK_IMPORTED_MODULE_1__["brighter"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _color__WEBPACK_IMPORTED_MODULE_1__["darker"] : Math.pow(_color__WEBPACK_IMPORTED_MODULE_1__["darker"], k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math__WEBPACK_IMPORTED_MODULE_2__["deg2rad"],
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"](255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));

/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/*! exports provided: default, extend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony default export */ __webpack_exports__["default"] = (function (constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
});
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);

  for (var key in definition) {
    prototype[key] = definition[key];
  }

  return prototype;
}

/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/*! exports provided: default, Lab, hcl, Hcl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Lab", function() { return Lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hcl", function() { return hcl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Hcl", function() { return Hcl; });
/* harmony import */ var _define__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-color/src/math.js");



var Kn = 18,
    Xn = 0.950470,
    // D65 standard referent
Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);

  if (o instanceof Hcl) {
    var h = o.h * _math__WEBPACK_IMPORTED_MODULE_2__["deg2rad"];
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }

  if (!(o instanceof _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"])) o = Object(_color__WEBPACK_IMPORTED_MODULE_1__["rgbConvert"])(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Lab, lab, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function brighter(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function darker(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new _color__WEBPACK_IMPORTED_MODULE_1__["Rgb"](xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
    xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * _math__WEBPACK_IMPORTED_MODULE_2__["rad2deg"];
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
Object(_define__WEBPACK_IMPORTED_MODULE_0__["default"])(Hcl, hcl, Object(_define__WEBPACK_IMPORTED_MODULE_0__["extend"])(_color__WEBPACK_IMPORTED_MODULE_1__["Color"], {
  brighter: function brighter(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function darker(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function rgb() {
    return labConvert(this).rgb();
  }
}));

/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/*! exports provided: deg2rad, rad2deg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rad2deg", function() { return rad2deg; });
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

/***/ }),

/***/ "./node_modules/d3-dispatch/index.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-dispatch/index.js ***!
  \*******************************************/
/*! exports provided: dispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return _src_dispatch__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var noop = {
  value: function value() {}
};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
    _[t] = [];
  }

  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function on(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length; // If no callback was specified, return the callback of the given type and name.

    if (arguments.length < 2) {
      while (++i < n) {
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      }

      return;
    } // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.


    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) {
        _[t] = set(_[t], typename.name, null);
      }
    }

    return this;
  },
  copy: function copy() {
    var copy = {},
        _ = this._;

    for (var t in _) {
      copy[t] = _[t].slice();
    }

    return new Dispatch(copy);
  },
  call: function call(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) {
      args[i] = arguments[i + 2];
    }
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  },
  apply: function apply(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) {
      t[i].value.apply(that, args);
    }
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }

  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}

/* harmony default export */ __webpack_exports__["default"] = (dispatch);

/***/ }),

/***/ "./node_modules/d3-drag/index.js":
/*!***************************************!*\
  !*** ./node_modules/d3-drag/index.js ***!
  \***************************************/
/*! exports provided: drag, dragDisable, dragEnable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_drag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/drag */ "./node_modules/d3-drag/src/drag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return _src_drag__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_nodrag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/nodrag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return _src_nodrag__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return _src_nodrag__WEBPACK_IMPORTED_MODULE_1__["yesdrag"]; });




/***/ }),

/***/ "./node_modules/d3-drag/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-drag/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-drag/src/drag.js":
/*!******************************************!*\
  !*** ./node_modules/d3-drag/src/drag.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _nodrag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nodrag */ "./node_modules/d3-drag/src/nodrag.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-drag/src/noevent.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-drag/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./event */ "./node_modules/d3-drag/src/event.js");





 // Ignore right-click, since that should open the context menu.

function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {
    x: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].x,
    y: d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].y
  } : d;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      gestures = {},
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "drag", "end"),
      active = 0,
      mousemoving,
      touchending;

  function drag(selection) {
    selection.on("mousedown.drag", mousedowned).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3_selection__WEBPACK_IMPORTED_MODULE_1__["mouse"], this, arguments);
    if (!gesture) return;
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    Object(_nodrag__WEBPACK_IMPORTED_MODULE_2__["default"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
    mousemoving = false;
    gesture("start");
  }

  function mousemoved() {
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    mousemoving = true;
    gestures.mouse("drag");
  }

  function mouseupped() {
    Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view).on("mousemove.drag mouseup.drag", null);
    Object(_nodrag__WEBPACK_IMPORTED_MODULE_2__["yesdrag"])(d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].view, mousemoving);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        c = container.apply(this, arguments),
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3_selection__WEBPACK_IMPORTED_MODULE_1__["touch"], this, arguments)) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["default"])();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].changedTouches,
        n = touches.length,
        i,
        gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, 500); // Ghost clicks are delayed!

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        Object(_noevent__WEBPACK_IMPORTED_MODULE_3__["nopropagation"])();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id),
        s,
        dx,
        dy,
        sublisteners = listeners.copy();
    if (!Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
      if ((d3_selection__WEBPACK_IMPORTED_MODULE_1__["event"].subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;
    return function gesture(type) {
      var p0 = p,
          n;

      switch (type) {
        case "start":
          gestures[id] = gesture, n = active++;
          break;

        case "end":
          delete gestures[id], --active;
        // nobreak

        case "drag":
          p = point(container, id), n = active;
          break;
      }

      Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_5__["default"](drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(!!_), drag) : filter;
  };

  drag.container = function (_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : container;
  };

  drag.subject = function (_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_4__["default"])(_), drag) : subject;
  };

  drag.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  return drag;
});

/***/ }),

/***/ "./node_modules/d3-drag/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-drag/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DragEvent; });
function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function () {
  var value = this._.on.apply(this._, arguments);

  return value === this._ ? this : value;
};

/***/ }),

/***/ "./node_modules/d3-drag/src/nodrag.js":
/*!********************************************!*\
  !*** ./node_modules/d3-drag/src/nodrag.js ***!
  \********************************************/
/*! exports provided: default, yesdrag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "yesdrag", function() { return yesdrag; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-drag/src/noevent.js");


/* harmony default export */ __webpack_exports__["default"] = (function (view) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
});
function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["select"])(view).on("dragstart.drag", null);

  if (noclick) {
    selection.on("click.drag", _noevent__WEBPACK_IMPORTED_MODULE_1__["default"], true);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

/***/ }),

/***/ "./node_modules/d3-drag/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-drag/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");

function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});

/***/ }),

/***/ "./node_modules/d3-dsv/index.js":
/*!**************************************!*\
  !*** ./node_modules/d3-dsv/index.js ***!
  \**************************************/
/*! exports provided: dsvFormat, csvParse, csvParseRows, csvFormat, csvFormatRows, tsvParse, tsvParseRows, tsvFormat, tsvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dsvFormat", function() { return _src_dsv__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_csv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/csv */ "./node_modules/d3-dsv/src/csv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_1__["csvFormatRows"]; });

/* harmony import */ var _src_tsv__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/tsv */ "./node_modules/d3-dsv/src/tsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvParse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvParseRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_2__["tsvFormatRows"]; });





/***/ }),

/***/ "./node_modules/d3-dsv/src/csv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/csv.js ***!
  \****************************************/
/*! exports provided: csvParse, csvParseRows, csvFormat, csvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParse", function() { return csvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvParseRows", function() { return csvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormat", function() { return csvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "csvFormatRows", function() { return csvFormatRows; });
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-dsv/src/dsv.js");

var csv = Object(_dsv__WEBPACK_IMPORTED_MODULE_0__["default"])(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function (name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function (row, i) {
    return f(object(row), i, columns);
  };
} // Compute unique columns in order of discovery.


function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];
  rows.forEach(function (row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}

/* harmony default export */ __webpack_exports__["default"] = (function (delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert,
        columns,
        rows = parseRows(text, function (row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [],
        // output rows
    N = text.length,
        I = 0,
        // current character index
    n = 0,
        // current line number
    t,
        // current token
    eof = N <= 0,
        // current token followed by EOF?
    eol = false; // current token followed by EOL?
    // Strip the trailing newline.

    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL; // Unescape quotes.

      var i,
          j = I,
          c;

      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) {
          ;
        }

        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      } // Find next delimiter or newline.


      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      } // Return last token before EOF.


      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];

      while (t !== EOL && t !== EOF) {
        row.push(t), t = token();
      }

      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
      return columns.map(function (column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? "" : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\"" : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
});

/***/ }),

/***/ "./node_modules/d3-dsv/src/tsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/tsv.js ***!
  \****************************************/
/*! exports provided: tsvParse, tsvParseRows, tsvFormat, tsvFormatRows */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParse", function() { return tsvParse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvParseRows", function() { return tsvParseRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormat", function() { return tsvFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tsvFormatRows", function() { return tsvFormatRows; });
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-dsv/src/dsv.js");

var tsv = Object(_dsv__WEBPACK_IMPORTED_MODULE_0__["default"])("\t");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

/***/ }),

/***/ "./node_modules/d3-ease/index.js":
/*!***************************************!*\
  !*** ./node_modules/d3-ease/index.js ***!
  \***************************************/
/*! exports provided: easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_linear__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/linear */ "./node_modules/d3-ease/src/linear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return _src_linear__WEBPACK_IMPORTED_MODULE_0__["linear"]; });

/* harmony import */ var _src_quad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/quad */ "./node_modules/d3-ease/src/quad.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return _src_quad__WEBPACK_IMPORTED_MODULE_1__["quadInOut"]; });

/* harmony import */ var _src_cubic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/cubic */ "./node_modules/d3-ease/src/cubic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return _src_cubic__WEBPACK_IMPORTED_MODULE_2__["cubicInOut"]; });

/* harmony import */ var _src_poly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/poly */ "./node_modules/d3-ease/src/poly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return _src_poly__WEBPACK_IMPORTED_MODULE_3__["polyInOut"]; });

/* harmony import */ var _src_sin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/sin */ "./node_modules/d3-ease/src/sin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return _src_sin__WEBPACK_IMPORTED_MODULE_4__["sinInOut"]; });

/* harmony import */ var _src_exp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/exp */ "./node_modules/d3-ease/src/exp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return _src_exp__WEBPACK_IMPORTED_MODULE_5__["expInOut"]; });

/* harmony import */ var _src_circle__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/circle */ "./node_modules/d3-ease/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_6__["circleInOut"]; });

/* harmony import */ var _src_bounce__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/bounce */ "./node_modules/d3-ease/src/bounce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return _src_bounce__WEBPACK_IMPORTED_MODULE_7__["bounceInOut"]; });

/* harmony import */ var _src_back__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/back */ "./node_modules/d3-ease/src/back.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return _src_back__WEBPACK_IMPORTED_MODULE_8__["backInOut"]; });

/* harmony import */ var _src_elastic__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/elastic */ "./node_modules/d3-ease/src/elastic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return _src_elastic__WEBPACK_IMPORTED_MODULE_9__["elasticInOut"]; });












/***/ }),

/***/ "./node_modules/d3-ease/src/back.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/back.js ***!
  \******************************************/
/*! exports provided: backIn, backOut, backInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backIn", function() { return backIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backOut", function() { return backOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "backInOut", function() { return backInOut; });
var overshoot = 1.70158;
var backIn = function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;
  return backIn;
}(overshoot);
var backOut = function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;
  return backOut;
}(overshoot);
var backInOut = function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);

/***/ }),

/***/ "./node_modules/d3-ease/src/bounce.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/bounce.js ***!
  \********************************************/
/*! exports provided: bounceIn, bounceOut, bounceInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceIn", function() { return bounceIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceOut", function() { return bounceOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bounceInOut", function() { return bounceInOut; });
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/circle.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/circle.js ***!
  \********************************************/
/*! exports provided: circleIn, circleOut, circleInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleIn", function() { return circleIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleOut", function() { return circleOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleInOut", function() { return circleInOut; });
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/cubic.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-ease/src/cubic.js ***!
  \*******************************************/
/*! exports provided: cubicIn, cubicOut, cubicInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicIn", function() { return cubicIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicOut", function() { return cubicOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubicInOut", function() { return cubicInOut; });
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/elastic.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-ease/src/elastic.js ***!
  \*********************************************/
/*! exports provided: elasticIn, elasticOut, elasticInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticIn", function() { return elasticIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticOut", function() { return elasticOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "elasticInOut", function() { return elasticInOut; });
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;
var elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticIn.period = function (p) {
    return custom(a, p);
  };

  return elasticIn;
}(amplitude, period);
var elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticOut.period = function (p) {
    return custom(a, p);
  };

  return elasticOut;
}(amplitude, period);
var elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticInOut.period = function (p) {
    return custom(a, p);
  };

  return elasticInOut;
}(amplitude, period);

/***/ }),

/***/ "./node_modules/d3-ease/src/exp.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/exp.js ***!
  \*****************************************/
/*! exports provided: expIn, expOut, expInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expIn", function() { return expIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expOut", function() { return expOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "expInOut", function() { return expInOut; });
function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}
function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/linear.js":
/*!********************************************!*\
  !*** ./node_modules/d3-ease/src/linear.js ***!
  \********************************************/
/*! exports provided: linear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
function linear(t) {
  return +t;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/poly.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/poly.js ***!
  \******************************************/
/*! exports provided: polyIn, polyOut, polyInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyIn", function() { return polyIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyOut", function() { return polyOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyInOut", function() { return polyInOut; });
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;
  return polyIn;
}(exponent);
var polyOut = function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;
  return polyOut;
}(exponent);
var polyInOut = function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;
  return polyInOut;
}(exponent);

/***/ }),

/***/ "./node_modules/d3-ease/src/quad.js":
/*!******************************************!*\
  !*** ./node_modules/d3-ease/src/quad.js ***!
  \******************************************/
/*! exports provided: quadIn, quadOut, quadInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadIn", function() { return quadIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadOut", function() { return quadOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quadInOut", function() { return quadInOut; });
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

/***/ }),

/***/ "./node_modules/d3-ease/src/sin.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-ease/src/sin.js ***!
  \*****************************************/
/*! exports provided: sinIn, sinOut, sinInOut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinIn", function() { return sinIn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinOut", function() { return sinOut; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinInOut", function() { return sinInOut; });
var pi = Math.PI,
    halfPi = pi / 2;
function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/index.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo-projection/index.js ***!
  \*************************************************/
/*! exports provided: geoAiry, geoAiryRaw, geoAitoff, geoAitoffRaw, geoArmadillo, geoArmadilloRaw, geoAugust, geoAugustRaw, geoBaker, geoBakerRaw, geoBerghaus, geoBerghausRaw, geoBoggs, geoBoggsRaw, geoBonne, geoBonneRaw, geoBottomley, geoBottomleyRaw, geoBromley, geoBromleyRaw, geoChamberlin, geoChamberlinRaw, geoChamberlinAfrica, geoCollignon, geoCollignonRaw, geoCraig, geoCraigRaw, geoCraster, geoCrasterRaw, geoCylindricalEqualArea, geoCylindricalEqualAreaRaw, geoCylindricalStereographic, geoCylindricalStereographicRaw, geoEckert1, geoEckert1Raw, geoEckert2, geoEckert2Raw, geoEckert3, geoEckert3Raw, geoEckert4, geoEckert4Raw, geoEckert5, geoEckert5Raw, geoEckert6, geoEckert6Raw, geoEisenlohr, geoEisenlohrRaw, geoFahey, geoFaheyRaw, geoFoucaut, geoFoucautRaw, geoGilbert, geoGingery, geoGingeryRaw, geoGinzburg4, geoGinzburg4Raw, geoGinzburg5, geoGinzburg5Raw, geoGinzburg6, geoGinzburg6Raw, geoGinzburg8, geoGinzburg8Raw, geoGinzburg9, geoGinzburg9Raw, geoGringorten, geoGringortenRaw, geoGuyou, geoGuyouRaw, geoHammer, geoHammerRaw, geoHammerRetroazimuthal, geoHammerRetroazimuthalRaw, geoHealpix, geoHealpixRaw, geoHill, geoHillRaw, geoHomolosine, geoHomolosineRaw, geoInterrupt, geoInterruptedBoggs, geoInterruptedHomolosine, geoInterruptedMollweide, geoInterruptedMollweideHemispheres, geoInterruptedSinuMollweide, geoInterruptedSinusoidal, geoKavrayskiy7, geoKavrayskiy7Raw, geoLagrange, geoLagrangeRaw, geoLarrivee, geoLarriveeRaw, geoLaskowski, geoLaskowskiRaw, geoLittrow, geoLittrowRaw, geoLoximuthal, geoLoximuthalRaw, geoMiller, geoMillerRaw, geoModifiedStereographic, geoModifiedStereographicRaw, geoModifiedStereographicAlaska, geoModifiedStereographicGs48, geoModifiedStereographicGs50, geoModifiedStereographicMiller, geoModifiedStereographicLee, geoMollweide, geoMollweideRaw, geoMtFlatPolarParabolic, geoMtFlatPolarParabolicRaw, geoMtFlatPolarQuartic, geoMtFlatPolarQuarticRaw, geoMtFlatPolarSinusoidal, geoMtFlatPolarSinusoidalRaw, geoNaturalEarth, geoNaturalEarthRaw, geoNellHammer, geoNellHammerRaw, geoPatterson, geoPattersonRaw, geoPolyconic, geoPolyconicRaw, geoPolyhedral, geoPolyhedralButterfly, geoPolyhedralCollignon, geoPolyhedralWaterman, geoProject, geoGringortenQuincuncial, geoPeirceQuincuncial, geoPierceQuincuncial, geoQuantize, geoQuincuncial, geoRectangularPolyconic, geoRectangularPolyconicRaw, geoRobinson, geoRobinsonRaw, geoSatellite, geoSatelliteRaw, geoSinuMollweide, geoSinuMollweideRaw, geoSinusoidal, geoSinusoidalRaw, geoStitch, geoTimes, geoTimesRaw, geoTwoPointAzimuthal, geoTwoPointAzimuthalRaw, geoTwoPointAzimuthalUsa, geoTwoPointEquidistant, geoTwoPointEquidistantRaw, geoTwoPointEquidistantUsa, geoVanDerGrinten, geoVanDerGrintenRaw, geoVanDerGrinten2, geoVanDerGrinten2Raw, geoVanDerGrinten3, geoVanDerGrinten3Raw, geoVanDerGrinten4, geoVanDerGrinten4Raw, geoWagner4, geoWagner4Raw, geoWagner6, geoWagner6Raw, geoWagner7, geoWagner7Raw, geoWiechel, geoWiechelRaw, geoWinkel3, geoWinkel3Raw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_airy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/airy */ "./node_modules/d3-geo-projection/src/airy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiry", function() { return _src_airy__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiryRaw", function() { return _src_airy__WEBPACK_IMPORTED_MODULE_0__["airyRaw"]; });

/* harmony import */ var _src_aitoff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/aitoff */ "./node_modules/d3-geo-projection/src/aitoff.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoff", function() { return _src_aitoff__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoffRaw", function() { return _src_aitoff__WEBPACK_IMPORTED_MODULE_1__["aitoffRaw"]; });

/* harmony import */ var _src_armadillo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/armadillo */ "./node_modules/d3-geo-projection/src/armadillo.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadillo", function() { return _src_armadillo__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadilloRaw", function() { return _src_armadillo__WEBPACK_IMPORTED_MODULE_2__["armadilloRaw"]; });

/* harmony import */ var _src_august__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/august */ "./node_modules/d3-geo-projection/src/august.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugust", function() { return _src_august__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugustRaw", function() { return _src_august__WEBPACK_IMPORTED_MODULE_3__["augustRaw"]; });

/* harmony import */ var _src_baker__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/baker */ "./node_modules/d3-geo-projection/src/baker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBaker", function() { return _src_baker__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBakerRaw", function() { return _src_baker__WEBPACK_IMPORTED_MODULE_4__["bakerRaw"]; });

/* harmony import */ var _src_berghaus__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/berghaus */ "./node_modules/d3-geo-projection/src/berghaus.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghaus", function() { return _src_berghaus__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghausRaw", function() { return _src_berghaus__WEBPACK_IMPORTED_MODULE_5__["berghausRaw"]; });

/* harmony import */ var _src_boggs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/boggs */ "./node_modules/d3-geo-projection/src/boggs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggs", function() { return _src_boggs__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggsRaw", function() { return _src_boggs__WEBPACK_IMPORTED_MODULE_6__["boggsRaw"]; });

/* harmony import */ var _src_bonne__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/bonne */ "./node_modules/d3-geo-projection/src/bonne.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonne", function() { return _src_bonne__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonneRaw", function() { return _src_bonne__WEBPACK_IMPORTED_MODULE_7__["bonneRaw"]; });

/* harmony import */ var _src_bottomley__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/bottomley */ "./node_modules/d3-geo-projection/src/bottomley.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomley", function() { return _src_bottomley__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomleyRaw", function() { return _src_bottomley__WEBPACK_IMPORTED_MODULE_8__["bottomleyRaw"]; });

/* harmony import */ var _src_bromley__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/bromley */ "./node_modules/d3-geo-projection/src/bromley.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromley", function() { return _src_bromley__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromleyRaw", function() { return _src_bromley__WEBPACK_IMPORTED_MODULE_9__["bromleyRaw"]; });

/* harmony import */ var _src_chamberlin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/chamberlin */ "./node_modules/d3-geo-projection/src/chamberlin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlin", function() { return _src_chamberlin__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinRaw", function() { return _src_chamberlin__WEBPACK_IMPORTED_MODULE_10__["chamberlinRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinAfrica", function() { return _src_chamberlin__WEBPACK_IMPORTED_MODULE_10__["chamberlinAfrica"]; });

/* harmony import */ var _src_collignon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/collignon */ "./node_modules/d3-geo-projection/src/collignon.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignon", function() { return _src_collignon__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignonRaw", function() { return _src_collignon__WEBPACK_IMPORTED_MODULE_11__["collignonRaw"]; });

/* harmony import */ var _src_craig__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/craig */ "./node_modules/d3-geo-projection/src/craig.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraig", function() { return _src_craig__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraigRaw", function() { return _src_craig__WEBPACK_IMPORTED_MODULE_12__["craigRaw"]; });

/* harmony import */ var _src_craster__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/craster */ "./node_modules/d3-geo-projection/src/craster.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraster", function() { return _src_craster__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCrasterRaw", function() { return _src_craster__WEBPACK_IMPORTED_MODULE_13__["crasterRaw"]; });

/* harmony import */ var _src_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/cylindricalEqualArea */ "./node_modules/d3-geo-projection/src/cylindricalEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualArea", function() { return _src_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualAreaRaw", function() { return _src_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_14__["cylindricalEqualAreaRaw"]; });

/* harmony import */ var _src_cylindricalStereographic__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/cylindricalStereographic */ "./node_modules/d3-geo-projection/src/cylindricalStereographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographic", function() { return _src_cylindricalStereographic__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographicRaw", function() { return _src_cylindricalStereographic__WEBPACK_IMPORTED_MODULE_15__["cylindricalStereographicRaw"]; });

/* harmony import */ var _src_eckert1_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/eckert1.js */ "./node_modules/d3-geo-projection/src/eckert1.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1", function() { return _src_eckert1_js__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1Raw", function() { return _src_eckert1_js__WEBPACK_IMPORTED_MODULE_16__["eckert1Raw"]; });

/* harmony import */ var _src_eckert2_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/eckert2.js */ "./node_modules/d3-geo-projection/src/eckert2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2", function() { return _src_eckert2_js__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2Raw", function() { return _src_eckert2_js__WEBPACK_IMPORTED_MODULE_17__["eckert2Raw"]; });

/* harmony import */ var _src_eckert3_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/eckert3.js */ "./node_modules/d3-geo-projection/src/eckert3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3", function() { return _src_eckert3_js__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3Raw", function() { return _src_eckert3_js__WEBPACK_IMPORTED_MODULE_18__["eckert3Raw"]; });

/* harmony import */ var _src_eckert4_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/eckert4.js */ "./node_modules/d3-geo-projection/src/eckert4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4", function() { return _src_eckert4_js__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4Raw", function() { return _src_eckert4_js__WEBPACK_IMPORTED_MODULE_19__["eckert4Raw"]; });

/* harmony import */ var _src_eckert5_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/eckert5.js */ "./node_modules/d3-geo-projection/src/eckert5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5", function() { return _src_eckert5_js__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5Raw", function() { return _src_eckert5_js__WEBPACK_IMPORTED_MODULE_20__["eckert5Raw"]; });

/* harmony import */ var _src_eckert6_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/eckert6.js */ "./node_modules/d3-geo-projection/src/eckert6.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6", function() { return _src_eckert6_js__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6Raw", function() { return _src_eckert6_js__WEBPACK_IMPORTED_MODULE_21__["eckert6Raw"]; });

/* harmony import */ var _src_eisenlohr_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/eisenlohr.js */ "./node_modules/d3-geo-projection/src/eisenlohr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohr", function() { return _src_eisenlohr_js__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohrRaw", function() { return _src_eisenlohr_js__WEBPACK_IMPORTED_MODULE_22__["eisenlohrRaw"]; });

/* harmony import */ var _src_fahey_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/fahey.js */ "./node_modules/d3-geo-projection/src/fahey.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFahey", function() { return _src_fahey_js__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFaheyRaw", function() { return _src_fahey_js__WEBPACK_IMPORTED_MODULE_23__["faheyRaw"]; });

/* harmony import */ var _src_foucaut_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/foucaut.js */ "./node_modules/d3-geo-projection/src/foucaut.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucaut", function() { return _src_foucaut_js__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucautRaw", function() { return _src_foucaut_js__WEBPACK_IMPORTED_MODULE_24__["foucautRaw"]; });

/* harmony import */ var _src_gilbert_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/gilbert.js */ "./node_modules/d3-geo-projection/src/gilbert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGilbert", function() { return _src_gilbert_js__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _src_gingery_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/gingery.js */ "./node_modules/d3-geo-projection/src/gingery.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingery", function() { return _src_gingery_js__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingeryRaw", function() { return _src_gingery_js__WEBPACK_IMPORTED_MODULE_26__["gingeryRaw"]; });

/* harmony import */ var _src_ginzburg4_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/ginzburg4.js */ "./node_modules/d3-geo-projection/src/ginzburg4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4", function() { return _src_ginzburg4_js__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4Raw", function() { return _src_ginzburg4_js__WEBPACK_IMPORTED_MODULE_27__["ginzburg4Raw"]; });

/* harmony import */ var _src_ginzburg5_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/ginzburg5.js */ "./node_modules/d3-geo-projection/src/ginzburg5.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5", function() { return _src_ginzburg5_js__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5Raw", function() { return _src_ginzburg5_js__WEBPACK_IMPORTED_MODULE_28__["ginzburg5Raw"]; });

/* harmony import */ var _src_ginzburg6_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/ginzburg6.js */ "./node_modules/d3-geo-projection/src/ginzburg6.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6", function() { return _src_ginzburg6_js__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6Raw", function() { return _src_ginzburg6_js__WEBPACK_IMPORTED_MODULE_29__["ginzburg6Raw"]; });

/* harmony import */ var _src_ginzburg8_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/ginzburg8.js */ "./node_modules/d3-geo-projection/src/ginzburg8.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8", function() { return _src_ginzburg8_js__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8Raw", function() { return _src_ginzburg8_js__WEBPACK_IMPORTED_MODULE_30__["ginzburg8Raw"]; });

/* harmony import */ var _src_ginzburg9_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/ginzburg9.js */ "./node_modules/d3-geo-projection/src/ginzburg9.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9", function() { return _src_ginzburg9_js__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9Raw", function() { return _src_ginzburg9_js__WEBPACK_IMPORTED_MODULE_31__["ginzburg9Raw"]; });

/* harmony import */ var _src_gringorten_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/gringorten.js */ "./node_modules/d3-geo-projection/src/gringorten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringorten", function() { return _src_gringorten_js__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenRaw", function() { return _src_gringorten_js__WEBPACK_IMPORTED_MODULE_32__["gringortenRaw"]; });

/* harmony import */ var _src_guyou_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/guyou.js */ "./node_modules/d3-geo-projection/src/guyou.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyou", function() { return _src_guyou_js__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyouRaw", function() { return _src_guyou_js__WEBPACK_IMPORTED_MODULE_33__["guyouRaw"]; });

/* harmony import */ var _src_hammer_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/hammer.js */ "./node_modules/d3-geo-projection/src/hammer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammer", function() { return _src_hammer_js__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRaw", function() { return _src_hammer_js__WEBPACK_IMPORTED_MODULE_34__["hammerRaw"]; });

/* harmony import */ var _src_hammerRetroazimuthal_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/hammerRetroazimuthal.js */ "./node_modules/d3-geo-projection/src/hammerRetroazimuthal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthal", function() { return _src_hammerRetroazimuthal_js__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthalRaw", function() { return _src_hammerRetroazimuthal_js__WEBPACK_IMPORTED_MODULE_35__["hammerRetroazimuthalRaw"]; });

/* harmony import */ var _src_healpix_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/healpix.js */ "./node_modules/d3-geo-projection/src/healpix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpix", function() { return _src_healpix_js__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpixRaw", function() { return _src_healpix_js__WEBPACK_IMPORTED_MODULE_36__["healpixRaw"]; });

/* harmony import */ var _src_hill_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/hill.js */ "./node_modules/d3-geo-projection/src/hill.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHill", function() { return _src_hill_js__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHillRaw", function() { return _src_hill_js__WEBPACK_IMPORTED_MODULE_37__["hillRaw"]; });

/* harmony import */ var _src_homolosine_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/homolosine.js */ "./node_modules/d3-geo-projection/src/homolosine.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosine", function() { return _src_homolosine_js__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosineRaw", function() { return _src_homolosine_js__WEBPACK_IMPORTED_MODULE_38__["homolosineRaw"]; });

/* harmony import */ var _src_interrupted_index__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./src/interrupted/index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterrupt", function() { return _src_interrupted_index__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _src_interrupted_boggs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./src/interrupted/boggs */ "./node_modules/d3-geo-projection/src/interrupted/boggs.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedBoggs", function() { return _src_interrupted_boggs__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _src_interrupted_homolosine__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./src/interrupted/homolosine */ "./node_modules/d3-geo-projection/src/interrupted/homolosine.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedHomolosine", function() { return _src_interrupted_homolosine__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _src_interrupted_mollweide__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./src/interrupted/mollweide */ "./node_modules/d3-geo-projection/src/interrupted/mollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweide", function() { return _src_interrupted_mollweide__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _src_interrupted_mollweideHemispheres__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./src/interrupted/mollweideHemispheres */ "./node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweideHemispheres", function() { return _src_interrupted_mollweideHemispheres__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _src_interrupted_sinuMollweide__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./src/interrupted/sinuMollweide */ "./node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinuMollweide", function() { return _src_interrupted_sinuMollweide__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _src_interrupted_sinusoidal__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./src/interrupted/sinusoidal */ "./node_modules/d3-geo-projection/src/interrupted/sinusoidal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinusoidal", function() { return _src_interrupted_sinusoidal__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _src_kavrayskiy7_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./src/kavrayskiy7.js */ "./node_modules/d3-geo-projection/src/kavrayskiy7.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7", function() { return _src_kavrayskiy7_js__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7Raw", function() { return _src_kavrayskiy7_js__WEBPACK_IMPORTED_MODULE_46__["kavrayskiy7Raw"]; });

/* harmony import */ var _src_lagrange_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./src/lagrange.js */ "./node_modules/d3-geo-projection/src/lagrange.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrange", function() { return _src_lagrange_js__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrangeRaw", function() { return _src_lagrange_js__WEBPACK_IMPORTED_MODULE_47__["lagrangeRaw"]; });

/* harmony import */ var _src_larrivee__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./src/larrivee */ "./node_modules/d3-geo-projection/src/larrivee.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarrivee", function() { return _src_larrivee__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarriveeRaw", function() { return _src_larrivee__WEBPACK_IMPORTED_MODULE_48__["larriveeRaw"]; });

/* harmony import */ var _src_laskowski__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./src/laskowski */ "./node_modules/d3-geo-projection/src/laskowski.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowski", function() { return _src_laskowski__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowskiRaw", function() { return _src_laskowski__WEBPACK_IMPORTED_MODULE_49__["laskowskiRaw"]; });

/* harmony import */ var _src_littrow_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./src/littrow.js */ "./node_modules/d3-geo-projection/src/littrow.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrow", function() { return _src_littrow_js__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrowRaw", function() { return _src_littrow_js__WEBPACK_IMPORTED_MODULE_50__["littrowRaw"]; });

/* harmony import */ var _src_loximuthal_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./src/loximuthal.js */ "./node_modules/d3-geo-projection/src/loximuthal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthal", function() { return _src_loximuthal_js__WEBPACK_IMPORTED_MODULE_51__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthalRaw", function() { return _src_loximuthal_js__WEBPACK_IMPORTED_MODULE_51__["loximuthalRaw"]; });

/* harmony import */ var _src_miller__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./src/miller */ "./node_modules/d3-geo-projection/src/miller.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMiller", function() { return _src_miller__WEBPACK_IMPORTED_MODULE_52__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMillerRaw", function() { return _src_miller__WEBPACK_IMPORTED_MODULE_52__["millerRaw"]; });

/* harmony import */ var _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./src/modifiedStereographic */ "./node_modules/d3-geo-projection/src/modifiedStereographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographic", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicRaw", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__["modifiedStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicAlaska", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__["modifiedStereographicAlaska"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs48", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__["modifiedStereographicGs48"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs50", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__["modifiedStereographicGs50"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicMiller", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__["modifiedStereographicMiller"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicLee", function() { return _src_modifiedStereographic__WEBPACK_IMPORTED_MODULE_53__["modifiedStereographicLee"]; });

/* harmony import */ var _src_mollweide__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./src/mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweide", function() { return _src_mollweide__WEBPACK_IMPORTED_MODULE_54__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweideRaw", function() { return _src_mollweide__WEBPACK_IMPORTED_MODULE_54__["mollweideRaw"]; });

/* harmony import */ var _src_mtFlatPolarParabolic__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./src/mtFlatPolarParabolic */ "./node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolic", function() { return _src_mtFlatPolarParabolic__WEBPACK_IMPORTED_MODULE_55__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolicRaw", function() { return _src_mtFlatPolarParabolic__WEBPACK_IMPORTED_MODULE_55__["mtFlatPolarParabolicRaw"]; });

/* harmony import */ var _src_mtFlatPolarQuartic__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./src/mtFlatPolarQuartic */ "./node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuartic", function() { return _src_mtFlatPolarQuartic__WEBPACK_IMPORTED_MODULE_56__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuarticRaw", function() { return _src_mtFlatPolarQuartic__WEBPACK_IMPORTED_MODULE_56__["mtFlatPolarQuarticRaw"]; });

/* harmony import */ var _src_mtFlatPolarSinusoidal__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./src/mtFlatPolarSinusoidal */ "./node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidal", function() { return _src_mtFlatPolarSinusoidal__WEBPACK_IMPORTED_MODULE_57__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidalRaw", function() { return _src_mtFlatPolarSinusoidal__WEBPACK_IMPORTED_MODULE_57__["mtFlatPolarSinusoidalRaw"]; });

/* harmony import */ var _src_naturalEarth__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./src/naturalEarth */ "./node_modules/d3-geo-projection/src/naturalEarth.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth", function() { return _src_naturalEarth__WEBPACK_IMPORTED_MODULE_58__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarthRaw", function() { return _src_naturalEarth__WEBPACK_IMPORTED_MODULE_58__["naturalEarthRaw"]; });

/* harmony import */ var _src_nellHammer__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./src/nellHammer */ "./node_modules/d3-geo-projection/src/nellHammer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammer", function() { return _src_nellHammer__WEBPACK_IMPORTED_MODULE_59__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammerRaw", function() { return _src_nellHammer__WEBPACK_IMPORTED_MODULE_59__["nellHammerRaw"]; });

/* harmony import */ var _src_patterson__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./src/patterson */ "./node_modules/d3-geo-projection/src/patterson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPatterson", function() { return _src_patterson__WEBPACK_IMPORTED_MODULE_60__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPattersonRaw", function() { return _src_patterson__WEBPACK_IMPORTED_MODULE_60__["pattersonRaw"]; });

/* harmony import */ var _src_polyconic__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./src/polyconic */ "./node_modules/d3-geo-projection/src/polyconic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconic", function() { return _src_polyconic__WEBPACK_IMPORTED_MODULE_61__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconicRaw", function() { return _src_polyconic__WEBPACK_IMPORTED_MODULE_61__["polyconicRaw"]; });

/* harmony import */ var _src_polyhedral_index_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./src/polyhedral/index.js */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedral", function() { return _src_polyhedral_index_js__WEBPACK_IMPORTED_MODULE_62__["default"]; });

/* harmony import */ var _src_polyhedral_butterfly_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./src/polyhedral/butterfly.js */ "./node_modules/d3-geo-projection/src/polyhedral/butterfly.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralButterfly", function() { return _src_polyhedral_butterfly_js__WEBPACK_IMPORTED_MODULE_63__["default"]; });

/* harmony import */ var _src_polyhedral_collignon_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./src/polyhedral/collignon.js */ "./node_modules/d3-geo-projection/src/polyhedral/collignon.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralCollignon", function() { return _src_polyhedral_collignon_js__WEBPACK_IMPORTED_MODULE_64__["default"]; });

/* harmony import */ var _src_polyhedral_waterman_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./src/polyhedral/waterman.js */ "./node_modules/d3-geo-projection/src/polyhedral/waterman.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralWaterman", function() { return _src_polyhedral_waterman_js__WEBPACK_IMPORTED_MODULE_65__["default"]; });

/* harmony import */ var _src_project_index__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./src/project/index */ "./node_modules/d3-geo-projection/src/project/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProject", function() { return _src_project_index__WEBPACK_IMPORTED_MODULE_66__["default"]; });

/* harmony import */ var _src_quincuncial_gringorten_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./src/quincuncial/gringorten.js */ "./node_modules/d3-geo-projection/src/quincuncial/gringorten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenQuincuncial", function() { return _src_quincuncial_gringorten_js__WEBPACK_IMPORTED_MODULE_67__["default"]; });

/* harmony import */ var _src_quincuncial_peirce_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./src/quincuncial/peirce.js */ "./node_modules/d3-geo-projection/src/quincuncial/peirce.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPeirceQuincuncial", function() { return _src_quincuncial_peirce_js__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPierceQuincuncial", function() { return _src_quincuncial_peirce_js__WEBPACK_IMPORTED_MODULE_68__["default"]; });

/* harmony import */ var _src_quantize__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./src/quantize */ "./node_modules/d3-geo-projection/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuantize", function() { return _src_quantize__WEBPACK_IMPORTED_MODULE_69__["default"]; });

/* harmony import */ var _src_quincuncial_index_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./src/quincuncial/index.js */ "./node_modules/d3-geo-projection/src/quincuncial/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuincuncial", function() { return _src_quincuncial_index_js__WEBPACK_IMPORTED_MODULE_70__["default"]; });

/* harmony import */ var _src_rectangularPolyconic__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./src/rectangularPolyconic */ "./node_modules/d3-geo-projection/src/rectangularPolyconic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconic", function() { return _src_rectangularPolyconic__WEBPACK_IMPORTED_MODULE_71__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconicRaw", function() { return _src_rectangularPolyconic__WEBPACK_IMPORTED_MODULE_71__["rectangularPolyconicRaw"]; });

/* harmony import */ var _src_robinson__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./src/robinson */ "./node_modules/d3-geo-projection/src/robinson.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinson", function() { return _src_robinson__WEBPACK_IMPORTED_MODULE_72__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinsonRaw", function() { return _src_robinson__WEBPACK_IMPORTED_MODULE_72__["robinsonRaw"]; });

/* harmony import */ var _src_satellite__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./src/satellite */ "./node_modules/d3-geo-projection/src/satellite.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatellite", function() { return _src_satellite__WEBPACK_IMPORTED_MODULE_73__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatelliteRaw", function() { return _src_satellite__WEBPACK_IMPORTED_MODULE_73__["satelliteRaw"]; });

/* harmony import */ var _src_sinuMollweide__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./src/sinuMollweide */ "./node_modules/d3-geo-projection/src/sinuMollweide.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweide", function() { return _src_sinuMollweide__WEBPACK_IMPORTED_MODULE_74__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweideRaw", function() { return _src_sinuMollweide__WEBPACK_IMPORTED_MODULE_74__["sinuMollweideRaw"]; });

/* harmony import */ var _src_sinusoidal__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./src/sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidal", function() { return _src_sinusoidal__WEBPACK_IMPORTED_MODULE_75__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidalRaw", function() { return _src_sinusoidal__WEBPACK_IMPORTED_MODULE_75__["sinusoidalRaw"]; });

/* harmony import */ var _src_stitch__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./src/stitch */ "./node_modules/d3-geo-projection/src/stitch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStitch", function() { return _src_stitch__WEBPACK_IMPORTED_MODULE_76__["default"]; });

/* harmony import */ var _src_times__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./src/times */ "./node_modules/d3-geo-projection/src/times.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimes", function() { return _src_times__WEBPACK_IMPORTED_MODULE_77__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimesRaw", function() { return _src_times__WEBPACK_IMPORTED_MODULE_77__["timesRaw"]; });

/* harmony import */ var _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./src/twoPointAzimuthal */ "./node_modules/d3-geo-projection/src/twoPointAzimuthal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthal", function() { return _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_78__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalRaw", function() { return _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_78__["twoPointAzimuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalUsa", function() { return _src_twoPointAzimuthal__WEBPACK_IMPORTED_MODULE_78__["twoPointAzimuthalUsa"]; });

/* harmony import */ var _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./src/twoPointEquidistant */ "./node_modules/d3-geo-projection/src/twoPointEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistant", function() { return _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_79__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantRaw", function() { return _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_79__["twoPointEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantUsa", function() { return _src_twoPointEquidistant__WEBPACK_IMPORTED_MODULE_79__["twoPointEquidistantUsa"]; });

/* harmony import */ var _src_vanDerGrinten__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./src/vanDerGrinten */ "./node_modules/d3-geo-projection/src/vanDerGrinten.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten", function() { return _src_vanDerGrinten__WEBPACK_IMPORTED_MODULE_80__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrintenRaw", function() { return _src_vanDerGrinten__WEBPACK_IMPORTED_MODULE_80__["vanDerGrintenRaw"]; });

/* harmony import */ var _src_vanDerGrinten2__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./src/vanDerGrinten2 */ "./node_modules/d3-geo-projection/src/vanDerGrinten2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2", function() { return _src_vanDerGrinten2__WEBPACK_IMPORTED_MODULE_81__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2Raw", function() { return _src_vanDerGrinten2__WEBPACK_IMPORTED_MODULE_81__["vanDerGrinten2Raw"]; });

/* harmony import */ var _src_vanDerGrinten3__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./src/vanDerGrinten3 */ "./node_modules/d3-geo-projection/src/vanDerGrinten3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3", function() { return _src_vanDerGrinten3__WEBPACK_IMPORTED_MODULE_82__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3Raw", function() { return _src_vanDerGrinten3__WEBPACK_IMPORTED_MODULE_82__["vanDerGrinten3Raw"]; });

/* harmony import */ var _src_vanDerGrinten4__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./src/vanDerGrinten4 */ "./node_modules/d3-geo-projection/src/vanDerGrinten4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4", function() { return _src_vanDerGrinten4__WEBPACK_IMPORTED_MODULE_83__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4Raw", function() { return _src_vanDerGrinten4__WEBPACK_IMPORTED_MODULE_83__["vanDerGrinten4Raw"]; });

/* harmony import */ var _src_wagner4_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./src/wagner4.js */ "./node_modules/d3-geo-projection/src/wagner4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4", function() { return _src_wagner4_js__WEBPACK_IMPORTED_MODULE_84__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4Raw", function() { return _src_wagner4_js__WEBPACK_IMPORTED_MODULE_84__["wagner4Raw"]; });

/* harmony import */ var _src_wagner6_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./src/wagner6.js */ "./node_modules/d3-geo-projection/src/wagner6.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6", function() { return _src_wagner6_js__WEBPACK_IMPORTED_MODULE_85__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6Raw", function() { return _src_wagner6_js__WEBPACK_IMPORTED_MODULE_85__["wagner6Raw"]; });

/* harmony import */ var _src_wagner7_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./src/wagner7.js */ "./node_modules/d3-geo-projection/src/wagner7.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7", function() { return _src_wagner7_js__WEBPACK_IMPORTED_MODULE_86__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7Raw", function() { return _src_wagner7_js__WEBPACK_IMPORTED_MODULE_86__["wagner7Raw"]; });

/* harmony import */ var _src_wiechel_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./src/wiechel.js */ "./node_modules/d3-geo-projection/src/wiechel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechel", function() { return _src_wiechel_js__WEBPACK_IMPORTED_MODULE_87__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechelRaw", function() { return _src_wiechel_js__WEBPACK_IMPORTED_MODULE_87__["wiechelRaw"]; });

/* harmony import */ var _src_winkel3__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./src/winkel3 */ "./node_modules/d3-geo-projection/src/winkel3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3", function() { return _src_winkel3__WEBPACK_IMPORTED_MODULE_88__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3Raw", function() { return _src_winkel3__WEBPACK_IMPORTED_MODULE_88__["winkel3Raw"]; });






































































 // DEPRECATED misspelling






















/***/ }),

/***/ "./node_modules/d3-geo-projection/src/airy.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/airy.js ***!
  \****************************************************/
/*! exports provided: airyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "airyRaw", function() { return airyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function airyRaw(beta) {
  var tanBeta_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(beta / 2),
      b = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(beta / 2)) / (tanBeta_2 * tanBeta_2);

  function forward(x, y) {
    var cosx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x),
        cosy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y),
        siny = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y),
        cosz = cosy * cosx,
        k = -((1 - cosz ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz));
    return [k * cosy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x), k * siny];
  }

  forward.invert = function (x, y) {
    var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y),
        z = -beta / 2,
        i = 50,
        delta;
    if (!r) return [0, 0];

    do {
      var z_2 = z / 2,
          cosz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(z_2),
          sinz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(z_2),
          tanz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(z_2),
          lnsecz_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(1 / cosz_2);
      z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2));
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

    var sinz = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(z);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * sinz, r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(z)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * sinz / r)];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var beta = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(airyRaw),
      p = m(beta);

  p.radius = function (_) {
    return arguments.length ? m(beta = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) : beta * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
  };

  return p.scale(179.976).clipAngle(147);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/aitoff.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/aitoff.js ***!
  \******************************************************/
/*! exports provided: aitoffRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aitoffRaw", function() { return aitoffRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function aitoffRaw(x, y) {
  var cosy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y),
      sincia = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sinci"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x /= 2)));
  return [2 * cosy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x) * sincia, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y) * sincia];
} // Abort if [x, y] is not within an ellipse centered at [0, 0] with
// semi-major axis pi and semi-minor axis pi/2.

aitoffRaw.invert = function (x, y) {
  if (x * x + 4 * y * y > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return;
  var x1 = x,
      y1 = y,
      i = 25;

  do {
    var sinx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x1),
        sinx_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x1 / 2),
        cosx_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x1 / 2),
        siny = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y1),
        cosy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y1),
        sin_2y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * y1),
        sin2y = siny * siny,
        cos2y = cosy * cosy,
        sin2x_2 = sinx_2 * sinx_2,
        c = 1 - cos2y * cosx_2 * cosx_2,
        e = c ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosy * cosx_2) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(f = 1 / c) : f = 0,
        f,
        fx = 2 * e * cosy * sinx_2 - x,
        fy = e * siny - y,
        dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y),
        dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2),
        dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx),
        dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy),
        z = dxdy * dydx - dydy * dxdx;
    if (!z) break;
    var dx = (fy * dxdy - fx * dydy) / z,
        dy = (fx * dydx - fy * dxdx) / z;
    x1 -= dx, y1 -= dy;
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dx) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dy) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) && --i > 0);

  return [x1, y1];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(aitoffRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/armadillo.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/armadillo.js ***!
  \*********************************************************/
/*! exports provided: armadilloRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "armadilloRaw", function() { return armadilloRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function armadilloRaw(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0),
      cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0),
      sPhi0 = phi0 >= 0 ? 1 : -1,
      tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(sPhi0 * phi0),
      k = (1 + sinPhi0 - cosPhi0) / 2;

  function forward(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda /= 2);
    return [(1 + cosPhi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), (sPhi0 * phi > -Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda // TODO D3 core should allow null or [NaN, NaN] to be returned.
    ];
  }

  forward.invert = function (x, y) {
    var lambda = 0,
        phi = 0,
        i = 50;

    do {
      var cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda),
          sinLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda),
          cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
          sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
          A = 1 + cosPhi,
          fx = A * sinLambda - x,
          fy = k + sinPhi * cosPhi0 - A * sinPhi0 * cosLambda - y,
          dxdLambda = A * cosLambda / 2,
          dxdPhi = -sinLambda * sinPhi,
          dydLambda = sinPhi0 * A * sinLambda / 2,
          dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi,
          denominator = dxdPhi * dydLambda - dydPhi * dxdLambda,
          dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2,
          dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;
      lambda -= dLambda, phi -= dPhi;
    } while ((Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dLambda) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dPhi) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) && --i > 0);

    return sPhi0 * phi > -Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var phi0 = 20 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      sPhi0 = phi0 >= 0 ? 1 : -1,
      tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(sPhi0 * phi0),
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(armadilloRaw),
      p = m(phi0),
      stream_ = p.stream;

  p.parallel = function (_) {
    if (!arguments.length) return phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])((sPhi0 = (phi0 = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) >= 0 ? 1 : -1) * phi0);
    return m(phi0);
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart(), sphereStream.lineStart();

      for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90) {
        sphereStream.point(lambda, sPhi0 * 90);
      }

      while (sPhi0 * (lambda -= phi0) >= -180) {
        // TODO precision?
        sphereStream.point(lambda, sPhi0 * -Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda * _math__WEBPACK_IMPORTED_MODULE_1__["radians"] / 2), tanPhi0) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
      }

      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return p.scale(218.695).center([0, 28.0974]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/august.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/august.js ***!
  \******************************************************/
/*! exports provided: augustRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "augustRaw", function() { return augustRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function augustRaw(lambda, phi) {
  var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - tanPhi * tanPhi),
      c = 1 + k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda /= 2),
      x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * k / c,
      y = tanPhi / c,
      x2 = x * x,
      y2 = y * y;
  return [4 / 3 * x * (3 + x2 - 3 * y2), 4 / 3 * y * (3 + 3 * x2 - y2)];
}

augustRaw.invert = function (x, y) {
  x *= 3 / 8, y *= 3 / 8;
  if (!x && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) > 1) return null;
  var x2 = x * x,
      y2 = y * y,
      s = 1 + x2 + y2,
      sin3Eta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((s - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(s * s - 4 * y * y)) / 2),
      eta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sin3Eta) / 3,
      xi = sin3Eta ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["arcosh"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y / sin3Eta)) / 3 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["arsinh"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x)) / 3,
      cosEta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(eta),
      coshXi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cosh"])(xi),
      d = coshXi * coshXi - cosEta * cosEta;
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sinh"])(xi) * cosEta, 0.25 - d), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(coshXi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(eta), 0.25 + d)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(augustRaw).scale(66.1603);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/baker.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/baker.js ***!
  \*****************************************************/
/*! exports provided: bakerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bakerRaw", function() { return bakerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var sqrt8 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(8),
    phi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(1 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"]);
function bakerRaw(lambda, phi) {
  var phi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi);
  return phi0 < _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] ? [lambda, Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi / 2))] : [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0) * (2 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] - 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * (2 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] * (phi0 - _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]) - Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi0 / 2)))];
}

bakerRaw.invert = function (x, y) {
  if ((y0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y)) < phi0) return [x, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["exp"])(y)) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]];
  var phi = _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"],
      i = 25,
      delta,
      y0;

  do {
    var cosPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2),
        tanPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2);
    phi -= delta = (sqrt8 * (phi - _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]) - Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(tanPhi_2) - y0) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] && --i > 0);

  return [x / (Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * (sqrt8 - 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi))), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(bakerRaw).scale(112.314);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/berghaus.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/berghaus.js ***!
  \********************************************************/
/*! exports provided: berghausRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "berghausRaw", function() { return berghausRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function berghausRaw(lobes) {
  var k = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lobes;

  function forward(lambda, phi) {
    var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"])(lambda, phi);

    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) {
      // back hemisphere
      var theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(p[1], p[0]),
          r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(p[0] * p[0] + p[1] * p[1]),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])((theta - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) / k) + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
          α = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta -= theta0), 2 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta)); // angle relative to lobe end

      theta = theta0 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(α)) - α;
      p[0] = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta);
      p[1] = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta);
    }

    return p;
  }

  forward.invert = function (x, y) {
    var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y);

    if (r > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) {
      var theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])((theta - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) / k) + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
          s = theta > theta0 ? -1 : 1,
          A = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta0 - theta),
          cotα = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(s * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])((A - _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] - 2 * A) + r * r)));
      theta = theta0 + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])((cotα + s * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(cotα * cotα - 3)) / 3);
      x = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta), y = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta);
    }

    return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"].invert(x, y);
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var lobes = 5,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(berghausRaw),
      p = m(lobes),
      projectionStream = p.stream,
      epsilon = 1e-2,
      cr = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]),
      sr = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);

  p.lobes = function (_) {
    return arguments.length ? m(lobes = +_) : lobes;
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = projectionStream(stream),
        sphereStream = (p.rotate([0, 0]), projectionStream(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart(), sphereStream.lineStart();

      for (var i = 0, delta = 360 / lobes, delta0 = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lobes, phi = 90 - 180 / lobes, phi0 = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]; i < lobes; ++i, phi -= delta, phi0 -= delta0) {
        sphereStream.point(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0), cr) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0)) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);

        if (phi < -90) {
          sphereStream.point(-90, -180 - phi - epsilon);
          sphereStream.point(-90, -180 - phi + epsilon);
        } else {
          sphereStream.point(90, phi + epsilon);
          sphereStream.point(90, phi - epsilon);
        }
      }

      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return p.scale(87.8076).center([0, 17.1875]).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/boggs.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/boggs.js ***!
  \*****************************************************/
/*! exports provided: boggsRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boggsRaw", function() { return boggsRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



var k = 2.00276,
    w = 1.11072;
function boggsRaw(lambda, phi) {
  var theta = Object(_mollweide__WEBPACK_IMPORTED_MODULE_1__["mollweideBromleyTheta"])(_math__WEBPACK_IMPORTED_MODULE_2__["pi"], phi);
  return [k * lambda / (1 / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) + w / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(theta)), (phi + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(theta)) / k];
}

boggsRaw.invert = function (x, y) {
  var ky = k * y,
      theta = y < 0 ? -_math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"] : _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
      i = 25,
      delta,
      phi;

  do {
    phi = ky - _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(theta);
    theta -= delta = (Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(2 * theta) + 2 * theta - _math__WEBPACK_IMPORTED_MODULE_2__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi)) / (2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(2 * theta) + 2 + _math__WEBPACK_IMPORTED_MODULE_2__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) * _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(theta));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && --i > 0);

  phi = ky - _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(theta);
  return [x * (1 / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) + w / Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(theta)) / k, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(boggsRaw).scale(160.857);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/bonne.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/bonne.js ***!
  \*****************************************************/
/*! exports provided: bonneRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bonneRaw", function() { return bonneRaw; });
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");



function bonneRaw(phi0) {
  if (!phi0) return _sinusoidal__WEBPACK_IMPORTED_MODULE_2__["sinusoidalRaw"];
  var cotPhi0 = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi0);

  function forward(lambda, phi) {
    var rho = cotPhi0 + phi0 - phi,
        e = rho ? lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) / rho : rho;
    return [rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(e), cotPhi0 - rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(e)];
  }

  forward.invert = function (x, y) {
    var rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + (y = cotPhi0 - y) * y),
        phi = cotPhi0 + phi0 - rho;
    return [rho / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x, y), phi];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_0__["default"])(bonneRaw).scale(123.082).center([0, 26.1441]).parallel(45);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/bottomley.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/bottomley.js ***!
  \*********************************************************/
/*! exports provided: bottomleyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bottomleyRaw", function() { return bottomleyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function bottomleyRaw(sinPsi) {
  function forward(lambda, phi) {
    var rho = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - phi,
        eta = rho ? lambda * sinPsi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho) / rho : rho;
    return [rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(eta) / sinPsi, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(eta)];
  }

  forward.invert = function (x, y) {
    var x1 = x * sinPsi,
        y1 = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - y,
        rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x1 * x1 + y1 * y1),
        eta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x1, y1);
    return [(rho ? rho / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho) : 1) * eta / sinPsi, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rho];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var sinPsi = 0.5,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(bottomleyRaw),
      p = m(sinPsi);

  p.fraction = function (_) {
    return arguments.length ? m(sinPsi = +_) : sinPsi;
  };

  return p.scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/bromley.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/bromley.js ***!
  \*******************************************************/
/*! exports provided: bromleyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bromleyRaw", function() { return bromleyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");



var bromleyRaw = Object(_mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideBromleyRaw"])(1, 4 / _math__WEBPACK_IMPORTED_MODULE_1__["pi"], _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(bromleyRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/chamberlin.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/chamberlin.js ***!
  \**********************************************************/
/*! exports provided: chamberlinRaw, chamberlinAfrica, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chamberlinRaw", function() { return chamberlinRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chamberlinAfrica", function() { return chamberlinAfrica; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return chamberlin; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

 // Azimuthal distance.

function distance(dPhi, c1, s1, c2, s2, dLambda) {
  var cosdLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(dLambda),
      r;

  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dPhi) > 1 || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dLambda) > 1) {
    r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(s1 * s2 + c1 * c2 * cosdLambda);
  } else {
    var sindPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dPhi / 2),
        sindLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dLambda / 2);
    r = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));
  }

  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(r) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? [r, Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(c2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];
} // Angle opposite a, and contained between sides of lengths b and c.


function angle(b, c, a) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])((b * b + c * c - a * a) / (2 * b * c));
} // Normalize longitude.


function longitude(lambda) {
  return lambda - 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])((lambda + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / (2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]));
}

function chamberlinRaw(p0, p1, p2) {
  var points = [[p0[0], p0[1], Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(p0[1]), Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(p0[1])], [p1[0], p1[1], Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(p1[1]), Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(p1[1])], [p2[0], p2[1], Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(p2[1]), Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(p2[1])]];

  for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {
    b = points[i];
    a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
    a.point = [0, 0];
  }

  var beta0 = angle(points[0].v[0], points[2].v[0], points[1].v[0]),
      beta1 = angle(points[0].v[0], points[1].v[0], points[2].v[0]),
      beta2 = _math__WEBPACK_IMPORTED_MODULE_1__["pi"] - beta0;
  points[2].point[1] = 0;
  points[0].point[0] = -(points[1].point[0] = points[0].v[0] / 2);
  var mean = [points[2].point[0] = points[0].point[0] + points[2].v[0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(beta0), 2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(beta0))];

  function forward(lambda, phi) {
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        v = new Array(3),
        i; // Compute distance and azimuth from control points.

    for (i = 0; i < 3; ++i) {
      var p = points[i];
      v[i] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);
      if (!v[i][0]) return p.point;
      v[i][1] = longitude(v[i][1] - p.v[1]);
    } // Arithmetic mean of interception points.


    var point = mean.slice();

    for (i = 0; i < 3; ++i) {
      var j = i == 2 ? 0 : i + 1;
      var a = angle(points[i].v[0], v[i][0], v[j][0]);
      if (v[i][1] < 0) a = -a;

      if (!i) {
        point[0] += v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(a);
        point[1] -= v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a);
      } else if (i == 1) {
        a = beta1 - a;
        point[0] -= v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(a);
        point[1] -= v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a);
      } else {
        a = beta2 - a;
        point[0] += v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(a);
        point[1] += v[i][0] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a);
      }
    }

    point[0] /= 3, point[1] /= 3;
    return point;
  }

  return forward;
}

function pointRadians(p) {
  return p[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], p[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], p;
}

function chamberlinAfrica() {
  return chamberlin([0, 22], [45, 22], [22.5, -22]).scale(380).center([22.5, 2]);
}
function chamberlin(p0, p1, p2) {
  // TODO order matters!
  var c = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
    type: "MultiPoint",
    coordinates: [p0, p1, p2]
  }),
      R = [-c[0], -c[1]],
      r = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])(R),
      p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R),
      center = p.center;
  delete p.rotate;

  p.center = function (_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };

  return p.clipAngle(90);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/collignon.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/collignon.js ***!
  \*********************************************************/
/*! exports provided: collignonRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "collignonRaw", function() { return collignonRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function collignonRaw(lambda, phi) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi));
  return [2 / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * lambda * alpha, _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * (1 - alpha)];
}

collignonRaw.invert = function (x, y) {
  var lambda = (lambda = y / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] - 1) * lambda;
  return [lambda > 0 ? x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda) / 2 : 0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 - lambda)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(collignonRaw).scale(95.6464).center([0, 30]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/craig.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/craig.js ***!
  \*****************************************************/
/*! exports provided: craigRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "craigRaw", function() { return craigRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function craigRaw(phi0) {
  var tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi0);

  function forward(lambda, phi) {
    return [lambda, (lambda ? lambda / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda) : 1) * (Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda) - tanPhi0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi))];
  }

  forward.invert = tanPhi0 ? function (x, y) {
    if (x) y *= Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / x;
    var cosλ = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x);
    return [x, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cosλ * cosλ + tanPhi0 * tanPhi0 - y * y) - cosλ, tanPhi0 - y)];
  } : function (x, y) {
    return [x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(x ? y * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(x) / x : y)];
  };
  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(craigRaw).scale(249.828).clipAngle(90);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/craster.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/craster.js ***!
  \*******************************************************/
/*! exports provided: crasterRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crasterRaw", function() { return crasterRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var sqrt3 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3);
function crasterRaw(lambda, phi) {
  return [sqrt3 * lambda * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * phi / 3) - 1) / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"], sqrt3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi / 3)];
}

crasterRaw.invert = function (x, y) {
  var phi = 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y / (sqrt3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"]));
  return [_math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * x / (sqrt3 * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * phi / 3) - 1)), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(crasterRaw).scale(156.19);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/cylindricalEqualArea.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/cylindricalEqualArea.js ***!
  \********************************************************************/
/*! exports provided: cylindricalEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalEqualAreaRaw", function() { return cylindricalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(y * cosPhi0)];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(cylindricalEqualAreaRaw).parallel(38.58) // acos(sqrt(width / height / pi)) * radians
  .scale(195.044); // width / (sqrt(width / height / pi) * 2 * pi)
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/cylindricalStereographic.js":
/*!************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/cylindricalStereographic.js ***!
  \************************************************************************/
/*! exports provided: cylindricalStereographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalStereographicRaw", function() { return cylindricalStereographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function cylindricalStereographicRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (1 + cosPhi0) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi / 2)];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(y / (1 + cosPhi0)) * 2];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(cylindricalStereographicRaw).scale(124.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert1.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert1.js ***!
  \*******************************************************/
/*! exports provided: eckert1Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert1Raw", function() { return eckert1Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert1Raw(lambda, phi) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(8 / (3 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]));
  return [alpha * lambda * (1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]), alpha * phi];
}

eckert1Raw.invert = function (x, y) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(8 / (3 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"])),
      phi = y / alpha;
  return [x / (alpha * (1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"])), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert1Raw).scale(165.664);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert2.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert2.js ***!
  \*******************************************************/
/*! exports provided: eckert2Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert2Raw", function() { return eckert2Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert2Raw(lambda, phi) {
  var alpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(4 - 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi)));
  return [2 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * lambda * alpha, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3) * (2 - alpha)];
}

eckert2Raw.invert = function (x, y) {
  var alpha = 2 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3);
  return [x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / (2 * alpha), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((4 - alpha * alpha) / 3)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert2Raw).scale(165.664);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert3.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert3.js ***!
  \*******************************************************/
/*! exports provided: eckert3Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert3Raw", function() { return eckert3Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert3Raw(lambda, phi) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]));
  return [2 / k * lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - 4 * phi * phi / (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))), 4 / k * phi];
}

eckert3Raw.invert = function (x, y) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) / 2;
  return [x * k / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - y * y * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / (4 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))), y * k / 2];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert3Raw).scale(180.739);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert4.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert4.js ***!
  \*******************************************************/
/*! exports provided: eckert4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert4Raw", function() { return eckert4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert4Raw(lambda, phi) {
  var k = (2 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
  phi /= 2;

  for (var i = 0, delta = Infinity; i < 10 && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; i++) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
    phi -= delta = (phi + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) * (cosPhi + 2) - k) / (2 * cosPhi * (1 + cosPhi));
  }

  return [2 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) * lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
}

eckert4Raw.invert = function (x, y) {
  var A = y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(A),
      c = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k);
  return [x / (2 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])) * (1 + c)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((k + A * (c + 2)) / (2 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert4Raw).scale(180.739);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert5.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert5.js ***!
  \*******************************************************/
/*! exports provided: eckert5Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert5Raw", function() { return eckert5Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert5Raw(lambda, phi) {
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]), 2 * phi / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])];
}

eckert5Raw.invert = function (x, y) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]),
      phi = y * k / 2;
  return [k * x / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert5Raw).scale(173.044);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eckert6.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eckert6.js ***!
  \*******************************************************/
/*! exports provided: eckert6Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eckert6Raw", function() { return eckert6Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function eckert6Raw(lambda, phi) {
  var k = (1 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);

  for (var i = 0, delta = Infinity; i < 10 && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; i++) {
    phi -= delta = (phi + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) - k) / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi));
  }

  k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)) / k, 2 * phi / k];
}

eckert6Raw.invert = function (x, y) {
  var j = 1 + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(j / 2);
  return [x * 2 * k / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y *= k)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((y + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(y)) / j)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eckert6Raw).scale(173.044);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/eisenlohr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/eisenlohr.js ***!
  \*********************************************************/
/*! exports provided: eisenlohrRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eisenlohrRaw", function() { return eisenlohrRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _august__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./august */ "./node_modules/d3-geo-projection/src/august.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



var eisenlohrK = 3 + 2 * _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"];
function eisenlohrRaw(lambda, phi) {
  var s0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda /= 2),
      c0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi)),
      c1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi /= 2),
      t = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi) / (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k),
      c = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(2 / (1 + t * t)),
      v = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])((_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 + s0) * k) / (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 - s0) * k));
  return [eisenlohrK * (c * (v - 1 / v) - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(v)), eisenlohrK * (c * t * (v + 1 / v) - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan"])(t))];
}

eisenlohrRaw.invert = function (x, y) {
  if (!(p = _august__WEBPACK_IMPORTED_MODULE_1__["augustRaw"].invert(x / 1.2, y * 1.065))) return null;
  var lambda = p[0],
      phi = p[1],
      i = 20,
      p;
  x /= eisenlohrK, y /= eisenlohrK;

  do {
    var _0 = lambda / 2,
        _1 = phi / 2,
        s0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(_0),
        c0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(_0),
        s1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(_1),
        c1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(_1),
        cos1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi),
        k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(cos1),
        t = s1 / (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k),
        t2 = t * t,
        c = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(2 / (1 + t2)),
        v0 = _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 + s0) * k,
        v1 = _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c1 + (c0 - s0) * k,
        v2 = v0 / v1,
        v = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(v2),
        vm1v = v - 1 / v,
        vp1v = v + 1 / v,
        fx = c * vm1v - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(v) - x,
        fy = c * t * vp1v - 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan"])(t) - y,
        deltatDeltaLambda = s1 && _math__WEBPACK_IMPORTED_MODULE_2__["sqrt1_2"] * k * s0 * t2 / s1,
        deltatDeltaPhi = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * c1 + k) / (2 * (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k) * (c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * k) * k),
        deltacDeltat = -0.5 * t * c * c * c,
        deltacDeltaLambda = deltacDeltat * deltatDeltaLambda,
        deltacDeltaPhi = deltacDeltat * deltatDeltaPhi,
        A = (A = 2 * c1 + _math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * k * (c0 - s0)) * A * v,
        deltavDeltaLambda = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * c0 * c1 * k + cos1) / A,
        deltavDeltaPhi = -(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] * s0 * s1) / (k * A),
        deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2),
        deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2),
        deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2),
        deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2),
        denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;

    if (!denominator) break;
    var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator,
        deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda;
    phi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["max"])(-_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], Object(_math__WEBPACK_IMPORTED_MODULE_2__["min"])(_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], phi - deltaPhi));
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(deltaLambda) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(deltaPhi) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) && --i > 0);

  return Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] ? [0, phi] : i && [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(eisenlohrRaw).scale(62.5271);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/elliptic.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/elliptic.js ***!
  \********************************************************/
/*! exports provided: ellipticJi, ellipticJ, ellipticFi, ellipticF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticJi", function() { return ellipticJi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticJ", function() { return ellipticJ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticFi", function() { return ellipticFi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ellipticF", function() { return ellipticF; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
 // Returns [sn, cn, dn](u + iv|m).

function ellipticJi(u, v, m) {
  var a, b, c;

  if (!u) {
    b = ellipticJ(v, 1 - m);
    return [[0, b[0] / b[1]], [1 / b[1], 0], [b[2] / b[1], 0]];
  }

  a = ellipticJ(u, m);
  if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
  b = ellipticJ(v, 1 - m);
  c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
  return [[a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c], [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c], [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]];
} // Returns [sn, cn, dn, ph](u|m).

function ellipticJ(u, m) {
  var ai, b, phi, t, twon;

  if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    t = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(u);
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(u);
    ai = m * (u - t * b) / 4;
    return [t - ai * b, b + ai * t, 1 - m * t * t / 2, u - ai];
  }

  if (m >= 1 - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) {
    ai = (1 - m) / 4;
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cosh"])(u);
    t = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tanh"])(u);
    phi = 1 / b;
    twon = b * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sinh"])(u);
    return [t + ai * (twon - u) / (b * b), phi - ai * t * phi * (twon - u), phi + ai * t * phi * (twon + u), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["exp"])(u)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + ai * (twon - u) / b];
  }

  var a = [1, 0, 0, 0, 0, 0, 0, 0, 0],
      c = [Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m), 0, 0, 0, 0, 0, 0, 0, 0],
      i = 0;
  b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(1 - m);
  twon = 1;

  while (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(c[i] / a[i]) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && i < 8) {
    ai = a[i++];
    c[i] = (ai - b) / 2;
    a[i] = (ai + b) / 2;
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(ai * b);
    twon *= 2;
  }

  phi = twon * a[i] * u;

  do {
    t = c[i] * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(b = phi) / a[i];
    phi = (Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(t) + phi) / 2;
  } while (--i);

  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi), t = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi), t / Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi - b), phi];
} // Calculate F(phi+iPsi|m).
// See Abramowitz and Stegun, 17.4.11.

function ellipticFi(phi, psi, m) {
  var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(phi),
      i = Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(psi),
      sinhPsi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sinh"])(i);

  if (r) {
    var cscPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(r),
        cotPhi2 = 1 / (Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(r) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(r)),
        b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m),
        c = (m - 1) * cotPhi2,
        cotLambda2 = (-b + Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(b * b - 4 * c)) / 2;
    return [ellipticF(Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cotLambda2)), m) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(phi), ellipticF(Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(psi)];
  }

  return [0, ellipticF(Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(sinhPsi), 1 - m) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(psi)];
} // Calculate F(phi|m) where m = k² = sin²α.
// See Abramowitz and Stegun, 17.6.7.

function ellipticF(phi, m) {
  if (!m) return phi;
  if (m === 1) return Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi / 2 + _math__WEBPACK_IMPORTED_MODULE_0__["quarterPi"]));
  var a = 1,
      b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(1 - m),
      c = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m);

  for (var i = 0; Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(c) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]; i++) {
    if (phi % _math__WEBPACK_IMPORTED_MODULE_0__["pi"]) {
      var dPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(b * Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi) / a);
      if (dPhi < 0) dPhi += _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
      phi += dPhi + ~~(phi / _math__WEBPACK_IMPORTED_MODULE_0__["pi"]) * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    } else phi += phi;

    c = (a + b) / 2;
    b = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(a * b);
    c = ((a = c) - b) / 2;
  }

  return phi / (Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(2, i) * a);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/fahey.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/fahey.js ***!
  \*****************************************************/
/*! exports provided: faheyRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "faheyRaw", function() { return faheyRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var faheyK = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(35 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
function faheyRaw(lambda, phi) {
  var t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2);
  return [lambda * faheyK * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - t * t), (1 + faheyK) * t];
}

faheyRaw.invert = function (x, y) {
  var t = y / (1 + faheyK);
  return [x && x / (faheyK * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - t * t)), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(t)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(faheyRaw).scale(137.152);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/foucaut.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/foucaut.js ***!
  \*******************************************************/
/*! exports provided: foucautRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "foucautRaw", function() { return foucautRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function foucautRaw(lambda, phi) {
  var k = phi / 2,
      cosk = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k);
  return [2 * lambda / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * cosk * cosk, _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(k)];
}

foucautRaw.invert = function (x, y) {
  var k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y / _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"]),
      cosk = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k),
      phi = 2 * k;
  return [x * _math__WEBPACK_IMPORTED_MODULE_1__["sqrtPi"] / 2 / (Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * cosk * cosk), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(foucautRaw).scale(135.264);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/gilbert.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/gilbert.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



function gilbertForward(point) {
  return [point[0] / 2, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(point[1] / 2 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"])) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]];
}

function gilbertInvert(point) {
  return [point[0] * 2, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(point[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"])) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]];
}

/* harmony default export */ __webpack_exports__["default"] = (function (projectionType) {
  if (projectionType == null) projectionType = d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoOrthographic"];
  var projection = projectionType(),
      equirectangular = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoEquirectangular"])().scale(_math__WEBPACK_IMPORTED_MODULE_1__["degrees"]).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting

  function gilbert(point) {
    return projection(gilbertForward(point));
  }

  if (projection.invert) gilbert.invert = function (point) {
    return gilbertInvert(projection.invert(point));
  };

  gilbert.stream = function (stream) {
    var s1 = projection.stream(stream),
        s0 = equirectangular.stream({
      point: function point(lambda, phi) {
        s1.point(lambda / 2, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(-phi / 2 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"])) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
      },
      lineStart: function lineStart() {
        s1.lineStart();
      },
      lineEnd: function lineEnd() {
        s1.lineEnd();
      },
      polygonStart: function polygonStart() {
        s1.polygonStart();
      },
      polygonEnd: function polygonEnd() {
        s1.polygonEnd();
      }
    });
    s0.sphere = s1.sphere;
    return s0;
  };

  function property(name) {
    gilbert[name] = function (_) {
      return arguments.length ? (projection[name](_), gilbert) : projection[name]();
    };
  }

  gilbert.rotate = function (_) {
    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();
  };

  gilbert.center = function (_) {
    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());
  };

  property("clipAngle");
  property("clipExtent");
  property("scale");
  property("translate");
  property("precision");
  return gilbert.scale(249.5);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/gingery.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/gingery.js ***!
  \*******************************************************/
/*! exports provided: gingeryRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gingeryRaw", function() { return gingeryRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function gingeryRaw(rho, n) {
  var k = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / n,
      rho2 = rho * rho;

  function forward(lambda, phi) {
    var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"])(lambda, phi),
        x = p[0],
        y = p[1],
        r2 = x * x + y * y;

    if (r2 > rho2) {
      var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(r2),
          theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])(theta / k),
          alpha = theta - theta0,
          rhoCosAlpha = rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(alpha),
          k_ = (rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(alpha) - alpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rhoCosAlpha)) / (_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rhoCosAlpha),
          s_ = gingeryLength(alpha, k_),
          e = (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] - rho) / gingeryIntegrate(s_, rhoCosAlpha, _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
      x = r;
      var i = 50,
          delta;

      do {
        x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e);
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

      y = alpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x);
      if (x < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) y -= k_ * (x - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]);
      var s = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta0),
          c = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta0);
      p[0] = x * c - y * s;
      p[1] = x * s + y * c;
    }

    return p;
  }

  forward.invert = function (x, y) {
    var r2 = x * x + y * y;

    if (r2 > rho2) {
      var r = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(r2),
          theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x),
          theta0 = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["round"])(theta / k),
          dTheta = theta - theta0;
      x = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(dTheta);
      y = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(dTheta);
      var x_halfPi = x - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
          sinx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(x),
          alpha = y / sinx,
          delta = x < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] ? Infinity : 0,
          i = 10;

      while (true) {
        var rhosinAlpha = rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(alpha),
            rhoCosAlpha = rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(alpha),
            sinRhoCosAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rhoCosAlpha),
            halfPi_RhoCosAlpha = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - rhoCosAlpha,
            k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha,
            s_ = gingeryLength(alpha, k_);
        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] || ! --i) break;
        alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rhoCosAlpha) - sinRhoCosAlpha) - rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));
      }

      r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] - rho) / gingeryIntegrate(s_, rhoCosAlpha, _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
      theta = theta0 + alpha;
      x = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta);
      y = r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta);
    }

    return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"].invert(x, y);
  };

  return forward;
}

function gingeryLength(alpha, k) {
  return function (x) {
    var y_ = alpha * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(x);
    if (x < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) y_ -= k;
    return Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + y_ * y_);
  };
} // Numerical integration: trapezoidal rule.


function gingeryIntegrate(f, a, b) {
  var n = 50,
      h = (b - a) / n,
      s = f(a) + f(b);

  for (var i = 1, x = a; i < n; ++i) {
    s += 2 * f(x += h);
  }

  return s * 0.5 * h;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var n = 6,
      rho = 30 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      cRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rho),
      sRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho),
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(gingeryRaw),
      p = m(rho, n),
      stream_ = p.stream,
      epsilon = 1e-2,
      cr = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]),
      sr = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(epsilon * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);

  p.radius = function (_) {
    if (!arguments.length) return rho * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    cRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rho = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    sRho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho);
    return m(rho, n);
  };

  p.lobes = function (_) {
    if (!arguments.length) return n;
    return m(rho, n = +_);
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart(), sphereStream.lineStart();

      for (var i = 0, delta = 2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / n, phi = 0; i < n; ++i, phi -= delta) {
        sphereStream.point(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), cr) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sr * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
        sphereStream.point(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sRho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi - delta / 2), cRho) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sRho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi - delta / 2)) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]);
      }

      sphereStream.lineEnd(), sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return p.rotate([90, -40]).scale(91.7095).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg4.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg4.js ***!
  \*********************************************************/
/*! exports provided: ginzburg4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg4Raw", function() { return ginzburg4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");


var ginzburg4Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg4Raw).scale(149.995);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg5.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg5.js ***!
  \*********************************************************/
/*! exports provided: ginzburg5Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg5Raw", function() { return ginzburg5Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");


var ginzburg5Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg5Raw).scale(153.93);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg6.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg6.js ***!
  \*********************************************************/
/*! exports provided: ginzburg6Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg6Raw", function() { return ginzburg6Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



var ginzburg6Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(5 / 6 * _math__WEBPACK_IMPORTED_MODULE_2__["pi"], -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg6Raw).scale(130.945);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg8.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg8.js ***!
  \*********************************************************/
/*! exports provided: ginzburg8Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg8Raw", function() { return ginzburg8Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function ginzburg8Raw(lambda, phi) {
  var lambda2 = lambda * lambda,
      phi2 = phi * phi;
  return [lambda * (1 - 0.162388 * phi2) * (0.87 - 0.000952426 * lambda2 * lambda2), phi * (1 + phi2 / 12)];
}

ginzburg8Raw.invert = function (x, y) {
  var lambda = x,
      phi = y,
      i = 50,
      delta;

  do {
    var phi2 = phi * phi;
    phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4);
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  i = 50;
  x /= 1 - 0.162388 * phi2;

  do {
    var lambda4 = (lambda4 = lambda * lambda) * lambda4;
    lambda -= delta = (lambda * (0.87 - 0.000952426 * lambda4) - x) / (0.87 - 0.00476213 * lambda4);
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg8Raw).scale(131.747);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburg9.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburg9.js ***!
  \*********************************************************/
/*! exports provided: ginzburg9Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ginzburg9Raw", function() { return ginzburg9Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ginzburgPolyconic */ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js");


var ginzburg9Raw = Object(_ginzburgPolyconic__WEBPACK_IMPORTED_MODULE_1__["default"])(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(ginzburg9Raw).scale(131.087);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/ginzburgPolyconic.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/ginzburgPolyconic.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b, c, d, e, f, g, h) {
  if (arguments.length < 8) h = 0;

  function forward(lambda, phi) {
    if (!phi) return [a * lambda / _math__WEBPACK_IMPORTED_MODULE_0__["pi"], 0];
    var phi2 = phi * phi,
        xB = a + phi2 * (b + phi2 * (c + phi2 * d)),
        yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)),
        m = (xB * xB + yB * yB) / (2 * yB),
        alpha = lambda * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(xB / m) / _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    return [m * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(alpha), phi * (1 + phi2 * h) + m * (1 - Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(alpha))];
  }

  forward.invert = function (x, y) {
    var lambda = _math__WEBPACK_IMPORTED_MODULE_0__["pi"] * x / a,
        phi = y,
        deltaLambda,
        deltaPhi,
        i = 50;

    do {
      var phi2 = phi * phi,
          xB = a + phi2 * (b + phi2 * (c + phi2 * d)),
          yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)),
          p = xB * xB + yB * yB,
          q = 2 * yB,
          m = p / q,
          m2 = m * m,
          dAlphadLambda = Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(xB / m) / _math__WEBPACK_IMPORTED_MODULE_0__["pi"],
          alpha = lambda * dAlphadLambda,
          xB2 = xB * xB,
          dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi,
          dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g),
          dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)),
          dqdPhi = 2 * (dyBdPhi - 1),
          dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q),
          cosAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(alpha),
          sinAlpha = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(alpha),
          mcosAlpha = m * cosAlpha,
          msinAlpha = m * sinAlpha,
          dAlphadPhi = lambda / _math__WEBPACK_IMPORTED_MODULE_0__["pi"] * (1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi) / m2,
          fx = msinAlpha - x,
          fy = phi * (1 + phi2 * h) + m - mcosAlpha - y,
          deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi,
          deltaxDeltaLambda = mcosAlpha * dAlphadLambda,
          deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi),
          deltayDeltaLambda = msinAlpha * dAlphadLambda,
          denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;
      if (!denominator) break;
      lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;
      phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    } while ((Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(deltaLambda) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(deltaPhi) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) && --i > 0);

    return [lambda, phi];
  };

  return forward;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/gringorten.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/gringorten.js ***!
  \**********************************************************/
/*! exports provided: gringortenRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gringortenRaw", function() { return gringortenRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./square */ "./node_modules/d3-geo-projection/src/square.js");



function gringortenRaw(lambda, phi) {
  var sLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda),
      sPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi),
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
      y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(sPhi * phi);
  lambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, z));
  phi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda %= _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
  var point = gringortenHexadecant(lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - lambda : lambda, phi);
  if (lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4) z = point[0], point[0] = -point[1], point[1] = -z;
  return point[0] *= sLambda, point[1] *= -sPhi, point;
}

gringortenRaw.invert = function (x, y) {
  var sx = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x),
      sy = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y),
      x0 = -sx * x,
      y0 = -sy * y,
      t = y0 / x0 < 1,
      p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0),
      lambda = p[0],
      phi = p[1],
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  if (t) lambda = -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - lambda;
  return [sx * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi, -Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)) + _math__WEBPACK_IMPORTED_MODULE_1__["pi"]), sy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi)];
};

function gringortenHexadecant(lambda, phi) {
  if (phi === _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) return [0, 0];
  var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      r = sinPhi * sinPhi,
      r2 = r * r,
      j = 1 + r2,
      k = 1 + 3 * r2,
      q = 1 - r2,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(j)),
      v = q + r * j * z,
      p2 = (1 - sinPhi) / v,
      p = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(p2),
      a2 = p2 * j,
      a = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2),
      h = p * q,
      x,
      i;
  if (lambda === 0) return [0, -(h + r * a)];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      secPhi = 1 / cosPhi,
      drdPhi = 2 * sinPhi * cosPhi,
      dvdPhi = (-3 * r + z * k) * drdPhi,
      dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v),
      dpdPhi = 0.5 * dp2dPhi / p,
      dhdPhi = q * dpdPhi - 2 * r * p * drdPhi,
      dra2dPhi = r * j * dp2dPhi + p2 * k * drdPhi,
      mu = -secPhi * drdPhi,
      nu = -secPhi * dra2dPhi,
      zeta = -2 * secPhi * dhdPhi,
      lambda1 = 4 * lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"],
      delta; // Slower but accurate bisection method.

  if (lambda > 0.222 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] || phi < _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4 && lambda > 0.175 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) {
    x = (h + r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 * (1 + r2) - h * h)) / (1 + r2);
    if (lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4) return [x, x];
    var x1 = x,
        x0 = 0.5 * x;
    x = 0.5 * (x0 + x1), i = 50;

    do {
      var g = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 - x * x),
          f = x * (zeta + mu * g) + nu * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / a) - lambda1;
      if (!f) break;
      if (f < 0) x0 = x;else x1 = x;
      x = 0.5 * (x0 + x1);
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1 - x0) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);
  } // Newton-Raphson.
  else {
      x = _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], i = 25;

      do {
        var x2 = x * x,
            g2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 - x2),
            zetaMug = zeta + mu * g2,
            f2 = x * zetaMug + nu * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / a) - lambda1,
            df = zetaMug + (nu - mu * x2) / g2;
        x -= delta = g2 ? f2 / df : 0;
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);
    }

  return [x, -h - r * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2 - x * x)];
}

function gringortenHexadecantInvert(x, y) {
  var x0 = 0,
      x1 = 1,
      r = 0.5,
      i = 50;

  while (true) {
    var r2 = r * r,
        sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(r),
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + r2)),
        v = 1 - r2 + r * (1 + r2) * z,
        p2 = (1 - sinPhi) / v,
        p = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(p2),
        a2 = p2 * (1 + r2),
        h = p * (1 - r2),
        g2 = a2 - x * x,
        g = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(g2),
        y0 = y + h + r * g;
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1 - x0) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] || --i === 0 || y0 === 0) break;
    if (y0 > 0) x0 = r;else x1 = r;
    r = 0.5 * (x0 + x1);
  }

  if (!i) return null;
  var phi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinPhi),
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      secPhi = 1 / cosPhi,
      drdPhi = 2 * sinPhi * cosPhi,
      dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi,
      dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v),
      dpdPhi = 0.5 * dp2dPhi / p,
      dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi,
      zeta = -2 * secPhi * dhdPhi,
      mu = -secPhi * drdPhi,
      nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);
  return [_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4 * (x * (zeta + mu * g) + nu * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a2))), phi];
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(Object(_square__WEBPACK_IMPORTED_MODULE_2__["default"])(gringortenRaw)).scale(239.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/guyou.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/guyou.js ***!
  \*****************************************************/
/*! exports provided: guyouRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "guyouRaw", function() { return guyouRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elliptic */ "./node_modules/d3-geo-projection/src/elliptic.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _square__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./square */ "./node_modules/d3-geo-projection/src/square.js");




function guyouRaw(lambda, phi) {
  var k_ = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] - 1) / (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] + 1),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(1 - k_ * k_),
      K = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticF"])(_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], k * k),
      f = -1,
      psi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["tan"])(_math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 4 + Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(phi) / 2)),
      r = Object(_math__WEBPACK_IMPORTED_MODULE_2__["exp"])(f * psi) / Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(k_),
      at = guyouComplexAtan(r * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(f * lambda), r * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(f * lambda)),
      t = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticFi"])(at[0], at[1], k * k);
  return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K - t[0])];
}

function guyouComplexAtan(x, y) {
  var x2 = x * x,
      y_1 = y + 1,
      t = 1 - x2 - y * y;
  return [0.5 * ((x >= 0 ? _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) - Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(t, 2 * x)), -0.25 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(t * t + 4 * x2) + 0.5 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(y_1 * y_1 + x2)];
}

function guyouComplexDivide(a, b) {
  var denominator = b[0] * b[0] + b[1] * b[1];
  return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
}

guyouRaw.invert = function (x, y) {
  var k_ = (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] - 1) / (_math__WEBPACK_IMPORTED_MODULE_2__["sqrt2"] + 1),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(1 - k_ * k_),
      K = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticF"])(_math__WEBPACK_IMPORTED_MODULE_2__["halfPi"], k * k),
      f = -1,
      j = Object(_elliptic__WEBPACK_IMPORTED_MODULE_1__["ellipticJi"])(0.5 * K - y, -x, k * k),
      tn = guyouComplexDivide(j[0], j[1]),
      lambda = Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(tn[1], tn[0]) / f;
  return [lambda, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_2__["exp"])(0.5 / f * Object(_math__WEBPACK_IMPORTED_MODULE_2__["log"])(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(Object(_square__WEBPACK_IMPORTED_MODULE_3__["default"])(guyouRaw)).scale(151.496);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/hammer.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/hammer.js ***!
  \******************************************************/
/*! exports provided: hammerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammerRaw", function() { return hammerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function hammerRaw(A, B) {
  if (arguments.length < 2) B = A;
  if (B === 1) return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEqualAreaRaw"];
  if (B === Infinity) return hammerQuarticAuthalicRaw;

  function forward(lambda, phi) {
    var coordinates = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEqualAreaRaw"])(lambda / B, phi);
    coordinates[0] *= A;
    return coordinates;
  }

  forward.invert = function (x, y) {
    var coordinates = d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEqualAreaRaw"].invert(x / A, y);
    coordinates[0] *= B;
    return coordinates;
  };

  return forward;
}

function hammerQuarticAuthalicRaw(lambda, phi) {
  return [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi /= 2), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
}

hammerQuarticAuthalicRaw.invert = function (x, y) {
  var phi = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y / 2);
  return [x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var B = 2,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(hammerRaw),
      p = m(B);

  p.coefficient = function (_) {
    if (!arguments.length) return B;
    return m(B = +_);
  };

  return p.scale(169.529);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/hammerRetroazimuthal.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/hammerRetroazimuthal.js ***!
  \********************************************************************/
/*! exports provided: hammerRetroazimuthalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hammerRetroazimuthalRaw", function() { return hammerRetroazimuthalRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function hammerRetroazimuthalRaw(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0),
      cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0),
      rotate = hammerRetroazimuthalRotation(phi0);
  rotate.invert = hammerRetroazimuthalRotation(-phi0);

  function forward(lambda, phi) {
    var p = rotate(lambda, phi);
    lambda = p[0], phi = p[1];
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda),
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda),
        sinz = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(z),
        K = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(sinz) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? z / sinz : 1;
    return [K * cosPhi0 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] ? K : -K) * ( // rotate for back hemisphere
    sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)];
  }

  forward.invert = function (x, y) {
    var rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y),
        sinz = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(rho),
        cosz = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(rho),
        a = rho * cosz,
        b = -y * sinz,
        c = rho * sinPhi0,
        d = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b - c * c),
        phi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(a * c + b * d, b * c - a * d),
        lambda = (rho > _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * sinz, rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * cosz + y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) * sinz);
    return rotate.invert(lambda, phi);
  };

  return forward;
} // Latitudinal rotation by phi0.
// Temporary hack until D3 supports arbitrary small-circle clipping origins.

function hammerRetroazimuthalRotation(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0),
      cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0);
  return function (lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y, x * cosPhi0 - z * sinPhi0), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(z * cosPhi0 + x * sinPhi0)];
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var phi0 = 0,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(hammerRetroazimuthalRaw),
      p = m(phi0),
      rotate_ = p.rotate,
      stream_ = p.stream,
      circle = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCircle"])();

  p.parallel = function (_) {
    if (!arguments.length) return phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    var r = p.rotate();
    return m(phi0 = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]).rotate(r);
  }; // Temporary hack; see hammerRetroazimuthalRotation.


  p.rotate = function (_) {
    if (!arguments.length) return _ = rotate_.call(p), _[1] += phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], _;
    rotate_.call(p, [_[0], _[1] - phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]]);
    circle.center([-_[0], -_[1]]);
    return p;
  };

  p.stream = function (stream) {
    stream = stream_(stream);

    stream.sphere = function () {
      stream.polygonStart();
      var epsilon = 1e-2,
          ring = circle.radius(90 - epsilon)().coordinates[0],
          n = ring.length - 1,
          i = -1,
          p;
      stream.lineStart();

      while (++i < n) {
        stream.point((p = ring[i])[0], p[1]);
      }

      stream.lineEnd();
      ring = circle.radius(90 + epsilon)().coordinates[0];
      n = ring.length - 1;
      stream.lineStart();

      while (--i >= 0) {
        stream.point((p = ring[i])[0], p[1]);
      }

      stream.lineEnd();
      stream.polygonEnd();
    };

    return stream;
  };

  return p.scale(79.4187).parallel(45).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/healpix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/healpix.js ***!
  \*******************************************************/
/*! exports provided: healpixRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "healpixRaw", function() { return healpixRaw; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _collignon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collignon */ "./node_modules/d3-geo-projection/src/collignon.js");
/* harmony import */ var _cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cylindricalEqualArea */ "./node_modules/d3-geo-projection/src/cylindricalEqualArea.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");





var healpixParallel = 41 + 48 / 36 + 37 / 3600,
    // for K=3; TODO automate
healpixLambert = Object(_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_3__["cylindricalEqualAreaRaw"])(0);
function healpixRaw(H) {
  var phi0 = healpixParallel * _math__WEBPACK_IMPORTED_MODULE_4__["radians"],
      dx = Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(_math__WEBPACK_IMPORTED_MODULE_4__["pi"], phi0)[0] - Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(-_math__WEBPACK_IMPORTED_MODULE_4__["pi"], phi0)[0],
      y0 = healpixLambert(0, phi0)[1],
      y1 = Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(0, phi0)[1],
      dy1 = _math__WEBPACK_IMPORTED_MODULE_4__["sqrtPi"] - y1,
      k = _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / H,
      w = 4 / _math__WEBPACK_IMPORTED_MODULE_4__["tau"],
      h = y0 + dy1 * dy1 * 4 / _math__WEBPACK_IMPORTED_MODULE_4__["tau"];

  function forward(lambda, phi) {
    var point,
        phi2 = Object(_math__WEBPACK_IMPORTED_MODULE_4__["abs"])(phi);

    if (phi2 > phi0) {
      var i = Object(_math__WEBPACK_IMPORTED_MODULE_4__["min"])(H - 1, Object(_math__WEBPACK_IMPORTED_MODULE_4__["max"])(0, Object(_math__WEBPACK_IMPORTED_MODULE_4__["floor"])((lambda + _math__WEBPACK_IMPORTED_MODULE_4__["pi"]) / k)));
      lambda += _math__WEBPACK_IMPORTED_MODULE_4__["pi"] * (H - 1) / H - i * k;
      point = Object(_collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"])(lambda, phi2);
      point[0] = point[0] * _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / dx - _math__WEBPACK_IMPORTED_MODULE_4__["tau"] * (H - 1) / (2 * H) + i * _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / H;
      point[1] = y0 + (point[1] - y1) * 4 * dy1 / _math__WEBPACK_IMPORTED_MODULE_4__["tau"];
      if (phi < 0) point[1] = -point[1];
    } else {
      point = healpixLambert(lambda, phi);
    }

    point[0] *= w, point[1] /= h;
    return point;
  }

  forward.invert = function (x, y) {
    x /= w, y *= h;
    var y2 = Object(_math__WEBPACK_IMPORTED_MODULE_4__["abs"])(y);

    if (y2 > y0) {
      var i = Object(_math__WEBPACK_IMPORTED_MODULE_4__["min"])(H - 1, Object(_math__WEBPACK_IMPORTED_MODULE_4__["max"])(0, Object(_math__WEBPACK_IMPORTED_MODULE_4__["floor"])((x + _math__WEBPACK_IMPORTED_MODULE_4__["pi"]) / k)));
      x = (x + _math__WEBPACK_IMPORTED_MODULE_4__["pi"] * (H - 1) / H - i * k) * dx / _math__WEBPACK_IMPORTED_MODULE_4__["tau"];
      var point = _collignon__WEBPACK_IMPORTED_MODULE_2__["collignonRaw"].invert(x, 0.25 * (y2 - y0) * _math__WEBPACK_IMPORTED_MODULE_4__["tau"] / dy1 + y1);
      point[0] -= _math__WEBPACK_IMPORTED_MODULE_4__["pi"] * (H - 1) / H - i * k;
      if (y < 0) point[1] = -point[1];
      return point;
    }

    return healpixLambert.invert(x, y);
  };

  return forward;
}

function sphere(step) {
  return {
    type: "Polygon",
    coordinates: [Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(-180, 180 + step / 2, step).map(function (x, i) {
      return [x, i & 1 ? 90 - 1e-6 : healpixParallel];
    }).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(180, -180 - step / 2, -step).map(function (x, i) {
      return [x, i & 1 ? -90 + 1e-6 : -healpixParallel];
    }))]
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var H = 4,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoProjectionMutator"])(healpixRaw),
      p = m(H),
      stream_ = p.stream;

  p.lobes = function (_) {
    return arguments.length ? m(H = +_) : H;
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoStream"])(sphere(180 / H), sphereStream);
    };

    return rotateStream;
  };

  return p.scale(239.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/hill.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/hill.js ***!
  \****************************************************/
/*! exports provided: hillRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hillRaw", function() { return hillRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function hillRaw(K) {
  var L = 1 + K,
      sinBt = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(1 / L),
      Bt = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinBt),
      A = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / (B = _math__WEBPACK_IMPORTED_MODULE_1__["pi"] + 4 * Bt * L)),
      B,
      rho0 = 0.5 * A * (L + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(K * (2 + K))),
      K2 = K * K,
      L2 = L * L;

  function forward(lambda, phi) {
    var t = 1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        rho,
        omega;

    if (t && t < 2) {
      var theta = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] - phi,
          i = 25,
          delta;

      do {
        var sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta),
            cosTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta),
            Bt_Bt1 = Bt + Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sinTheta, L - cosTheta),
            C = 1 + L2 - 2 * L * cosTheta;
        theta -= delta = (theta - K2 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B) / (2 * L * sinTheta * Bt_Bt1);
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] && --i > 0);

      rho = A * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(C);
      omega = lambda * Bt_Bt1 / _math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    } else {
      rho = A * (K + t);
      omega = lambda * Bt / _math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    }

    return [rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(omega), rho0 - rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(omega)];
  }

  forward.invert = function (x, y) {
    var rho2 = x * x + (y -= rho0) * y,
        cosTheta = (1 + L2 - rho2 / (A * A)) / (2 * L),
        theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosTheta),
        sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta),
        Bt_Bt1 = Bt + Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(sinTheta, L - cosTheta);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(rho2)) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / Bt_Bt1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(1 - 2 * (theta - K2 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B)];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var K = 1,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(hillRaw),
      p = m(K);

  p.ratio = function (_) {
    return arguments.length ? m(K = +_) : K;
  };

  return p.scale(167.774).center([0, 18.67]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/homolosine.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/homolosine.js ***!
  \**********************************************************/
/*! exports provided: homolosineRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "homolosineRaw", function() { return homolosineRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");
/* harmony import */ var _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sinuMollweide */ "./node_modules/d3-geo-projection/src/sinuMollweide.js");





function homolosineRaw(lambda, phi) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) > _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweidePhi"] ? (lambda = Object(_mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideRaw"])(lambda, phi), lambda[1] -= phi > 0 ? _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"] : -_sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"], lambda) : Object(_sinusoidal__WEBPACK_IMPORTED_MODULE_3__["sinusoidalRaw"])(lambda, phi);
}

homolosineRaw.invert = function (x, y) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) > _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweidePhi"] ? _mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideRaw"].invert(x, y + (y > 0 ? _sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"] : -_sinuMollweide__WEBPACK_IMPORTED_MODULE_4__["sinuMollweideY"])) : _sinusoidal__WEBPACK_IMPORTED_MODULE_3__["sinusoidalRaw"].invert(x, y);
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(homolosineRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/boggs.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/boggs.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _boggs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../boggs */ "./node_modules/d3-geo-projection/src/boggs.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-100, 90], [-40, 0]], [[-40, 0], [30, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-160, -90], [-100, 0]], [[-100, 0], [-60, -90], [-20, 0]], [[-20, 0], [20, -90], [80, 0]], [[80, 0], [140, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_boggs__WEBPACK_IMPORTED_MODULE_0__["boggsRaw"], lobes).scale(160.857);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/homolosine.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/homolosine.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _homolosine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../homolosine */ "./node_modules/d3-geo-projection/src/homolosine.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-100, 90], [-40, 0]], [[-40, 0], [30, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-160, -90], [-100, 0]], [[-100, 0], [-60, -90], [-20, 0]], [[-20, 0], [20, -90], [80, 0]], [[80, 0], [140, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_homolosine__WEBPACK_IMPORTED_MODULE_0__["homolosineRaw"], lobes).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/index.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");




function pointEqual(a, b) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(a[0] - b[0]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(a[1] - b[1]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
}

function interpolateLine(coordinates, m) {
  var i = -1,
      n = coordinates.length,
      p0 = coordinates[0],
      p1,
      dx,
      dy,
      resampled = [];

  while (++i < n) {
    p1 = coordinates[i];
    dx = (p1[0] - p0[0]) / m;
    dy = (p1[1] - p0[1]) / m;

    for (var j = 0; j < m; ++j) {
      resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
    }

    p0 = p1;
  }

  resampled.push(p1);
  return resampled;
}

function interpolateSphere(lobes) {
  var coordinates = [],
      lobe,
      lambda0,
      phi0,
      phi1,
      lambda2,
      phi2,
      i,
      n = lobes[0].length; // Northern Hemisphere

  for (i = 0; i < n; ++i) {
    lobe = lobes[0][i];
    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];
    lambda2 = lobe[2][0], phi2 = lobe[2][1];
    coordinates.push(interpolateLine([[lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi2 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]]], 30));
  } // Southern Hemisphere


  for (i = lobes[1].length - 1; i >= 0; --i) {
    lobe = lobes[1][i];
    lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];
    lambda2 = lobe[2][0], phi2 = lobe[2][1];
    coordinates.push(interpolateLine([[lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda2 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi1 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]], [lambda0 + _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"], phi0 - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]]], 30));
  }

  return {
    type: "Polygon",
    coordinates: [Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["merge"])(coordinates)]
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (project, lobes) {
  var sphere = interpolateSphere(lobes);
  lobes = lobes.map(function (lobe) {
    return lobe.map(function (l) {
      return [[l[0][0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], l[0][1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]], [l[1][0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], l[1][1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]], [l[2][0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], l[2][1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"]]];
    });
  });
  var bounds = lobes.map(function (lobe) {
    return lobe.map(function (l) {
      var x0 = project(l[0][0], l[0][1])[0],
          x1 = project(l[2][0], l[2][1])[0],
          y0 = project(l[1][0], l[0][1])[1],
          y1 = project(l[1][0], l[1][1])[1],
          t;
      if (y0 > y1) t = y0, y0 = y1, y1 = t;
      return [[x0, y0], [x1, y1]];
    });
  });
  var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoProjection"])(forward),
      stream_ = p.stream;

  function forward(lambda, phi) {
    var sign = phi < 0 ? -1 : +1,
        lobe = lobes[+(phi < 0)];

    for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i) {
      ;
    }

    var p = project(lambda - lobe[i][1][0], phi);
    p[0] += project(lobe[i][1][0], sign * phi > sign * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];
    return p;
  } // Assumes mutually exclusive bounding boxes for lobes.


  if (project.invert) forward.invert = function (x, y) {
    var bound = bounds[+(y < 0)],
        lobe = lobes[+(y < 0)];

    for (var i = 0, n = bound.length; i < n; ++i) {
      var b = bound[i];

      if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
        var p = project.invert(x - project(lobe[i][1][0], 0)[0], y);
        p[0] += lobe[i][1][0];
        return pointEqual(forward(p[0], p[1]), [x, y]) ? p : null;
      }
    }
  };

  p.stream = function (stream) {
    var rotate = p.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (p.rotate([0, 0]), stream_(stream));
    p.rotate(rotate);

    rotateStream.sphere = function () {
      Object(d3_geo__WEBPACK_IMPORTED_MODULE_1__["geoStream"])(sphere, sphereStream);
    };

    return rotateStream;
  };

  return p;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/mollweide.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/mollweide.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-100, 90], [-40, 0]], [[-40, 0], [30, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-160, -90], [-100, 0]], [[-100, 0], [-60, -90], [-20, 0]], [[-20, 0], [20, -90], [80, 0]], [[80, 0], [140, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_mollweide__WEBPACK_IMPORTED_MODULE_0__["mollweideRaw"], lobes).scale(169.529);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js":
/*!********************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/mollweideHemispheres.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-90, 90], [0, 0]], [[0, 0], [90, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-90, -90], [0, 0]], [[0, 0], [90, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_mollweide__WEBPACK_IMPORTED_MODULE_0__["mollweideRaw"], lobes).scale(169.529).rotate([20, 0]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js":
/*!*************************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/sinuMollweide.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sinuMollweide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sinuMollweide */ "./node_modules/d3-geo-projection/src/sinuMollweide.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 35], [-30, 90], [0, 35]], [[0, 35], [30, 90], [180, 35]]], [// southern hemisphere
[[-180, -10], [-102, -90], [-65, -10]], [[-65, -10], [5, -90], [77, -10]], [[77, -10], [103, -90], [180, -10]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_sinuMollweide__WEBPACK_IMPORTED_MODULE_0__["sinuMollweideRaw"], lobes).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/interrupted/sinusoidal.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/interrupted/sinusoidal.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/interrupted/index.js");


var lobes = [[// northern hemisphere
[[-180, 0], [-110, 90], [-40, 0]], [[-40, 0], [0, 90], [40, 0]], [[40, 0], [110, 90], [180, 0]]], [// southern hemisphere
[[-180, 0], [-110, -90], [-40, 0]], [[-40, 0], [0, -90], [40, 0]], [[40, 0], [110, -90], [180, 0]]]];
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_sinusoidal__WEBPACK_IMPORTED_MODULE_0__["sinusoidalRaw"], lobes).scale(152.63).rotate([-20, 0]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/kavrayskiy7.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/kavrayskiy7.js ***!
  \***********************************************************/
/*! exports provided: kavrayskiy7Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "kavrayskiy7Raw", function() { return kavrayskiy7Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function kavrayskiy7Raw(lambda, phi) {
  return [3 / _math__WEBPACK_IMPORTED_MODULE_1__["tau"] * lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3 - phi * phi), phi];
}

kavrayskiy7Raw.invert = function (x, y) {
  return [_math__WEBPACK_IMPORTED_MODULE_1__["tau"] / 3 * x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3 - y * y), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(kavrayskiy7Raw).scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/lagrange.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/lagrange.js ***!
  \********************************************************/
/*! exports provided: lagrangeRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lagrangeRaw", function() { return lagrangeRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function lagrangeRaw(n) {
  function forward(lambda, phi) {
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, phi < 0 ? -2 : 2];
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        v = Object(_math__WEBPACK_IMPORTED_MODULE_1__["pow"])((1 + sinPhi) / (1 - sinPhi), n / 2),
        c = 0.5 * (v + 1 / v) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda *= n);
    return [2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) / c, (v - 1 / v) / c];
  }

  forward.invert = function (x, y) {
    var y0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y);
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y0 - 2) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return x ? null : [0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]];
    if (y0 > 2) return null;
    x /= 2, y /= 2;
    var x2 = x * x,
        y2 = y * y,
        t = 2 * y / (1 + x2 + y2); // tanh(nPhi)

    t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["pow"])((1 + t) / (1 - t), 1 / n);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(2 * x, 1 - x2 - y2) / n, Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((t - 1) / (t + 1))];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var n = 0.5,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(lagrangeRaw),
      p = m(n);

  p.spacing = function (_) {
    return arguments.length ? m(n = +_) : n;
  };

  return p.scale(124.75);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/larrivee.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/larrivee.js ***!
  \********************************************************/
/*! exports provided: larriveeRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "larriveeRaw", function() { return larriveeRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var pi_sqrt2 = _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"];
function larriveeRaw(lambda, phi) {
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi))) / 2, phi / (Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda / 6))];
}

larriveeRaw.invert = function (x, y) {
  var x0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x),
      y0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y),
      lambda = _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"],
      phi = _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
  if (y0 < pi_sqrt2) phi *= y0 / pi_sqrt2;else lambda += 6 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(pi_sqrt2 / y0);

  for (var i = 0; i < 25; i++) {
    var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        sqrtcosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)),
        sinPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi / 2),
        cosPhi_2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi / 2),
        sinLambda_6 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda / 6),
        cosLambda_6 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda / 6),
        f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x0,
        f1 = phi / (cosPhi_2 * cosLambda_6) - y0,
        df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0,
        df0dLambda = 0.5 * (1 + sqrtcosPhi),
        df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6),
        df1dLambda = phi / cosPhi_2 * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6),
        denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda,
        dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom,
        dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;
    phi -= dPhi;
    lambda -= dLambda;
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dPhi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(dLambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) break;
  }

  return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(larriveeRaw).scale(97.2672);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/laskowski.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/laskowski.js ***!
  \*********************************************************/
/*! exports provided: laskowskiRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "laskowskiRaw", function() { return laskowskiRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function laskowskiRaw(lambda, phi) {
  var lambda2 = lambda * lambda,
      phi2 = phi * phi;
  return [lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)), phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032))];
}

laskowskiRaw.invert = function (x, y) {
  var lambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"],
      phi = y / 2,
      i = 50;

  do {
    var lambda2 = lambda * lambda,
        phi2 = phi * phi,
        lambdaPhi = lambda * phi,
        fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x,
        fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y,
        deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009),
        deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2),
        deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 0.000199025 * lambda2 + 2 * -0.02855 * phi2),
        deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 0.000199025 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2),
        denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda,
        deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator,
        deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;
    lambda -= deltaLambda, phi -= deltaPhi;
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltaLambda) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltaPhi) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) && --i > 0);

  return i && [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(laskowskiRaw).scale(139.98);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/littrow.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/littrow.js ***!
  \*******************************************************/
/*! exports provided: littrowRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "littrowRaw", function() { return littrowRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function littrowRaw(lambda, phi) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda)];
}

littrowRaw.invert = function (x, y) {
  var x2 = x * x,
      y2 = y * y,
      y2_1 = y2 + 1,
      cosPhi = x ? _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((y2_1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1) : 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(y2_1);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x * cosPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(cosPhi)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(littrowRaw).scale(144.049).clipAngle(90 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/loximuthal.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/loximuthal.js ***!
  \**********************************************************/
/*! exports provided: loximuthalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loximuthalRaw", function() { return loximuthalRaw; });
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function loximuthalRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0),
      tanPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi0 / 2);

  function forward(lambda, phi) {
    var y = phi - phi0,
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? lambda * cosPhi0 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x = _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi / 2) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? 0 : lambda * y / Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(x) / tanPhi0);
    return [x, y];
  }

  forward.invert = function (x, y) {
    var lambda,
        phi = y + phi0;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? x / cosPhi0 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda = _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + phi / 2) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? 0 : x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(lambda) / tanPhi0) / y, phi];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_0__["default"])(loximuthalRaw).parallel(40).scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/*! exports provided: abs, atan, atan2, ceil, cos, exp, floor, log, max, min, pow, round, sign, sin, tan, epsilon, epsilon2, pi, halfPi, quarterPi, sqrt1_2, sqrt2, sqrtPi, tau, degrees, radians, sinci, asin, acos, sqrt, tanh, sinh, cosh, arsinh, arcosh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quarterPi", function() { return quarterPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt1_2", function() { return sqrt1_2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt2", function() { return sqrt2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrtPi", function() { return sqrtPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinci", function() { return sinci; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tanh", function() { return tanh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinh", function() { return sinh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cosh", function() { return cosh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arsinh", function() { return arsinh; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arcosh", function() { return arcosh; });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sin = Math.sin;
var tan = Math.tan;
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}
function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}
function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}
function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}
function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}
function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/miller.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/miller.js ***!
  \******************************************************/
/*! exports provided: millerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "millerRaw", function() { return millerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function millerRaw(lambda, phi) {
  return [lambda, 1.25 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] + 0.4 * phi))];
}

millerRaw.invert = function (x, y) {
  return [x, 2.5 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["exp"])(0.8 * y)) - 0.625 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(millerRaw).scale(108.318);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/modifiedStereographic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/modifiedStereographic.js ***!
  \*********************************************************************/
/*! exports provided: modifiedStereographicRaw, modifiedStereographicAlaska, modifiedStereographicGs48, modifiedStereographicGs50, modifiedStereographicMiller, modifiedStereographicLee, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicRaw", function() { return modifiedStereographicRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicAlaska", function() { return modifiedStereographicAlaska; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicGs48", function() { return modifiedStereographicGs48; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicGs50", function() { return modifiedStereographicGs50; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicMiller", function() { return modifiedStereographicMiller; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modifiedStereographicLee", function() { return modifiedStereographicLee; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return modifiedStereographic; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function modifiedStereographicRaw(C) {
  var m = C.length - 1;

  function forward(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        k = 2 / (1 + cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda)),
        zr = k * cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda),
        zi = k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        i = m,
        w = C[i],
        ar = w[0],
        ai = w[1],
        t;

    while (--i >= 0) {
      w = C[i];
      ar = w[0] + zr * (t = ar) - zi * ai;
      ai = w[1] + zr * ai + zi * t;
    }

    ar = zr * (t = ar) - zi * ai;
    ai = zr * ai + zi * t;
    return [ar, ai];
  }

  forward.invert = function (x, y) {
    var i = 20,
        zr = x,
        zi = y;

    do {
      var j = m,
          w = C[j],
          ar = w[0],
          ai = w[1],
          br = 0,
          bi = 0,
          t;

      while (--j >= 0) {
        w = C[j];
        br = ar + zr * (t = br) - zi * bi;
        bi = ai + zr * bi + zi * t;
        ar = w[0] + zr * (t = ar) - zi * ai;
        ai = w[1] + zr * ai + zi * t;
      }

      br = ar + zr * (t = br) - zi * bi;
      bi = ai + zr * bi + zi * t;
      ar = zr * (t = ar) - zi * ai - x;
      ai = zr * ai + zi * t - y;
      var denominator = br * br + bi * bi,
          deltar,
          deltai;
      zr -= deltar = (ar * br + ai * bi) / denominator;
      zi -= deltai = (ai * br - ar * bi) / denominator;
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltar) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(deltai) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

    if (i) {
      var rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(zr * zr + zi * zi),
          c = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(rho * 0.5),
          sinc = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(c);
      return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(zr * sinc, rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(c)), rho ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(zi * sinc / rho) : 0];
    }
  };

  return forward;
}
var alaska = [[0.9972523, 0], [0.0052513, -0.0041175], [0.0074606, 0.0048125], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]],
    gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]],
    gs50 = [[0.9842990, 0], [0.0211642, 0.0037608], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.0260460, 0.0899805], [0.0007388, -0.1435792], [0.0075848, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]],
    miller = [[0.9245, 0], [0, 0], [0.01943, 0]],
    lee = [[0.721316, 0], [0, 0], [-0.00881625, -0.00617325]];
function modifiedStereographicAlaska() {
  return modifiedStereographic(alaska, [152, -64]).scale(1500).center([-160.908, 62.4864]).clipAngle(25);
}
function modifiedStereographicGs48() {
  return modifiedStereographic(gs48, [95, -38]).scale(1000).clipAngle(55).center([-96.5563, 38.8675]);
}
function modifiedStereographicGs50() {
  return modifiedStereographic(gs50, [120, -45]).scale(359.513).clipAngle(55).center([-117.474, 53.0628]);
}
function modifiedStereographicMiller() {
  return modifiedStereographic(miller, [-20, -18]).scale(209.091).center([20, 16.7214]).clipAngle(82);
}
function modifiedStereographicLee() {
  return modifiedStereographic(lee, [165, 10]).scale(250).clipAngle(130).center([-165, -10]);
}
function modifiedStereographic(coefficients, rotate) {
  var p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90),
      r = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])(rotate),
      center = p.center;
  delete p.rotate;

  p.center = function (_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };

  return p;
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mollweide.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mollweide.js ***!
  \*********************************************************/
/*! exports provided: mollweideBromleyTheta, mollweideBromleyRaw, mollweideRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mollweideBromleyTheta", function() { return mollweideBromleyTheta; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mollweideBromleyRaw", function() { return mollweideBromleyRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mollweideRaw", function() { return mollweideRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      i = 30,
      delta;

  do {
    phi -= delta = (phi + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) - cpsinPhi) / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return phi / 2;
}
function mollweideBromleyRaw(cx, cy, cp) {
  function forward(lambda, phi) {
    return [cx * lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi = mollweideBromleyTheta(cp, phi)), cy * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
  }

  forward.invert = function (x, y) {
    return y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y / cy), [x / (cx * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((2 * y + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * y)) / cp)];
  };

  return forward;
}
var mollweideRaw = mollweideBromleyRaw(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"], _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"], _math__WEBPACK_IMPORTED_MODULE_1__["pi"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mollweideRaw).scale(169.529);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mtFlatPolarParabolic.js ***!
  \********************************************************************/
/*! exports provided: mtFlatPolarParabolicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtFlatPolarParabolicRaw", function() { return mtFlatPolarParabolicRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var sqrt6 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6),
    sqrt7 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(7);
function mtFlatPolarParabolicRaw(lambda, phi) {
  var theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(7 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi) / (3 * sqrt6));
  return [sqrt6 * lambda * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * theta / 3) - 1) / sqrt7, 9 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta / 3) / sqrt7];
}

mtFlatPolarParabolicRaw.invert = function (x, y) {
  var theta = 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * sqrt7 / 9);
  return [x * sqrt7 / (sqrt6 * (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(2 * theta / 3) - 1)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta) * 3 * sqrt6 / 7)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mtFlatPolarParabolicRaw).scale(164.859);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mtFlatPolarQuartic.js ***!
  \******************************************************************/
/*! exports provided: mtFlatPolarQuarticRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtFlatPolarQuarticRaw", function() { return mtFlatPolarQuarticRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function mtFlatPolarQuarticRaw(lambda, phi) {
  var k = (1 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      theta = phi;

  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta / 2) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta) - k) / (0.5 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta / 2) + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta));
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) break;
  }

  return [lambda * (1 + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta / 2)) / (3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"]), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta / 2) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"])];
}

mtFlatPolarQuarticRaw.invert = function (x, y) {
  var sinTheta_2 = y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"]) / (2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3)),
      theta = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta_2);
  return [3 * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt2"] * x / (1 + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta / 2)), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((sinTheta_2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta)) / (1 + _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"]))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mtFlatPolarQuarticRaw).scale(188.209);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mtFlatPolarSinusoidal.js ***!
  \*********************************************************************/
/*! exports provided: mtFlatPolarSinusoidalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mtFlatPolarSinusoidalRaw", function() { return mtFlatPolarSinusoidalRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function mtFlatPolarSinusoidalRaw(lambda, phi) {
  var A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 / (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])),
      k = (1 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      theta = phi / 2;

  for (var i = 0, delta; i < 25; i++) {
    theta -= delta = (theta / 2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta) - k) / (0.5 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta));
    if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) break;
  }

  return [A * (0.5 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta)) * lambda / 1.5, A * theta];
}

mtFlatPolarSinusoidalRaw.invert = function (x, y) {
  var A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(6 / (4 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"])),
      theta = y / A;
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(theta) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) theta = theta < 0 ? -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
  return [1.5 * x / (A * (0.5 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta))), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])((theta / 2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(theta)) / (1 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(mtFlatPolarSinusoidalRaw).scale(166.518);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/naturalEarth.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/naturalEarth.js ***!
  \************************************************************/
/*! exports provided: naturalEarthRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "naturalEarthRaw", function() { return naturalEarthRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function naturalEarthRaw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2;
  return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))];
}

naturalEarthRaw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta;

  do {
    var phi2 = phi * phi,
        phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(naturalEarthRaw).scale(175.295);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/nellHammer.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/nellHammer.js ***!
  \**********************************************************/
/*! exports provided: nellHammerRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nellHammerRaw", function() { return nellHammerRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function nellHammerRaw(lambda, phi) {
  return [lambda * (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi)) / 2, 2 * (phi - Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2))];
}

nellHammerRaw.invert = function (x, y) {
  var p = y / 2;

  for (var i = 0, delta = Infinity; i < 10 && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; ++i) {
    var c = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y / 2);
    y -= delta = (y - Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(y / 2) - p) / (1 - 0.5 / (c * c));
  }

  return [2 * x / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y)), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(nellHammerRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/noop.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/noop.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/parallel1.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/parallel1.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = (function (projectAt) {
  var phi0 = 0,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(projectAt),
      p = m(phi0);

  p.parallel = function (_) {
    return arguments.length ? m(phi0 = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) : phi0 * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
  };

  return p;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/patterson.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/patterson.js ***!
  \*********************************************************/
/*! exports provided: pattersonRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pattersonRaw", function() { return pattersonRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

 // Based on Java implementation by Bojan Savric.
// https://github.com/OSUCartography/JMapProjLib/blob/master/src/com/jhlabs/map/proj/PattersonProjection.java

var pattersonK1 = 1.0148,
    pattersonK2 = 0.23185,
    pattersonK3 = -0.14499,
    pattersonK4 = 0.02406,
    pattersonC1 = pattersonK1,
    pattersonC2 = 5 * pattersonK2,
    pattersonC3 = 7 * pattersonK3,
    pattersonC4 = 9 * pattersonK4,
    pattersonYmax = 1.790857183;
function pattersonRaw(lambda, phi) {
  var phi2 = phi * phi;
  return [lambda, phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))];
}

pattersonRaw.invert = function (x, y) {
  if (y > pattersonYmax) y = pattersonYmax;else if (y < -pattersonYmax) y = -pattersonYmax;
  var yc = y,
      delta;

  do {
    // Newton-Raphson
    var y2 = yc * yc;
    yc -= delta = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]);

  return [x, yc];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(pattersonRaw).scale(139.319);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyconic.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyconic.js ***!
  \*********************************************************/
/*! exports provided: polyconicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polyconicRaw", function() { return polyconicRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function polyconicRaw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi),
      k = lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(k) / tanPhi, phi + (1 - Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(k)) / tanPhi];
}

polyconicRaw.invert = function (x, y) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [x, 0];
  var k = x * x + y * y,
      phi = y * 0.5,
      i = 10,
      delta;

  do {
    var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi),
        secPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        j = k - 2 * y * phi + phi * phi;
    phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
  } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi);
  return [(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi + 1 / tanPhi) ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(x * tanPhi) : Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x * tanPhi)) + _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"])) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi), phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(polyconicRaw).scale(103.74);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/butterfly.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/butterfly.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony import */ var _octahedron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./octahedron */ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js");




/* harmony default export */ __webpack_exports__["default"] = (function (faceProjection) {
  faceProjection = faceProjection || function (face) {
    var c = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
      type: "MultiPoint",
      coordinates: face
    });
    return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonic"])().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
  };

  var faces = _octahedron__WEBPACK_IMPORTED_MODULE_3__["default"].map(function (face) {
    return {
      face: face,
      project: faceProjection(face)
    };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {
    var node = faces[d];
    node && (node.children || (node.children = [])).push(faces[i]);
  });
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(faces[0], function (lambda, phi) {
    return faces[lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
  }).scale(101.858).center([0, 45]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/collignon.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/collignon.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _collignon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../collignon */ "./node_modules/d3-geo-projection/src/collignon.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony import */ var _octahedron__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./octahedron */ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js");





var kx = 2 / Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(3);

function collignonK(a, b) {
  var p = Object(_collignon__WEBPACK_IMPORTED_MODULE_1__["collignonRaw"])(a, b);
  return [p[0] * kx, p[1]];
}

collignonK.invert = function (x, y) {
  return _collignon__WEBPACK_IMPORTED_MODULE_1__["collignonRaw"].invert(x / kx, y);
};

/* harmony default export */ __webpack_exports__["default"] = (function (faceProjection) {
  faceProjection = faceProjection || function (face) {
    var c = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
      type: "MultiPoint",
      coordinates: face
    });
    return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);
  };

  var faces = _octahedron__WEBPACK_IMPORTED_MODULE_4__["default"].map(function (face) {
    return {
      face: face,
      project: faceProjection(face)
    };
  });
  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {
    var node = faces[d];
    node && (node.children || (node.children = [])).push(faces[i]);
  });
  return Object(_index__WEBPACK_IMPORTED_MODULE_3__["default"])(faces[0], function (lambda, phi) {
    return faces[lambda < -_math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math__WEBPACK_IMPORTED_MODULE_2__["pi"] / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];
  }).scale(121.906).center([0, 48.5904]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/index.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix */ "./node_modules/d3-geo-projection/src/polyhedral/matrix.js");


 // Creates a polyhedral projection.
//  * root: a spanning tree of polygon faces.  Nodes are automatically
//    augmented with a transform matrix.
//  * face: a function that returns the appropriate node for a given {lambda, phi}
//    point (radians).
//  * r: rotation angle for final polyhedral net.  Defaults to -pi / 6 (for
//    butterflies).

/* harmony default export */ __webpack_exports__["default"] = (function (root, face, r) {
  r = r == null ? -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 6 : r; // TODO automate

  recurse(root, {
    transform: [Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(r), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(r), 0, -Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(r), Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(r), 0]
  });

  function recurse(node, parent) {
    node.edges = faceEdges(node.face);

    if (parent) {
      // Find shared edge.
      if (parent.face) {
        var shared = node.shared = sharedEdge(node.face, parent.face),
            m = Object(_matrix__WEBPACK_IMPORTED_MODULE_2__["default"])(shared.map(parent.project), shared.map(node.project));
        node.transform = parent.transform ? Object(_matrix__WEBPACK_IMPORTED_MODULE_2__["multiply"])(parent.transform, m) : m; // Replace shared edge in parent edges array.

        var edges = parent.edges;

        for (var i = 0, n = edges.length; i < n; ++i) {
          if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = node;
          if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = node;
        }

        edges = node.edges;

        for (i = 0, n = edges.length; i < n; ++i) {
          if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = parent;
          if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = parent;
        }
      } else {
        node.transform = parent.transform;
      }
    }

    if (node.children) {
      node.children.forEach(function (child) {
        recurse(child, node);
      });
    }

    return node;
  }

  function forward(lambda, phi) {
    var node = face(lambda, phi),
        point = node.project([lambda * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], phi * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]]),
        t;

    if (t = node.transform) {
      return [t[0] * point[0] + t[1] * point[1] + t[2], -(t[3] * point[0] + t[4] * point[1] + t[5])];
    }

    point[1] = -point[1];
    return point;
  } // Naive inverse!  A faster solution would use bounding boxes, or even a
  // polygonal quadtree.


  if (hasInverse(root)) forward.invert = function (x, y) {
    var coordinates = faceInvert(root, [x, -y]);
    return coordinates && (coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates);
  };

  function faceInvert(node, coordinates) {
    var invert = node.project.invert,
        t = node.transform,
        point = coordinates;

    if (t) {
      t = Object(_matrix__WEBPACK_IMPORTED_MODULE_2__["inverse"])(t);
      point = [t[0] * point[0] + t[1] * point[1] + t[2], t[3] * point[0] + t[4] * point[1] + t[5]];
    }

    if (invert && node === faceDegrees(p = invert(point))) return p;
    var p,
        children = node.children;

    for (var i = 0, n = children && children.length; i < n; ++i) {
      if (p = faceInvert(children[i], coordinates)) return p;
    }
  }

  function faceDegrees(coordinates) {
    return face(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
  }

  var proj = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(forward),
      stream_ = proj.stream;

  proj.stream = function (stream) {
    var rotate = proj.rotate(),
        rotateStream = stream_(stream),
        sphereStream = (proj.rotate([0, 0]), stream_(stream));
    proj.rotate(rotate);

    rotateStream.sphere = function () {
      sphereStream.polygonStart();
      sphereStream.lineStart();
      outline(sphereStream, root);
      sphereStream.lineEnd();
      sphereStream.polygonEnd();
    };

    return rotateStream;
  };

  return proj;
});

function outline(stream, node, parent) {
  var point,
      edges = node.edges,
      n = edges.length,
      edge,
      multiPoint = {
    type: "MultiPoint",
    coordinates: node.face
  },
      notPoles = node.face.filter(function (d) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(d[1]) !== 90;
  }),
      b = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoBounds"])({
    type: "MultiPoint",
    coordinates: notPoles
  }),
      inside = false,
      j = -1,
      dx = b[1][0] - b[0][0]; // TODO

  var c = dx === 180 || dx === 360 ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2] : Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])(multiPoint); // First find the shared edge…

  if (parent) while (++j < n) {
    if (edges[j] === parent) break;
  }
  ++j;

  for (var i = 0; i < n; ++i) {
    edge = edges[(i + j) % n];

    if (Array.isArray(edge)) {
      if (!inside) {
        stream.point((point = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoInterpolate"])(edge[0], c)(_math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]))[0], point[1]);
        inside = true;
      }

      stream.point((point = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoInterpolate"])(edge[1], c)(_math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]))[0], point[1]);
    } else {
      inside = false;
      if (edge !== parent) outline(stream, edge, node);
    }
  }
} // Tests equality of two spherical points.


function pointEqual(a, b) {
  return a && b && a[0] === b[0] && a[1] === b[1];
} // Finds a shared edge given two clockwise polygons.


function sharedEdge(a, b) {
  var x,
      y,
      n = a.length,
      found = null;

  for (var i = 0; i < n; ++i) {
    x = a[i];

    for (var j = b.length; --j >= 0;) {
      y = b[j];

      if (x[0] === y[0] && x[1] === y[1]) {
        if (found) return [found, x];
        found = x;
      }
    }
  }
} // Converts an array of n face vertices to an array of n + 1 edges.


function faceEdges(face) {
  var n = face.length,
      edges = [];

  for (var a = face[n - 1], i = 0; i < n; ++i) {
    edges.push([a, a = face[i]]);
  }

  return edges;
}

function hasInverse(node) {
  return node.project.invert || node.children && node.children.some(hasInverse);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/matrix.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/matrix.js ***!
  \*****************************************************************/
/*! exports provided: default, inverse, multiply */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
 // Note: 6-element arrays are used to denote the 3x3 affine transform matrix:
// [a, b, c,
//  d, e, f,
//  0, 0, 1] - this redundant row is left out.
// Transform matrix for [a0, a1] -> [b0, b1].

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var u = subtract(a[1], a[0]),
      v = subtract(b[1], b[0]),
      phi = angle(u, v),
      s = length(u) / length(v);
  return multiply([1, 0, a[0][0], 0, 1, a[0][1]], multiply([s, 0, 0, 0, s, 0], multiply([Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi), 0, -Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi), Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi), 0], [1, 0, -b[0][0], 0, 1, -b[0][1]])));
}); // Inverts a transform matrix.

function inverse(m) {
  var k = 1 / (m[0] * m[4] - m[1] * m[3]);
  return [k * m[4], -k * m[1], k * (m[1] * m[5] - m[2] * m[4]), -k * m[3], k * m[0], k * (m[2] * m[3] - m[0] * m[5])];
} // Multiplies two 3x2 matrices.

function multiply(a, b) {
  return [a[0] * b[0] + a[1] * b[3], a[0] * b[1] + a[1] * b[4], a[0] * b[2] + a[1] * b[5] + a[2], a[3] * b[0] + a[4] * b[3], a[3] * b[1] + a[4] * b[4], a[3] * b[2] + a[4] * b[5] + a[5]];
} // Subtracts 2D vectors.

function subtract(a, b) {
  return [a[0] - b[0], a[1] - b[1]];
} // Magnitude of a 2D vector.


function length(v) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(v[0] * v[0] + v[1] * v[1]);
} // Angle between two 2D vectors.


function angle(a, b) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js":
/*!*********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/octahedron.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// TODO generate on-the-fly to avoid external modification.
var octahedron = [[0, 90], [-90, 0], [0, 0], [90, 0], [180, 0], [0, -90]];
/* harmony default export */ __webpack_exports__["default"] = ([[0, 2, 1], [0, 3, 2], [5, 1, 2], [5, 2, 3], [0, 1, 4], [0, 4, 3], [5, 4, 1], [5, 3, 4]].map(function (face) {
  return face.map(function (i) {
    return octahedron[i];
  });
}));

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/polyhedral/waterman.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/polyhedral/waterman.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/polyhedral/index.js");
/* harmony import */ var _octahedron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./octahedron */ "./node_modules/d3-geo-projection/src/polyhedral/octahedron.js");




/* harmony default export */ __webpack_exports__["default"] = (function (faceProjection) {
  faceProjection = faceProjection || function (face) {
    var c = face.length === 6 ? Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoCentroid"])({
      type: "MultiPoint",
      coordinates: face
    }) : face[0];
    return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonic"])().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);
  };

  var w5 = _octahedron__WEBPACK_IMPORTED_MODULE_3__["default"].map(function (face) {
    var xyz = face.map(cartesian),
        n = xyz.length,
        a = xyz[n - 1],
        b,
        hexagon = [];

    for (var i = 0; i < n; ++i) {
      b = xyz[i];
      hexagon.push(spherical([a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794, a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794, a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794]), spherical([b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794, b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794, b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794]));
      a = b;
    }

    return hexagon;
  });
  var cornerNormals = [];
  var parents = [-1, 0, 0, 1, 0, 1, 4, 5];
  w5.forEach(function (hexagon, j) {
    var face = _octahedron__WEBPACK_IMPORTED_MODULE_3__["default"][j],
        n = face.length,
        normals = cornerNormals[j] = [];

    for (var i = 0; i < n; ++i) {
      w5.push([face[i], hexagon[(i * 2 + 2) % (2 * n)], hexagon[(i * 2 + 1) % (2 * n)]]);
      parents.push(j);
      normals.push(cross(cartesian(hexagon[(i * 2 + 2) % (2 * n)]), cartesian(hexagon[(i * 2 + 1) % (2 * n)])));
    }
  });
  var faces = w5.map(function (face) {
    return {
      project: faceProjection(face),
      face: face
    };
  });
  parents.forEach(function (d, i) {
    var parent = faces[d];
    parent && (parent.children || (parent.children = [])).push(faces[i]);
  });

  function face(lambda, phi) {
    var cosphi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        p = [cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda), cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
    var hexagon = lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;
    var n = cornerNormals[hexagon];
    return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];
  }

  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(faces[0], face).scale(110.625).center([0, 45]);
});

function dot(a, b) {
  for (var i = 0, n = a.length, s = 0; i < n; ++i) {
    s += a[i] * b[i];
  }

  return s;
}

function cross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // Converts 3D Cartesian to spherical coordinates (degrees).


function spherical(cartesian) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(cartesian[1], cartesian[0]) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["max"])(-1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(1, cartesian[2]))) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]];
} // Converts spherical coordinates (degrees) to 3D Cartesian.


function cartesian(coordinates) {
  var lambda = coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      phi = coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"],
      cosphi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  return [cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda), cosphi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/project/clockwise.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/project/clockwise.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (ring) {
  if ((n = ring.length) < 4) return false;
  var i = 0,
      n,
      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];

  while (++i < n) {
    area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  }

  return area <= 0;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/project/contains.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/project/contains.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (ring, point) {
  var x = point[0],
      y = point[1],
      contains = false;

  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
        xi = pi[0],
        yi = pi[1],
        pj = ring[j],
        xj = pj[0],
        yj = pj[1];
    if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;
  }

  return contains;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/project/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/project/index.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo-projection/src/noop.js");
/* harmony import */ var _clockwise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clockwise */ "./node_modules/d3-geo-projection/src/project/clockwise.js");
/* harmony import */ var _contains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contains */ "./node_modules/d3-geo-projection/src/project/contains.js");




/* harmony default export */ __webpack_exports__["default"] = (function (object, projection) {
  var stream = projection.stream,
      project;
  if (!stream) throw new Error("invalid projection");

  switch (object && object.type) {
    case "Feature":
      project = projectFeature;
      break;

    case "FeatureCollection":
      project = projectFeatureCollection;
      break;

    default:
      project = projectGeometry;
      break;
  }

  return project(object, stream);
});

function projectFeatureCollection(o, stream) {
  return {
    type: "FeatureCollection",
    features: o.features.map(function (f) {
      return projectFeature(f, stream);
    })
  };
}

function projectFeature(o, stream) {
  return {
    type: "Feature",
    id: o.id,
    properties: o.properties,
    geometry: projectGeometry(o.geometry, stream)
  };
}

function projectGeometryCollection(o, stream) {
  return {
    type: "GeometryCollection",
    geometries: o.geometries.map(function (o) {
      return projectGeometry(o, stream);
    })
  };
}

function projectGeometry(o, stream) {
  if (!o) return null;
  if (o.type === "GeometryCollection") return projectGeometryCollection(o, stream);
  var sink;

  switch (o.type) {
    case "Point":
      sink = sinkPoint;
      break;

    case "MultiPoint":
      sink = sinkPoint;
      break;

    case "LineString":
      sink = sinkLine;
      break;

    case "MultiLineString":
      sink = sinkLine;
      break;

    case "Polygon":
      sink = sinkPolygon;
      break;

    case "MultiPolygon":
      sink = sinkPolygon;
      break;

    case "Sphere":
      sink = sinkPolygon;
      break;

    default:
      return null;
  }

  Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoStream"])(o, stream(sink));
  return sink.result();
}

var points = [],
    lines = [];
var sinkPoint = {
  point: function point(x, y) {
    points.push([x, y]);
  },
  result: function result() {
    var result = !points.length ? null : points.length < 2 ? {
      type: "Point",
      coordinates: points[0]
    } : {
      type: "MultiPoint",
      coordinates: points
    };
    points = [];
    return result;
  }
};
var sinkLine = {
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: function point(x, y) {
    points.push([x, y]);
  },
  lineEnd: function lineEnd() {
    if (points.length) lines.push(points), points = [];
  },
  result: function result() {
    var result = !lines.length ? null : lines.length < 2 ? {
      type: "LineString",
      coordinates: lines[0]
    } : {
      type: "MultiLineString",
      coordinates: lines
    };
    lines = [];
    return result;
  }
};
var sinkPolygon = {
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: function point(x, y) {
    points.push([x, y]);
  },
  lineEnd: function lineEnd() {
    var n = points.length;

    if (n) {
      do {
        points.push(points[0].slice());
      } while (++n < 4);

      lines.push(points), points = [];
    }
  },
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  result: function result() {
    if (!lines.length) return null;
    var polygons = [],
        holes = []; // https://github.com/d3/d3/issues/1558

    lines.forEach(function (ring) {
      if (Object(_clockwise__WEBPACK_IMPORTED_MODULE_2__["default"])(ring)) polygons.push([ring]);else holes.push(ring);
    });
    holes.forEach(function (hole) {
      var point = hole[0];
      polygons.some(function (polygon) {
        if (Object(_contains__WEBPACK_IMPORTED_MODULE_3__["default"])(polygon[0], point)) {
          polygon.push(hole);
          return true;
        }
      }) || polygons.push([hole]);
    });
    lines = [];
    return !polygons.length ? null : polygons.length > 1 ? {
      type: "MultiPolygon",
      coordinates: polygons
    } : {
      type: "Polygon",
      coordinates: polygons[0]
    };
  }
};

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quantize.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quantize.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (o, digits) {
  if (!(0 <= (digits = +digits) && digits <= 20)) throw new Error("invalid digits");

  function quantizePoint(coordinates) {
    coordinates[0] = +coordinates[0].toFixed(digits);
    coordinates[1] = +coordinates[1].toFixed(digits);
  }

  function quantizePoints(coordinates) {
    coordinates.forEach(quantizePoint);
  }

  function quantizePolygon(coordinates) {
    coordinates.forEach(quantizePoints);
  }

  function quantizeGeometry(o) {
    if (o) switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(quantizeGeometry);
        break;

      case "Point":
        quantizePoint(o.coordinates);
        break;

      case "MultiPoint":
      case "LineString":
        quantizePoints(o.coordinates);
        break;

      case "MultiLineString":
      case "Polygon":
        quantizePolygon(o.coordinates);
        break;

      case "MultiPolygon":
        o.coordinates.forEach(quantizePolygon);
        break;

      default:
        return;
    }
  }

  function quantizeFeature(o) {
    quantizeGeometry(o.geometry);
  }

  if (o) switch (o.type) {
    case "Feature":
      quantizeFeature(o);
      break;

    case "FeatureCollection":
      o.features.forEach(quantizeFeature);
      break;

    default:
      quantizeGeometry(o);
      break;
  }
  return o;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quincuncial/gringorten.js":
/*!**********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quincuncial/gringorten.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _gringorten__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gringorten */ "./node_modules/d3-geo-projection/src/gringorten.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/quincuncial/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_gringorten__WEBPACK_IMPORTED_MODULE_0__["gringortenRaw"]).scale(176.423);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quincuncial/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quincuncial/index.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo-projection/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = (function (project) {
  var dx = project(_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"], 0)[0] - project(-_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"], 0)[0];

  function projectQuincuncial(lambda, phi) {
    var t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
        p = project(t ? lambda : lambda > 0 ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : lambda + _math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi),
        x = (p[0] - p[1]) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        y = (p[0] + p[1]) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"];
    if (t) return [x, y];
    var d = dx * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        s = x > 0 ^ y > 0 ? -1 : 1;
    return [s * x - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * d, s * y - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * d];
  }

  if (project.invert) projectQuincuncial.invert = function (x0, y0) {
    var x = (x0 + y0) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        y = (y0 - x0) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
        t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x) < 0.5 * dx && Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < 0.5 * dx;

    if (!t) {
      var d = dx * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"],
          s = x > 0 ^ y > 0 ? -1 : 1,
          x1 = -s * (x0 + (y > 0 ? 1 : -1) * d),
          y1 = -s * (y0 + (x > 0 ? 1 : -1) * d);
      x = (-x1 - y1) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"];
      y = (x1 - y1) * _math__WEBPACK_IMPORTED_MODULE_1__["sqrt1_2"];
    }

    var p = project.invert(x, y);
    if (!t) p[0] += x > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    return p;
  };
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(projectQuincuncial).rotate([-90, -90, 45]).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/quincuncial/peirce.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/quincuncial/peirce.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _guyou__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../guyou */ "./node_modules/d3-geo-projection/src/guyou.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo-projection/src/quincuncial/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_1__["default"])(_guyou__WEBPACK_IMPORTED_MODULE_0__["guyouRaw"]).scale(111.48);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/rectangularPolyconic.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/rectangularPolyconic.js ***!
  \********************************************************************/
/*! exports provided: rectangularPolyconicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rectangularPolyconicRaw", function() { return rectangularPolyconicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _parallel1__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parallel1 */ "./node_modules/d3-geo-projection/src/parallel1.js");


function rectangularPolyconicRaw(phi0) {
  var sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi0);

  function forward(lambda, phi) {
    var A = sinPhi0 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;
    if (!phi) return [2 * A, -phi0];
    var E = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(A * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi)),
        cotPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(E) * cotPhi, phi + (1 - Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(E)) * cotPhi - phi0];
  } // TODO return null for points outside outline.


  forward.invert = function (x, y) {
    if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(y += phi0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return [sinPhi0 ? 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(sinPhi0 * x / 2) / sinPhi0 : x, 0];
    var k = x * x + y * y,
        phi = 0,
        i = 10,
        delta;

    do {
      var tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi),
          secPhi = 1 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
          j = k - 2 * y * phi + phi * phi;
      phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);
    } while (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && --i > 0);

    var E = x * (tanPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(phi)),
        A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(y) < Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(phi + 1 / tanPhi) ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(E) * 0.5 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["acos"])(E) * 0.5 + _math__WEBPACK_IMPORTED_MODULE_0__["pi"] / 4) / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
    return [sinPhi0 ? 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(sinPhi0 * A) / sinPhi0 : 2 * A, phi];
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_parallel1__WEBPACK_IMPORTED_MODULE_1__["default"])(rectangularPolyconicRaw).scale(131.215);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/robinson.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/robinson.js ***!
  \********************************************************/
/*! exports provided: robinsonRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "robinsonRaw", function() { return robinsonRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


var K = [[0.9986, -0.062], [1.0000, 0.0000], [0.9986, 0.0620], [0.9954, 0.1240], [0.9900, 0.1860], [0.9822, 0.2480], [0.9730, 0.3100], [0.9600, 0.3720], [0.9427, 0.4340], [0.9216, 0.4958], [0.8962, 0.5571], [0.8679, 0.6176], [0.8350, 0.6769], [0.7986, 0.7346], [0.7597, 0.7903], [0.7186, 0.8435], [0.6732, 0.8936], [0.6213, 0.9394], [0.5722, 0.9761], [0.5322, 1.0000]];
K.forEach(function (d) {
  d[1] *= 1.0144;
});
function robinsonRaw(lambda, phi) {
  var i = Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(18, Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) * 36 / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]),
      i0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])(i),
      di = i - i0,
      ax = (k = K[i0])[0],
      ay = k[1],
      bx = (k = K[++i0])[0],
      by = k[1],
      cx = (k = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, ++i0)])[0],
      cy = k[1],
      k;
  return [lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (phi > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)];
}

robinsonRaw.invert = function (x, y) {
  var yy = y / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      phi = yy * 90,
      i = Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(18, Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi / 5)),
      i0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["max"])(0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])(i));

  do {
    var ay = K[i0][1],
        by = K[i0 + 1][1],
        cy = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, i0 + 2)][1],
        u = cy - ay,
        v = cy - 2 * by + ay,
        t = 2 * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(yy) - by) / u,
        c = v / u,
        di = t * (1 - c * t * (1 - 2 * c * t));

    if (di >= 0 || i0 === 1) {
      phi = (y >= 0 ? 5 : -5) * (di + i);
      var j = 50,
          delta;

      do {
        i = Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(18, Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) / 5);
        i0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floor"])(i);
        di = i - i0;
        ay = K[i0][1];
        by = K[i0 + 1][1];
        cy = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, i0 + 2)][1];
        phi -= (delta = (y >= 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
      } while (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon2"] && --j > 0);

      break;
    }
  } while (--i0 >= 0);

  var ax = K[i0][0],
      bx = K[i0 + 1][0],
      cx = K[Object(_math__WEBPACK_IMPORTED_MODULE_1__["min"])(19, i0 + 2)][0];
  return [x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), phi * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(robinsonRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/satellite.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/satellite.js ***!
  \*********************************************************/
/*! exports provided: satelliteRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "satelliteRaw", function() { return satelliteRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



function satelliteVerticalRaw(P) {
  function forward(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        k = (P - 1) / (P - cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda));
    return [k * cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi)];
  }

  forward.invert = function (x, y) {
    var rho2 = x * x + y * y,
        rho = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(rho2),
        sinc = (P - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * sinc, rho * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - sinc * sinc)), rho ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * sinc / rho) : 0];
  };

  return forward;
}

function satelliteRaw(P, omega) {
  var vertical = satelliteVerticalRaw(P);
  if (!omega) return vertical;
  var cosOmega = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(omega),
      sinOmega = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(omega);

  function forward(lambda, phi) {
    var coordinates = vertical(lambda, phi),
        y = coordinates[1],
        A = y * sinOmega / (P - 1) + cosOmega;
    return [coordinates[0] * cosOmega / A, y / A];
  }

  forward.invert = function (x, y) {
    var k = (P - 1) / (P - 1 - y * sinOmega);
    return vertical.invert(k * x, k * y * cosOmega);
  };

  return forward;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var distance = 2,
      omega = 0,
      m = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjectionMutator"])(satelliteRaw),
      p = m(distance, omega); // As a multiple of radius.

  p.distance = function (_) {
    if (!arguments.length) return distance;
    return m(distance = +_, omega);
  };

  p.tilt = function (_) {
    if (!arguments.length) return omega * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"];
    return m(distance, omega = _ * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
  };

  return p.scale(432.147).clipAngle(Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(1 / distance) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"] - 1e-6);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/sinuMollweide.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/sinuMollweide.js ***!
  \*************************************************************/
/*! exports provided: sinuMollweidePhi, sinuMollweideY, sinuMollweideRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinuMollweidePhi", function() { return sinuMollweidePhi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinuMollweideY", function() { return sinuMollweideY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinuMollweideRaw", function() { return sinuMollweideRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var _sinusoidal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sinusoidal */ "./node_modules/d3-geo-projection/src/sinusoidal.js");



var sinuMollweidePhi = 0.7109889596207567;
var sinuMollweideY = 0.0528035274542;
function sinuMollweideRaw(lambda, phi) {
  return phi > -sinuMollweidePhi ? (lambda = Object(_mollweide__WEBPACK_IMPORTED_MODULE_1__["mollweideRaw"])(lambda, phi), lambda[1] += sinuMollweideY, lambda) : Object(_sinusoidal__WEBPACK_IMPORTED_MODULE_2__["sinusoidalRaw"])(lambda, phi);
}

sinuMollweideRaw.invert = function (x, y) {
  return y > -sinuMollweidePhi ? _mollweide__WEBPACK_IMPORTED_MODULE_1__["mollweideRaw"].invert(x, y - sinuMollweideY) : _sinusoidal__WEBPACK_IMPORTED_MODULE_2__["sinusoidalRaw"].invert(x, y);
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(sinuMollweideRaw).rotate([-20, -55]).scale(164.263).center([0, -5.4036]);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/sinusoidal.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/sinusoidal.js ***!
  \**********************************************************/
/*! exports provided: sinusoidalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinusoidalRaw", function() { return sinusoidalRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function sinusoidalRaw(lambda, phi) {
  return [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi), phi];
}

sinusoidalRaw.invert = function (x, y) {
  return [x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(y), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(sinusoidalRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/square.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/square.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (project) {
  var dx = project(_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"], 0)[0] - project(-_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"], 0)[0];

  function projectSquare(lambda, phi) {
    var s = lambda > 0 ? -0.5 : 0.5,
        point = project(lambda + s * _math__WEBPACK_IMPORTED_MODULE_0__["pi"], phi);
    point[0] -= s * dx;
    return point;
  }

  if (project.invert) projectSquare.invert = function (x, y) {
    var s = x > 0 ? -0.5 : 0.5,
        location = project.invert(x + s * dx, y),
        lambda = location[0] - s * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    if (lambda < -_math__WEBPACK_IMPORTED_MODULE_0__["pi"]) lambda += 2 * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];else if (lambda > _math__WEBPACK_IMPORTED_MODULE_0__["pi"]) lambda -= 2 * _math__WEBPACK_IMPORTED_MODULE_0__["pi"];
    location[0] = lambda;
    return location;
  };
  return projectSquare;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/stitch.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/stitch.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var epsilon = 1e-4,
    epsilonInverse = 1e4,
    x0 = -180,
    x0e = x0 + epsilon,
    x1 = 180,
    x1e = x1 - epsilon,
    y0 = -90,
    y0e = y0 + epsilon,
    y1 = 90,
    y1e = y1 - epsilon;

function quantize(x) {
  return Math.floor(x * epsilonInverse) / epsilonInverse;
}

function normalizePoint(y) {
  return y === y0 || y === y1 ? [0, y] // pole
  : [x0, quantize(y)]; // antimeridian
}

function clampPoint(p) {
  if (p[0] <= x0e) p[0] = x0;else if (p[0] >= x1e) p[0] = x1;
  if (p[1] <= y0e) p[1] = y0;else if (p[1] >= y1e) p[1] = y1;
}

function clampPoints(points) {
  points.forEach(clampPoint);
} // For each ring, detect where it crosses the antimeridian or pole.


function extractFragments(polygon, fragments) {
  for (var j = 0, m = polygon.length; j < m; ++j) {
    var ring = polygon[j];
    ring.polygon = polygon; // By default, assume that this ring doesn’t need any stitching.

    fragments.push(ring);

    for (var i = 0, n = ring.length; i < n; ++i) {
      var point = ring[i],
          x = point[0],
          y = point[1]; // If this is an antimeridian or polar point…

      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {
        clampPoint(point); // Advance through any antimeridian or polar points…

        for (var k = i + 1; k < n; ++k) {
          var pointk = ring[k],
              xk = pointk[0],
              yk = pointk[1];
          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;
        } // If this was just a single antimeridian or polar point,
        // we don’t need to cut this ring into a fragment;
        // we can just leave it as-is.


        if (k === i + 1) continue; // Otherwise, if this is not the first point in the ring,
        // cut the current fragment so that it ends at the current point.
        // The current point is also normalized for later joining.

        if (i) {
          var fragmentBefore = ring.slice(0, i + 1);
          fragmentBefore.polygon = polygon;
          fragmentBefore[fragmentBefore.length - 1] = normalizePoint(y);
          fragments[fragments.length - 1] = fragmentBefore;
        } // If the ring started with an antimeridian fragment,
        // we can ignore that fragment entirely.
        else fragments.pop(); // If the remainder of the ring is an antimeridian fragment,
        // move on to the next ring.


        if (k >= n) break; // Otherwise, add the remaining ring fragment and continue.

        fragments.push(ring = ring.slice(k - 1));
        ring[0] = normalizePoint(ring[0][1]);
        ring.polygon = polygon;
        i = -1;
        n = ring.length;
      }
    }
  }

  polygon.length = 0;
} // Now stitch the fragments back together into rings.
// TODO remove empty polygons.


function stitchFragments(fragments) {
  var i,
      n = fragments.length; // To connect the fragments start-to-end, create a simple index by end.

  var fragmentByStart = {},
      fragmentByEnd = {},
      fragment,
      start,
      startFragment,
      end,
      endFragment; // For each fragment…

  for (i = 0; i < n; ++i) {
    fragment = fragments[i];
    start = fragment[0];
    end = fragment[fragment.length - 1]; // If this fragment is closed, add it as a standalone ring.

    if (start[0] === end[0] && start[1] === end[1]) {
      fragment.polygon.push(fragment);
      fragments[i] = null;
      continue;
    }

    fragment.index = i;
    fragmentByStart[start] = fragmentByEnd[end] = fragment;
  } // For each open fragment…


  for (i = 0; i < n; ++i) {
    fragment = fragments[i];

    if (fragment) {
      start = fragment[0];
      end = fragment[fragment.length - 1];
      startFragment = fragmentByEnd[start];
      endFragment = fragmentByStart[end];
      delete fragmentByStart[start];
      delete fragmentByEnd[end]; // If this fragment is closed, add it as a standalone ring.

      if (start[0] === end[0] && start[1] === end[1]) {
        fragment.polygon.push(fragment);
        continue;
      }

      if (startFragment) {
        delete fragmentByEnd[start];
        delete fragmentByStart[startFragment[0]];
        startFragment.pop(); // drop the shared coordinate

        fragments[startFragment.index] = null;
        fragment = startFragment.concat(fragment);
        fragment.polygon = startFragment.polygon;

        if (startFragment === endFragment) {
          // Connect both ends to this single fragment to create a ring.
          fragment.polygon.push(fragment);
        } else {
          fragment.index = n++;
          fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);
        }
      } else if (endFragment) {
        delete fragmentByStart[end];
        delete fragmentByEnd[endFragment[endFragment.length - 1]];
        fragment.pop(); // drop the shared coordinate

        fragment = fragment.concat(endFragment);
        fragment.polygon = endFragment.polygon;
        fragment.index = n++;
        fragments[endFragment.index] = null;
        fragments.push(fragmentByStart[fragment[0]] = fragmentByEnd[fragment[fragment.length - 1]] = fragment);
      } else {
        fragment.push(fragment[0]); // close ring

        fragment.polygon.push(fragment);
      }
    }
  }
}

function stitchFeature(o) {
  stitchGeometry(o.geometry);
}

function stitchGeometry(o) {
  if (!o) return;
  var fragments, i, n;

  switch (o.type) {
    case "GeometryCollection":
      {
        o.geometries.forEach(stitchGeometry);
        return;
      }

    case "Point":
      {
        clampPoint(o.coordinates);
        break;
      }

    case "MultiPoint":
    case "LineString":
      {
        clampPoints(o.coordinates);
        break;
      }

    case "MultiLineString":
      {
        o.coordinates.forEach(clampPoints);
        break;
      }

    case "Polygon":
      {
        extractFragments(o.coordinates, fragments = []);
        break;
      }

    case "MultiPolygon":
      {
        fragments = [], i = -1, n = o.coordinates.length;

        while (++i < n) {
          extractFragments(o.coordinates[i], fragments);
        }

        break;
      }

    default:
      return;
  }

  stitchFragments(fragments);
}

/* harmony default export */ __webpack_exports__["default"] = (function (o) {
  if (o) switch (o.type) {
    case "Feature":
      stitchFeature(o);
      break;

    case "FeatureCollection":
      o.features.forEach(stitchFeature);
      break;

    default:
      stitchGeometry(o);
      break;
  }
  return o;
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/times.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/times.js ***!
  \*****************************************************/
/*! exports provided: timesRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timesRaw", function() { return timesRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function timesRaw(lambda, phi) {
  var t = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(phi / 2),
      s = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] * t);
  return [lambda * (0.74482 - 0.34588 * s * s), 1.70711 * t];
}

timesRaw.invert = function (x, y) {
  var t = y / 1.70711,
      s = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(_math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"] * t);
  return [x / (0.74482 - 0.34588 * s * s), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(t)];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(timesRaw).scale(146.153);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/twoPoint.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/twoPoint.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");

 // Compute the origin as the midpoint of the two reference points.
// Rotate one of the reference points by the origin.
// Apply the spherical law of sines to compute gamma rotation.

/* harmony default export */ __webpack_exports__["default"] = (function (raw, p0, p1) {
  var i = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoInterpolate"])(p0, p1),
      o = i(0.5),
      a = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])([-o[0], -o[1]])(p0),
      b = i.distance / 2,
      y = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(a[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(b)),
      R = [-o[0], -o[1], -(a[0] > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] - y : y) * _math__WEBPACK_IMPORTED_MODULE_1__["degrees"]],
      p = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(raw(b)).rotate(R),
      r = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoRotation"])(R),
      center = p.center;
  delete p.rotate;

  p.center = function (_) {
    return arguments.length ? center(r(_)) : r.invert(center());
  };

  return p.clipAngle(90);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/twoPointAzimuthal.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/twoPointAzimuthal.js ***!
  \*****************************************************************/
/*! exports provided: twoPointAzimuthalRaw, twoPointAzimuthalUsa, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointAzimuthalRaw", function() { return twoPointAzimuthalRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointAzimuthalUsa", function() { return twoPointAzimuthalUsa; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return twoPointAzimuthal; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _twoPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./twoPoint */ "./node_modules/d3-geo-projection/src/twoPoint.js");



function twoPointAzimuthalRaw(d) {
  var cosd = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(d);

  function forward(lambda, phi) {
    var coordinates = Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonicRaw"])(lambda, phi);
    coordinates[0] *= cosd;
    return coordinates;
  }

  forward.invert = function (x, y) {
    return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoGnomonicRaw"].invert(x / cosd, y);
  };

  return forward;
}
function twoPointAzimuthalUsa() {
  return twoPointAzimuthal([-158, 21.5], [-77, 39]).clipAngle(60).scale(400);
}
function twoPointAzimuthal(p0, p1) {
  return Object(_twoPoint__WEBPACK_IMPORTED_MODULE_2__["default"])(twoPointAzimuthalRaw, p0, p1);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/twoPointEquidistant.js":
/*!*******************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/twoPointEquidistant.js ***!
  \*******************************************************************/
/*! exports provided: twoPointEquidistantRaw, twoPointEquidistantUsa, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointEquidistantRaw", function() { return twoPointEquidistantRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "twoPointEquidistantUsa", function() { return twoPointEquidistantUsa; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return twoPointEquidistant; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _twoPoint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./twoPoint */ "./node_modules/d3-geo-projection/src/twoPoint.js");


 // TODO clip to ellipse

function twoPointEquidistantRaw(z0) {
  if (!(z0 *= 2)) return d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoAzimuthalEquidistantRaw"];
  var lambdaa = -z0 / 2,
      lambdab = -lambdaa,
      z02 = z0 * z0,
      tanLambda0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(lambdab),
      S = 0.5 / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambdab);

  function forward(lambda, phi) {
    var za = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda - lambdaa)),
        zb = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda - lambdab)),
        ys = phi < 0 ? -1 : 1;
    za *= za, zb *= zb;
    return [(za - zb) / (2 * z0), ys * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)];
  }

  forward.invert = function (x, y) {
    var y2 = y * y,
        cosza = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(y2 + (t = x + lambdaa) * t)),
        coszb = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(y2 + (t = x + lambdab) * t)),
        t,
        d;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(d = cosza - coszb, t = (cosza + coszb) * tanLambda0), (y < 0 ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(t * t + d * d) * S)];
  };

  return forward;
}
function twoPointEquidistantUsa() {
  return twoPointEquidistant([-158, 21.5], [-77, 39]).clipAngle(130).scale(122.571);
}
function twoPointEquidistant(p0, p1) {
  return Object(_twoPoint__WEBPACK_IMPORTED_MODULE_2__["default"])(twoPointEquidistantRaw, p0, p1);
}

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten.js ***!
  \*************************************************************/
/*! exports provided: vanDerGrintenRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrintenRaw", function() { return vanDerGrintenRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrintenRaw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]),
      theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(theta / 2)];
  var cosTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta),
      A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda - lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      A2 = A * A,
      G = cosTheta / (sinTheta + cosTheta - 1),
      P = G * (2 / sinTheta - 1),
      P2 = P * P,
      P2_A2 = P2 + A2,
      G_P2 = G - P2,
      Q = A2 + G;
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (A * G_P2 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (P * Q - A * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((A2 + 1) * P2_A2 - Q * Q)) / P2_A2];
}

vanDerGrintenRaw.invert = function (x, y) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [x, 0];
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))];
  var x2 = (x /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * x,
      y2 = (y /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * y,
      x2_y2 = x2 + y2,
      z = x2_y2 * x2_y2,
      c1 = -Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y) * (1 + x2_y2),
      c2 = c1 - 2 * y2 + x2,
      c3 = -2 * c1 + 1 + 2 * y2 + z,
      d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27,
      a1 = (c1 - c2 * c2 / (3 * c3)) / c3,
      m1 = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(-a1 / 3),
      theta1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["acos"])(3 * d / (a1 * m1)) / 3;
  return [_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (x2_y2 - 1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + 2 * (x2 - y2) + z)) / (2 * x), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (-m1 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta1 + _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 3) - c2 / (3 * c3))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrintenRaw).scale(79.4183);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten2.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten2.js ***!
  \**************************************************************/
/*! exports provided: vanDerGrinten2Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrinten2Raw", function() { return vanDerGrinten2Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrinten2Raw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var sinTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]),
      theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(theta / 2)];
  var cosTheta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta),
      A = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda - lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      A2 = A * A,
      x1 = cosTheta * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + A2) - A * cosTheta) / (1 + A2 * sinTheta * sinTheta);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * x1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - x1 * (2 * A + x1))];
}

vanDerGrinten2Raw.invert = function (x, y) {
  if (!x) return [0, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]))];
  var x1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]),
      A = (1 - x1 * x1 - (y /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) * y) / (2 * x1),
      A2 = A * A,
      B = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A2 + 1);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (B - A), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(y) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])((1 - 2 * A * x1) * (A + B) - x1), Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(B + A + x1)))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrinten2Raw).scale(79.4183);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten3.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten3.js ***!
  \**************************************************************/
/*! exports provided: vanDerGrinten3Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrinten3Raw", function() { return vanDerGrinten3Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrinten3Raw(lambda, phi) {
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [lambda, 0];
  var sinTheta = phi / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      theta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(sinTheta);
  if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) return [0, _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(theta / 2)];
  var A = (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] / lambda - lambda / _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) / 2,
      y1 = sinTheta / (1 + Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(theta));
  return [_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A * A + 1 - y1 * y1) - A), _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * y1];
}

vanDerGrinten3Raw.invert = function (x, y) {
  if (!y) return [x, 0];
  var y1 = y / _math__WEBPACK_IMPORTED_MODULE_1__["pi"],
      A = (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (1 - y1 * y1) - x * x) / (2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * x);
  return [x ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(A * A + 1) - A) : 0, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(y1))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrinten3Raw).scale(79.4183);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/vanDerGrinten4.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/vanDerGrinten4.js ***!
  \**************************************************************/
/*! exports provided: vanDerGrinten4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vanDerGrinten4Raw", function() { return vanDerGrinten4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function vanDerGrinten4Raw(lambda, phi) {
  if (!phi) return [lambda, 0];
  var phi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(phi);
  if (!lambda || phi0 === _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) return [0, phi];
  var B = phi0 / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      B2 = B * B,
      C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
      C2 = C * C,
      BC = B * C,
      B_C2 = B2 + C2 + 2 * BC,
      B_3C = B + 3 * C,
      lambda0 = lambda / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      lambda1 = lambda0 + 1 / lambda0,
      D = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(lambda1 * lambda1 - 4),
      D2 = D * D,
      F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2),
      x1 = (D * (B_C2 + C2 - 1) + 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(F)) / (4 * B_C2 + D2);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(lambda) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * x1, Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(phi) * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 + D * Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1) - x1 * x1)];
}

vanDerGrinten4Raw.invert = function (x, y) {
  var delta;
  if (!x || !y) return [x, y];
  y /= _math__WEBPACK_IMPORTED_MODULE_1__["pi"];
  var x1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * x / _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"],
      D = (x1 * x1 - 1 + 4 * y * y) / Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x1),
      D2 = D * D,
      B = 2 * y,
      i = 50;

  do {
    var B2 = B * B,
        C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
        C_ = (3 * B - B2 * B - 10) / (2 * B2 * B),
        C2 = C * C,
        BC = B * C,
        B_C = B + C,
        B_C2 = B_C * B_C,
        B_3C = B + 3 * C,
        F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)),
        F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)),
        sqrtF = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(F),
        f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2),
        f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
    B -= delta = f / f_;
  } while (delta > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] && --i > 0);

  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["sign"])(x) * (Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(D * D + 4) + D) * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] / 4, _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] * B];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(vanDerGrinten4Raw).scale(127.16);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wagner4.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wagner4.js ***!
  \*******************************************************/
/*! exports provided: wagner4Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wagner4Raw", function() { return wagner4Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");
/* harmony import */ var _mollweide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mollweide */ "./node_modules/d3-geo-projection/src/mollweide.js");



var A = 4 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] + 3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3),
    B = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 * _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3) / A);
var wagner4Raw = Object(_mollweide__WEBPACK_IMPORTED_MODULE_2__["mollweideBromleyRaw"])(B * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(3) / _math__WEBPACK_IMPORTED_MODULE_1__["pi"], B, A / 6);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wagner4Raw).scale(176.84);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wagner6.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wagner6.js ***!
  \*******************************************************/
/*! exports provided: wagner6Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wagner6Raw", function() { return wagner6Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function wagner6Raw(lambda, phi) {
  return [lambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - 3 * phi * phi / (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"])), phi];
}

wagner6Raw.invert = function (x, y) {
  return [x / Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - 3 * y * y / (_math__WEBPACK_IMPORTED_MODULE_1__["pi"] * _math__WEBPACK_IMPORTED_MODULE_1__["pi"])), y];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wagner6Raw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wagner7.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wagner7.js ***!
  \*******************************************************/
/*! exports provided: wagner7Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wagner7Raw", function() { return wagner7Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function wagner7Raw(lambda, phi) {
  var s = 0.90631 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      c0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - s * s),
      c1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(2 / (1 + c0 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda /= 3)));
  return [2.66723 * c0 * c1 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda), 1.24104 * s * c1];
}

wagner7Raw.invert = function (x, y) {
  var t1 = x / 2.66723,
      t2 = y / 1.24104,
      p = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(t1 * t1 + t2 * t2),
      c = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(p / 2);
  return [3 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(x * Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])(c), 2.66723 * p), p && Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(y * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(c) / (1.24104 * 0.90631 * p))];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wagner7Raw).scale(172.632);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/wiechel.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/wiechel.js ***!
  \*******************************************************/
/*! exports provided: wiechelRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wiechelRaw", function() { return wiechelRaw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");


function wiechelRaw(lambda, phi) {
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
      sin1_Phi = 1 - sinPhi,
      cosLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi, -Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi))),
      sinLambda = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda);
  cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(1 - sinPhi * sinPhi);
  return [sinLambda * cosPhi - cosLambda * sin1_Phi, -cosLambda * cosPhi - sinLambda * sin1_Phi];
}

wiechelRaw.invert = function (x, y) {
  var w = (x * x + y * y) / -2,
      k = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(-w * (2 + w)),
      b = y * w + x * k,
      a = x * w - y * k,
      D = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b);
  return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(k * b, D * (1 + w)), D ? -Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * a / D) : 0];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(wiechelRaw).rotate([0, -90, 45]).scale(124.75).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo-projection/src/winkel3.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/winkel3.js ***!
  \*******************************************************/
/*! exports provided: winkel3Raw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "winkel3Raw", function() { return winkel3Raw; });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony import */ var _aitoff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aitoff */ "./node_modules/d3-geo-projection/src/aitoff.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo-projection/src/math.js");



function winkel3Raw(lambda, phi) {
  var coordinates = Object(_aitoff__WEBPACK_IMPORTED_MODULE_1__["aitoffRaw"])(lambda, phi);
  return [(coordinates[0] + lambda / _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) / 2, (coordinates[1] + phi) / 2];
}

winkel3Raw.invert = function (x, y) {
  var lambda = x,
      phi = y,
      i = 25;

  do {
    var cosphi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi),
        sinphi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi),
        sin_2phi = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(2 * phi),
        sin2phi = sinphi * sinphi,
        cos2phi = cosphi * cosphi,
        sinlambda = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda),
        coslambda_2 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda / 2),
        sinlambda_2 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda / 2),
        sin2lambda_2 = sinlambda_2 * sinlambda_2,
        C = 1 - cos2phi * coslambda_2 * coslambda_2,
        E = C ? Object(_math__WEBPACK_IMPORTED_MODULE_2__["acos"])(cosphi * coslambda_2) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(F = 1 / C) : F = 0,
        F,
        fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"]) - x,
        fy = 0.5 * (E * sinphi + phi) - y,
        dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"],
        dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2),
        dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda),
        dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5,
        denominator = dxdphi * dydlambda - dydphi * dxdlambda,
        dlambda = (fy * dxdphi - fx * dydphi) / denominator,
        dphi = (fx * dydlambda - fy * dxdlambda) / denominator;
    lambda -= dlambda, phi -= dphi;
  } while ((Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(dlambda) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(dphi) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) && --i > 0);

  return [lambda, phi];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(d3_geo__WEBPACK_IMPORTED_MODULE_0__["geoProjection"])(winkel3Raw).scale(158.837);
});

/***/ }),

/***/ "./node_modules/d3-geo/index.js":
/*!**************************************!*\
  !*** ./node_modules/d3-geo/index.js ***!
  \**************************************/
/*! exports provided: geoArea, geoBounds, geoCentroid, geoCircle, geoClipExtent, geoDistance, geoGraticule, geoGraticule10, geoInterpolate, geoLength, geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEqualAreaRaw, geoAzimuthalEquidistant, geoAzimuthalEquidistantRaw, geoConicConformal, geoConicConformalRaw, geoConicEqualArea, geoConicEqualAreaRaw, geoConicEquidistant, geoConicEquidistantRaw, geoEquirectangular, geoEquirectangularRaw, geoGnomonic, geoGnomonicRaw, geoIdentity, geoProjection, geoProjectionMutator, geoMercator, geoMercatorRaw, geoOrthographic, geoOrthographicRaw, geoStereographic, geoStereographicRaw, geoTransverseMercator, geoTransverseMercatorRaw, geoRotation, geoStream, geoTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_area__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/area */ "./node_modules/d3-geo/src/area.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return _src_area__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/bounds */ "./node_modules/d3-geo/src/bounds.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return _src_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_centroid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/centroid */ "./node_modules/d3-geo/src/centroid.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return _src_centroid__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/circle */ "./node_modules/d3-geo/src/circle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return _src_circle__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_clip_extent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/clip/extent */ "./node_modules/d3-geo/src/clip/extent.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return _src_clip_extent__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_distance__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/distance */ "./node_modules/d3-geo/src/distance.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return _src_distance__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_graticule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/graticule */ "./node_modules/d3-geo/src/graticule.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return _src_graticule__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return _src_graticule__WEBPACK_IMPORTED_MODULE_6__["graticule10"]; });

/* harmony import */ var _src_interpolate__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/interpolate */ "./node_modules/d3-geo/src/interpolate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return _src_interpolate__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_length__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/length */ "./node_modules/d3-geo/src/length.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return _src_length__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_path_index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/path/index */ "./node_modules/d3-geo/src/path/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return _src_path_index__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_projection_albers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/projection/albers */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return _src_projection_albers__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/projection/albersUsa */ "./node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return _src_projection_albersUsa__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/projection/azimuthalEqualArea */ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return _src_projection_azimuthalEqualArea__WEBPACK_IMPORTED_MODULE_12__["azimuthalEqualAreaRaw"]; });

/* harmony import */ var _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/projection/azimuthalEquidistant */ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return _src_projection_azimuthalEquidistant__WEBPACK_IMPORTED_MODULE_13__["azimuthalEquidistantRaw"]; });

/* harmony import */ var _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/projection/conicConformal */ "./node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return _src_projection_conicConformal__WEBPACK_IMPORTED_MODULE_14__["conicConformalRaw"]; });

/* harmony import */ var _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/projection/conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return _src_projection_conicEqualArea__WEBPACK_IMPORTED_MODULE_15__["conicEqualAreaRaw"]; });

/* harmony import */ var _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/projection/conicEquidistant */ "./node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return _src_projection_conicEquidistant__WEBPACK_IMPORTED_MODULE_16__["conicEquidistantRaw"]; });

/* harmony import */ var _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/projection/equirectangular */ "./node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return _src_projection_equirectangular__WEBPACK_IMPORTED_MODULE_17__["equirectangularRaw"]; });

/* harmony import */ var _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/projection/gnomonic */ "./node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return _src_projection_gnomonic__WEBPACK_IMPORTED_MODULE_18__["gnomonicRaw"]; });

/* harmony import */ var _src_projection_identity__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/projection/identity */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return _src_projection_identity__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _src_projection_index__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/projection/index */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return _src_projection_index__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return _src_projection_index__WEBPACK_IMPORTED_MODULE_20__["projectionMutator"]; });

/* harmony import */ var _src_projection_mercator__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/projection/mercator */ "./node_modules/d3-geo/src/projection/mercator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return _src_projection_mercator__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return _src_projection_mercator__WEBPACK_IMPORTED_MODULE_21__["mercatorRaw"]; });

/* harmony import */ var _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/projection/orthographic */ "./node_modules/d3-geo/src/projection/orthographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return _src_projection_orthographic__WEBPACK_IMPORTED_MODULE_22__["orthographicRaw"]; });

/* harmony import */ var _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/projection/stereographic */ "./node_modules/d3-geo/src/projection/stereographic.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return _src_projection_stereographic__WEBPACK_IMPORTED_MODULE_23__["stereographicRaw"]; });

/* harmony import */ var _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/projection/transverseMercator */ "./node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return _src_projection_transverseMercator__WEBPACK_IMPORTED_MODULE_24__["transverseMercatorRaw"]; });

/* harmony import */ var _src_rotation__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return _src_rotation__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _src_stream__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return _src_stream__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_27__["default"]; });





 // DEPRECATED! Use d3.geoIdentity().clipExtent(…).

























/***/ }),

/***/ "./node_modules/d3-geo/src/adder.js":
/*!******************************************!*\
  !*** ./node_modules/d3-geo/src/adder.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new Adder();
});

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function reset() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function add(y) {
    _add(temp, y, this.t);

    _add(this, temp.s, this.s);

    if (this.s) this.t += temp.t;else this.s = temp.t;
  },
  valueOf: function valueOf() {
    return this.s;
  }
};
var temp = new Adder();

function _add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = a - av + (b - bv);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/area.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/area.js ***!
  \*****************************************/
/*! exports provided: areaRingSum, areaStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaRingSum", function() { return areaRingSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areaStream", function() { return areaStream; });
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");




var areaRingSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
var areaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function polygonStart() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function polygonEnd() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["tau"] + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
  },
  sphere: function sphere() {
    areaSum.add(_math__WEBPACK_IMPORTED_MODULE_1__["tau"]);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]), sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  phi = phi / 2 + _math__WEBPACK_IMPORTED_MODULE_1__["quarterPi"]; // half the angular distance from south pole
  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).

  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(adLambda),
      v = k * sdLambda * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(adLambda);
  areaRingSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(v, u)); // Advance the previous points.

  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  areaSum.reset();
  Object(_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, areaStream);
  return areaSum * 2;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/bounds.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/bounds.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo/src/area.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");





var lambda0,
    phi0,
    lambda1,
    phi1,
    // bounds
lambda2,
    // previous lambda-coordinate
lambda00,
    phi00,
    // first point
p0,
    // previous 3D point
deltaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    ranges,
    range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function polygonStart() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonStart();
  },
  polygonEnd: function polygonEnd() {
    _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area__WEBPACK_IMPORTED_MODULE_1__["areaRingSum"] < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi1 = 90;else if (deltaSum < -_math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesian"])([lambda * _math__WEBPACK_IMPORTED_MODULE_3__["radians"], phi * _math__WEBPACK_IMPORTED_MODULE_3__["radians"]]);

  if (p0) {
    var normal = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianCross"])(equatorial, normal);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["cartesianNormalizeInPlace"])(inflection);
    inflection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_2__["spherical"])(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"] * sign,
        phii,
        antimeridian = Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180;

    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math__WEBPACK_IMPORTED_MODULE_3__["degrees"];
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    boundsPoint(lambda, phi);
  }

  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }

  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area__WEBPACK_IMPORTED_MODULE_1__["areaStream"].lineEnd();
  if (Object(_math__WEBPACK_IMPORTED_MODULE_3__["abs"])(deltaSum) > _math__WEBPACK_IMPORTED_MODULE_3__["epsilon"]) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
} // Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.


function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ __webpack_exports__["default"] = (function (feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  Object(_stream__WEBPACK_IMPORTED_MODULE_4__["default"])(feature, boundsStream); // First, sort ranges by their minimum longitudes.

  if (n = ranges.length) {
    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.

    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];

      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    } // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.


    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;
  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
});

/***/ }),

/***/ "./node_modules/d3-geo/src/cartesian.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/cartesian.js ***!
  \**********************************************/
/*! exports provided: spherical, cartesian, cartesianDot, cartesianCross, cartesianAddInPlace, cartesianScale, cartesianNormalizeInPlace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spherical", function() { return spherical; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesian", function() { return cartesian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianDot", function() { return cartesianDot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianCross", function() { return cartesianCross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianAddInPlace", function() { return cartesianAddInPlace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianScale", function() { return cartesianScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cartesianNormalizeInPlace", function() { return cartesianNormalizeInPlace; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

function spherical(cartesian) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(cartesian[1], cartesian[0]), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(cartesian[2])];
}
function cartesian(spherical) {
  var lambda = spherical[0],
      phi = spherical[1],
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  return [cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // TODO return a

function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
} // TODO return d

function cartesianNormalizeInPlace(d) {
  var l = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");



var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_1__["default"],
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function polygonStart() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function polygonEnd() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
}; // Arithmetic mean of Cartesian vectors.

function centroidPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  centroidPointCartesian(cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda), cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      w = Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).


function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  centroidStream.point = centroidRingPoint;
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi);
  x0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda);
  y0 = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda);
  z0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_0__["radians"];
  var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi),
      x = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(lambda),
      y = cosPhi * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(lambda),
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(cx * cx + cy * cy + cz * cz),
      u = x0 * x + y0 * y + z0 * z,
      v = m && -Object(_math__WEBPACK_IMPORTED_MODULE_0__["acos"])(u) / m,
      // area weight
  w = Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(m, u); // line weight

  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  Object(_stream__WEBPACK_IMPORTED_MODULE_2__["default"])(object, centroidStream);
  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z; // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.

  if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) {
    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.

    if (W1 < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z; // If the feature still has an undefined ccentroid, then return.

    if (m < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon2"]) return [NaN, NaN];
  }

  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(m)) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
});

/***/ }),

/***/ "./node_modules/d3-geo/src/circle.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/circle.js ***!
  \*******************************************/
/*! exports provided: circleStream, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleStream", function() { return circleStream; });
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation */ "./node_modules/d3-geo/src/rotation.js");



 // Generates a circle centered at [0°, 0°], with a given radius and precision.

function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      sinRadius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(radius),
      step = direction * delta;

  if (t0 == null) {
    t0 = radius + direction * _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
  }

  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])([cosRadius, -sinRadius * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(t), -sinRadius * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(t)]);
    stream.point(point[0], point[1]);
  }
} // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].

function circleRadius(cosRadius, point) {
  point = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(point), point[0] -= cosRadius;
  Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianNormalizeInPlace"])(point);
  var radius = Object(_math__WEBPACK_IMPORTED_MODULE_2__["acos"])(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math__WEBPACK_IMPORTED_MODULE_2__["tau"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) % _math__WEBPACK_IMPORTED_MODULE_2__["tau"];
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var center = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([0, 0]),
      radius = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(90),
      precision = Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(6),
      ring,
      rotate,
      stream = {
    point: point
  };

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math__WEBPACK_IMPORTED_MODULE_2__["degrees"], x[1] *= _math__WEBPACK_IMPORTED_MODULE_2__["degrees"];
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__["radians"],
        p = precision.apply(this, arguments) * _math__WEBPACK_IMPORTED_MODULE_2__["radians"];
    ring = [];
    rotate = Object(_rotation__WEBPACK_IMPORTED_MODULE_3__["rotateRadians"])(-c[0] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], -c[1] * _math__WEBPACK_IMPORTED_MODULE_2__["radians"], 0).invert;
    circleStream(stream, r, p, 1);
    c = {
      type: "Polygon",
      coordinates: [ring]
    };
    ring = rotate = null;
    return c;
  }

  circle.center = function (_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : radius;
  };

  circle.precision = function (_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_1__["default"])(+_), circle) : precision;
  };

  return circle;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/antimeridian.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/antimeridian.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(function () {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]])); // Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.

function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      _clean; // no intersections


  return {
    lineStart: function lineStart() {
      stream.lineStart();
      _clean = 1;
    },
    point: function point(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"],
          delta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - lambda0);

      if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(delta - _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
        // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        _clean = 0;
      } else if (sign0 !== sign1 && delta >= _math__WEBPACK_IMPORTED_MODULE_1__["pi"]) {
        // line crosses antimeridian
        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - sign0) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda0 -= sign0 * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]; // handle degeneracies

        if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda1 - sign1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) lambda1 -= sign1 * _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        _clean = 0;
      }

      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function lineEnd() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function clean() {
      return 2 - _clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0 - lambda1);
  return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(sinLambda0Lambda1) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])((Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi0) * (cosPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi1)) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda1) - Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi1) * (cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi0)) * Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;

  if (from == null) {
    phi = direction * _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"];
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(0, phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(0, -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], -phi);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], 0);
    stream.point(-_math__WEBPACK_IMPORTED_MODULE_1__["pi"], phi);
  } else if (Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(from[0] - to[0]) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]) {
    var lambda = from[0] < to[0] ? _math__WEBPACK_IMPORTED_MODULE_1__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_1__["pi"];
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var lines = [],
      line;
  return {
    point: function point(x, y) {
      line.push([x, y]);
    },
    lineStart: function lineStart() {
      lines.push(line = []);
    },
    lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
    rejoin: function rejoin() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function result() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/circle.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/circle.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle */ "./node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/clip/index.js");





/* harmony default export */ __webpack_exports__["default"] = (function (radius, delta) {
  var cr = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(radius),
      smallRadius = cr > 0,
      notHemisphere = Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(cr) > _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    Object(_circle__WEBPACK_IMPORTED_MODULE_1__["circleStream"])(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi) > cr;
  } // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.


  function clipLine(stream) {
    var point0, // previous point
    c0, // code for previous point
    v0, // visibility of previous point
    v00, // visibility of first point
    _clean; // no intersections


    return {
      lineStart: function lineStart() {
        v00 = v0 = false;
        _clean = 1;
      },
      point: function point(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math__WEBPACK_IMPORTED_MODULE_2__["pi"] : -_math__WEBPACK_IMPORTED_MODULE_2__["pi"]), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.
        // TODO ignore if not clipping polygons.

        if (v !== v0) {
          point2 = intersect(point0, point1);

          if (Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point2) || Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point1, point2)) {
            point1[0] += _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
            point1[1] += _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
            v = visible(point1[0], point1[1]);
          }
        }

        if (v !== v0) {
          _clean = 0;

          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }

          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t; // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.

          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            _clean = 0;

            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }

        if (v && (!point0 || !Object(_pointEqual__WEBPACK_IMPORTED_MODULE_3__["default"])(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }

        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function lineEnd() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function clean() {
        return _clean | (v00 && v0) << 1;
      }
    };
  } // Intersects the great circle between a and b with the clip circle.


  function intersect(a, b, two) {
    var pa = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(a),
        pb = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])(b); // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).

    var n1 = [1, 0, 0],
        // normal
    n2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(pa, pb),
        n2n2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(n2, n2),
        n1n2 = n2[0],
        // cartesianDot(n1, n2),
    determinant = n2n2 - n1n2 * n1n2; // Two polar points.

    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianCross"])(n1, n2),
        A = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n1, c1),
        B = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(n2, c2);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(A, B); // Solve |p(t)|^2 = 1.

    var u = n1xn2,
        w = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, u),
        uu = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(u, u),
        t2 = w * w - uu * (Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianDot"])(A, A) - 1);
    if (t2 < 0) return;
    var t = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sqrt"])(t2),
        q = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w - t) / uu);
    Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q, A);
    q = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q);
    if (!two) return q; // Two intersection points.

    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta = lambda1 - lambda0,
        polar = Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(delta - _math__WEBPACK_IMPORTED_MODULE_2__["pi"]) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"],
        meridian = polar || delta < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"];
    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.

    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (Object(_math__WEBPACK_IMPORTED_MODULE_2__["abs"])(q[0] - lambda0) < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math__WEBPACK_IMPORTED_MODULE_2__["pi"] ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianScale"])(u, (-w + t) / uu);
      Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesianAddInPlace"])(q1, A);
      return [q, Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["spherical"])(q1)];
    }
  } // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.


  function code(lambda, phi) {
    var r = smallRadius ? radius : _math__WEBPACK_IMPORTED_MODULE_2__["pi"] - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right

    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above

    return code;
  }

  return Object(_index__WEBPACK_IMPORTED_MODULE_4__["default"])(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math__WEBPACK_IMPORTED_MODULE_2__["pi"], radius - _math__WEBPACK_IMPORTED_MODULE_2__["pi"]]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/extent.js ***!
  \************************************************/
/*! exports provided: clipExtent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clipExtent", function() { return clipExtent; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polygon */ "./node_modules/d3-geo/src/clip/polygon.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");





var clipMax = 1e9,
    clipMin = -clipMax; // TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipExtent(x0, y0, x1, y1) {
  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0,
        a1 = 0;

    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do {
        stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      } while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 0 : 3 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[0] - x1) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 2 : 1 : Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(p[1] - y0) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }

  return function (stream) {
    var activeStream = stream,
        bufferStream = Object(_buffer__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        segments,
        polygon,
        ring,
        x__,
        y__,
        v__,
        // first point
    x_,
        y_,
        v_,
        // previous point
    first,
        clean;
    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];

          if (a1 <= y1) {
            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
          } else {
            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
          }
        }
      }

      return winding;
    } // Buffer geometry within a polygon and then clip it en masse.


    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments)).length;

      if (cleanInside || visible) {
        stream.polygonStart();

        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }

        if (visible) {
          Object(_polygon__WEBPACK_IMPORTED_MODULE_3__["default"])(segments, compareIntersection, startInside, interpolate, stream);
        }

        stream.polygonEnd();
      }

      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    } // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.


    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }

      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);

      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;

        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];

          if (Object(_line__WEBPACK_IMPORTED_MODULE_2__["default"])(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }

            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }

      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;
  return clip = {
    stream: function stream(_stream) {
      return cache && cacheStream === _stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = _stream);
    },
    extent: function extent(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygon */ "./node_modules/d3-geo/src/clip/polygon.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polygonContains */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");





/* harmony default export */ __webpack_exports__["default"] = (function (pointVisible, clipLine, interpolate, start) {
  return function (rotate, sink) {
    var line = clipLine(sink),
        rotatedStart = rotate.invert(start[0], start[1]),
        ringBuffer = Object(_buffer__WEBPACK_IMPORTED_MODULE_0__["default"])(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;
    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function polygonEnd() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = Object(d3_array__WEBPACK_IMPORTED_MODULE_4__["merge"])(segments);
        var startInside = Object(_polygonContains__WEBPACK_IMPORTED_MODULE_3__["default"])(polygon, rotatedStart);

        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          Object(_polygon__WEBPACK_IMPORTED_MODULE_1__["default"])(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }

        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function sphere() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      var point = rotate(lambda, phi);
      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      var point = rotate(lambda, phi);
      line.point(point[0], point[1]);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      var point = rotate(lambda, phi);
      ringSink.point(point[0], point[1]);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i,
          n = ringSegments.length,
          m,
          segment,
          point;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return; // No intersections.

      if (clean & 1) {
        segment = ringSegments[0];

        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();

          for (i = 0; i < m; ++i) {
            sink.point((point = segment[i])[0], point[1]);
          }

          sink.lineEnd();
        }

        return;
      } // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?


      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
});

function validSegment(segment) {
  return segment.length > 1;
} // Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.


function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] : _math__WEBPACK_IMPORTED_MODULE_2__["halfPi"] - b[1]);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/clip/polygon.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/polygon.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pointEqual__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual */ "./node_modules/d3-geo/src/pointEqual.js");


function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection

  this.e = entry; // is an entry?

  this.v = false; // visited

  this.n = this.p = null; // next & previous
} // A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.


/* harmony default export */ __webpack_exports__["default"] = (function (segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;
  segments.forEach(function (segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n,
        p0 = segment[0],
        p1 = segment[n],
        x; // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.

    if (Object(_pointEqual__WEBPACK_IMPORTED_MODULE_0__["default"])(p0, p1)) {
      stream.lineStart();

      for (i = 0; i < n; ++i) {
        stream.point((p0 = segment[i])[0], p0[1]);
      }

      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;

    while (current.v) {
      if ((current = current.n) === start) return;
    }

    points = current.z;
    stream.lineStart();

    do {
      current.v = current.o.v = true;

      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }

        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;

          for (i = points.length - 1; i >= 0; --i) {
            stream.point((point = points[i])[0], point[1]);
          }
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }

        current = current.p;
      }

      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);

    stream.lineEnd();
  }
});

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;

  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }

  a.n = b = array[0];
  b.p = a;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/compose.js":
/*!********************************************!*\
  !*** ./node_modules/d3-geo/src/compose.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function (x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/constant.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/constant.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/distance.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/distance.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _length__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./length */ "./node_modules/d3-geo/src/length.js");

var coordinates = [null, null],
    object = {
  type: "LineString",
  coordinates: coordinates
};
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return Object(_length__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/*! exports provided: default, graticule10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return graticule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "graticule10", function() { return graticule10; });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(y0, y1 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dy).concat(y1);
  return function (x) {
    return y.map(function (y) {
      return [x, y];
    });
  };
}

function graticuleY(x0, x1, dx) {
  var x = Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(x0, x1 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"], dx).concat(x1);
  return function (y) {
    return x.map(function (x) {
      return [x, y];
    });
  };
}

function graticule() {
  var x1,
      x0,
      X1,
      X0,
      y1,
      y0,
      Y1,
      Y0,
      dx = 10,
      dy = dx,
      DX = 90,
      DY = 360,
      x,
      y,
      X,
      Y,
      precision = 2.5;

  function graticule() {
    return {
      type: "MultiLineString",
      coordinates: lines()
    };
  }

  function lines() {
    return Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(X0 / DX) * DX, X1, DX).map(X).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(Y0 / DY) * DY, Y1, DY).map(Y)).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(x0 / dx) * dx, x1, dx).filter(function (x) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(x % DX) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
    }).map(x)).concat(Object(d3_array__WEBPACK_IMPORTED_MODULE_0__["range"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["ceil"])(y0 / dy) * dy, y1, dy).filter(function (y) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(y % DY) > _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"];
    }).map(y));
  }

  graticule.lines = function () {
    return lines().map(function (coordinates) {
      return {
        type: "LineString",
        coordinates: coordinates
      };
    });
  };

  graticule.outline = function () {
    return {
      type: "Polygon",
      coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
    };
  };

  graticule.extent = function (_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function (_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function (_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function (_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function (_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function (_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function (_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule.extentMajor([[-180, -90 + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 90 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]]).extentMinor([[-180, -80 - _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]], [180, 80 + _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"]]]);
}
function graticule10() {
  return graticule()();
}

/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/interpolate.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/interpolate.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var x0 = a[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y0 = a[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      x1 = b[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      y1 = b[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"],
      cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      sy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0),
      cy1 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1),
      sy1 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1),
      kx0 = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x0),
      ky0 = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x0),
      kx1 = cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x1),
      ky1 = cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x1),
      d = 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["haversin"])(y1 - y0) + cy0 * cy1 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["haversin"])(x1 - x0))),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(d);
  var interpolate = d ? function (t) {
    var B = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(t *= d) / k,
        A = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(y, x) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(z, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y)) * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  } : function () {
    return [x0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], y0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };
  interpolate.distance = d;
  return interpolate;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/length.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/length.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./noop */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream */ "./node_modules/d3-geo/src/stream.js");




var lengthSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    lambda0,
    sinPhi0,
    cosPhi0;
var lengthStream = {
  sphere: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: lengthLineStart,
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"]
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
}

function lengthPointFirst(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  lambda0 = lambda, sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi), cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"], phi *= _math__WEBPACK_IMPORTED_MODULE_1__["radians"];
  var sinPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
      cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
      delta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda - lambda0),
      cosDelta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(delta),
      sinDelta = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

/* harmony default export */ __webpack_exports__["default"] = (function (object) {
  lengthSum.reset();
  Object(_stream__WEBPACK_IMPORTED_MODULE_3__["default"])(object, lengthStream);
  return +lengthSum;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/*! exports provided: epsilon, epsilon2, pi, halfPi, quarterPi, tau, degrees, radians, abs, atan, atan2, cos, ceil, exp, floor, log, pow, sin, sign, sqrt, tan, acos, asin, haversin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon", function() { return epsilon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "epsilon2", function() { return epsilon2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pi", function() { return pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPi", function() { return halfPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quarterPi", function() { return quarterPi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tau", function() { return tau; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2", function() { return atan2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "haversin", function() { return haversin; });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt = Math.sqrt;
var tan = Math.tan;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function haversin(x) {
  return (x = sin(x / 2)) * x;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return noop; });
function noop() {}

/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");



var areaSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    areaRingSum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])(),
    x00,
    y00,
    x0,
    y0;
var areaStream = {
  point: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_2__["default"],
  polygonStart: function polygonStart() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function polygonEnd() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop__WEBPACK_IMPORTED_MODULE_2__["default"];
    areaSum.add(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(areaRingSum));
    areaRingSum.reset();
  },
  result: function result() {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ __webpack_exports__["default"] = (areaStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");

var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  lineEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonStart: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  polygonEnd: _noop__WEBPACK_IMPORTED_MODULE_0__["default"],
  result: function result() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ __webpack_exports__["default"] = (boundsStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
 // TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function polygonStart() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function polygonEnd() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function result() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ __webpack_exports__["default"] = (centroidStream);

/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathContext; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop */ "./node_modules/d3-geo/src/noop.js");


function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function pointRadius(_) {
    return this._radius = _, this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._context.moveTo(x, y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._context.lineTo(x, y);

          break;
        }

      default:
        {
          this._context.moveTo(x + this._radius, y);

          this._context.arc(x, y, this._radius, 0, _math__WEBPACK_IMPORTED_MODULE_0__["tau"]);

          break;
        }
    }
  },
  result: _noop__WEBPACK_IMPORTED_MODULE_1__["default"]
};

/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./area */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./context */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string */ "./node_modules/d3-geo/src/path/string.js");







/* harmony default export */ __webpack_exports__["default"] = (function (projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(contextStream));
    }

    return contextStream.result();
  }

  path.area = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_area__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _area__WEBPACK_IMPORTED_MODULE_2__["default"].result();
  };

  path.bounds = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_bounds__WEBPACK_IMPORTED_MODULE_3__["default"]));
    return _bounds__WEBPACK_IMPORTED_MODULE_3__["default"].result();
  };

  path.centroid = function (object) {
    Object(_stream__WEBPACK_IMPORTED_MODULE_1__["default"])(object, projectionStream(_centroid__WEBPACK_IMPORTED_MODULE_4__["default"]));
    return _centroid__WEBPACK_IMPORTED_MODULE_4__["default"].result();
  };

  path.projection = function (_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity__WEBPACK_IMPORTED_MODULE_0__["default"]) : (projection = _).stream, path) : projection;
  };

  path.context = function (_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string__WEBPACK_IMPORTED_MODULE_6__["default"]()) : new _context__WEBPACK_IMPORTED_MODULE_5__["default"](context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function (_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathString; });
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _circle: circle(4.5),
  pointRadius: function pointRadius(_) {
    return this._circle = circle(_), this;
  },
  polygonStart: function polygonStart() {
    this._line = 0;
  },
  polygonEnd: function polygonEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function point(x, y) {
    switch (this._point) {
      case 0:
        {
          this._string.push("M", x, ",", y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._string.push("L", x, ",", y);

          break;
        }

      default:
        {
          this._string.push("M", x, ",", y, this._circle);

          break;
        }
    }
  },
  result: function result() {
    if (this._string.length) {
      var result = this._string.join("");

      this._string = [];
      return result;
    }
  }
};

function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[0] - b[0]) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"] && Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(a[1] - b[1]) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
});

/***/ }),

/***/ "./node_modules/d3-geo/src/polygonContains.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo/src/polygonContains.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _adder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adder */ "./node_modules/d3-geo/src/adder.js");
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



var sum = Object(_adder__WEBPACK_IMPORTED_MODULE_0__["default"])();
/* harmony default export */ __webpack_exports__["default"] = (function (polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(lambda), -Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(lambda), 0],
      angle = 0,
      winding = 0;
  sum.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
        sinPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi0),
        cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + _math__WEBPACK_IMPORTED_MODULE_2__["quarterPi"],
          sinPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(phi1),
          cosPhi1 = Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math__WEBPACK_IMPORTED_MODULE_2__["pi"],
          k = sinPhi0 * sinPhi1;
      sum.add(Object(_math__WEBPACK_IMPORTED_MODULE_2__["atan2"])(k * sign * Object(_math__WEBPACK_IMPORTED_MODULE_2__["sin"])(absDelta), cosPhi0 * cosPhi1 + k * Object(_math__WEBPACK_IMPORTED_MODULE_2__["cos"])(absDelta)));
      angle += antimeridian ? delta + sign * _math__WEBPACK_IMPORTED_MODULE_2__["tau"] : delta; // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?

      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point0), Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesian"])(point1));
        Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(arc);
        var intersection = Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianCross"])(normal, arc);
        Object(_cartesian__WEBPACK_IMPORTED_MODULE_1__["cartesianNormalizeInPlace"])(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * Object(_math__WEBPACK_IMPORTED_MODULE_2__["asin"])(intersection[2]);

        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  } // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.


  return (angle < -_math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] || angle < _math__WEBPACK_IMPORTED_MODULE_2__["epsilon"] && sum < -_math__WEBPACK_IMPORTED_MODULE_2__["epsilon"]) ^ winding & 1;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albers.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albers.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_0__["default"])().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albersUsa.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albersUsa.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _albers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./albers */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _conicEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conicEqualArea */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");



 // The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.

function multiplex(streams) {
  var n = streams.length;
  return {
    point: function point(x, y) {
      var i = -1;

      while (++i < n) {
        streams[i].point(x, y);
      }
    },
    sphere: function sphere() {
      var i = -1;

      while (++i < n) {
        streams[i].sphere();
      }
    },
    lineStart: function lineStart() {
      var i = -1;

      while (++i < n) {
        streams[i].lineStart();
      }
    },
    lineEnd: function lineEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].lineEnd();
      }
    },
    polygonStart: function polygonStart() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonStart();
      }
    },
    polygonEnd: function polygonEnd() {
      var i = -1;

      while (++i < n) {
        streams[i].polygonEnd();
      }
    }
  };
} // A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers


/* harmony default export */ __webpack_exports__["default"] = (function () {
  var cache,
      cacheStream,
      lower48 = Object(_albers__WEBPACK_IMPORTED_MODULE_1__["default"])(),
      lower48Point,
      alaska = Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      alaskaPoint,
      // EPSG:3338
  hawaii = Object(_conicEqualArea__WEBPACK_IMPORTED_MODULE_2__["default"])().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      hawaiiPoint,
      // ESRI:102007
  _point,
      pointStream = {
    point: function point(x, y) {
      _point = [x, y];
    }
  };

  function albersUsa(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    return _point = null, (lower48Point.point(x, y), _point) || (alaskaPoint.point(x, y), _point) || (hawaiiPoint.point(x, y), _point);
  }

  albersUsa.invert = function (coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };

  albersUsa.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function (_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function (_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function (_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(),
        x = +_[0],
        y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.120 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.214 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.166 * k + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]], [x - 0.115 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"], y + 0.234 * k - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]]]).stream(pointStream);
    return reset();
  };

  albersUsa.fitExtent = function (extent, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(albersUsa, extent, object);
  };

  albersUsa.fitSize = function (size, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(albersUsa, size, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthal.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*********************************************************/
/*! exports provided: azimuthalRaw, azimuthalInvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalRaw", function() { return azimuthalRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalInvert", function() { return azimuthalInvert; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");

function azimuthalRaw(scale) {
  return function (x, y) {
    var cx = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x),
        cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
        k = scale(cx * cy);
    return [k * cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x), k * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)];
  };
}
function azimuthalInvert(angle) {
  return function (x, y) {
    var z = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + y * y),
        c = angle(z),
        sc = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(c),
        cc = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(c);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x * sc, z * cc), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z && y * sc / z)];
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \******************************************************************/
/*! exports provided: azimuthalEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEqualAreaRaw", function() { return azimuthalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



var azimuthalEqualAreaRaw = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function (cxcy) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(z / 2);
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \********************************************************************/
/*! exports provided: azimuthalEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthalEquidistantRaw", function() { return azimuthalEquidistantRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



var azimuthalEquidistantRaw = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalRaw"])(function (c) {
  return (c = Object(_math__WEBPACK_IMPORTED_MODULE_0__["acos"])(c)) && c / Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(c);
});
azimuthalEquidistantRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return z;
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conic.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conic.js ***!
  \*****************************************************/
/*! exports provided: conicProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicProjection", function() { return conicProjection; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");


function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math__WEBPACK_IMPORTED_MODULE_0__["pi"] / 3,
      m = Object(_index__WEBPACK_IMPORTED_MODULE_1__["projectionMutator"])(projectAt),
      p = m(phi0, phi1);

  p.parallels = function (_) {
    return arguments.length ? m(phi0 = _[0] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"], phi1 = _[1] * _math__WEBPACK_IMPORTED_MODULE_0__["radians"]) : [phi0 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"], phi1 * _math__WEBPACK_IMPORTED_MODULE_0__["degrees"]];
  };

  return p;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicConformal.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicConformal.js ***!
  \**************************************************************/
/*! exports provided: conicConformalRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicConformalRaw", function() { return conicConformalRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo/src/projection/mercator.js");




function tany(y) {
  return Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(cy0 / Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(tany(y1) / tany(y0)),
      f = cy0 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y0), n) / n;
  if (!n) return _mercator__WEBPACK_IMPORTED_MODULE_2__["mercatorRaw"];

  function project(x, y) {
    if (f > 0) {
      if (y < -_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = -_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
    } else {
      if (y > _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) y = _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] - _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"];
    }

    var r = f / Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(tany(y), n);
    return [r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(n * x), f - r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(n * x)];
  }

  project.invert = function (x, y) {
    var fy = f - y,
        r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + fy * fy);
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(fy)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(fy), 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["pow"])(f / r, 1 / n)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicConformalRaw).scale(109.5).parallels([30, 30]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEqualArea.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \**************************************************************/
/*! exports provided: conicEqualAreaRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEqualAreaRaw", function() { return conicEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cylindricalEqualArea */ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js");



function conicEqualAreaRaw(y0, y1) {
  var sy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0),
      n = (sy0 + Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y1)) / 2; // Are the parallels symmetrical around the Equator?

  if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return Object(_cylindricalEqualArea__WEBPACK_IMPORTED_MODULE_2__["cylindricalEqualAreaRaw"])(y0);
  var c = 1 + sy0 * (2 * n - sy0),
      r0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c) / n;

  function project(x, y) {
    var r = Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(c - 2 * n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)) / n;
    return [r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x *= n), r0 - r * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x)];
  }

  project.invert = function (x, y) {
    var r0y = r0 - y;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(r0y)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(r0y), Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEquidistant.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \****************************************************************/
/*! exports provided: conicEquidistantRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conicEquidistantRaw", function() { return conicEquidistantRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conic */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _equirectangular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./equirectangular */ "./node_modules/d3-geo/src/projection/equirectangular.js");



function conicEquidistantRaw(y0, y1) {
  var cy0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y0),
      n = y0 === y1 ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y0) : (cy0 - Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y1)) / (y1 - y0),
      g = cy0 / n + y0;
  if (Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(n) < _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]) return _equirectangular__WEBPACK_IMPORTED_MODULE_2__["equirectangularRaw"];

  function project(x, y) {
    var gy = g - y,
        nx = n * x;
    return [gy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(nx), g - gy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(nx)];
  }

  project.invert = function (x, y) {
    var gy = g - y;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan2"])(x, Object(_math__WEBPACK_IMPORTED_MODULE_0__["abs"])(gy)) / n * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(gy), g - Object(_math__WEBPACK_IMPORTED_MODULE_0__["sign"])(n) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sqrt"])(x * x + gy * gy)];
  };

  return project;
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_conic__WEBPACK_IMPORTED_MODULE_1__["conicProjection"])(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \********************************************************************/
/*! exports provided: cylindricalEqualAreaRaw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cylindricalEqualAreaRaw", function() { return cylindricalEqualAreaRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, Object(_math__WEBPACK_IMPORTED_MODULE_0__["asin"])(y * cosPhi0)];
  };

  return forward;
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/equirectangular.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/equirectangular.js ***!
  \***************************************************************/
/*! exports provided: equirectangularRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equirectangularRaw", function() { return equirectangularRaw; });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(equirectangularRaw).scale(152.63);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/*! exports provided: fitExtent, fitSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitExtent", function() { return fitExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fitSize", function() { return fitSize; });
/* harmony import */ var _stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds */ "./node_modules/d3-geo/src/path/bounds.js");


function fitExtent(projection, extent, object) {
  var w = extent[1][0] - extent[0][0],
      h = extent[1][1] - extent[0][1],
      clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  Object(_stream__WEBPACK_IMPORTED_MODULE_0__["default"])(object, projection.stream(_path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"]));
  var b = _path_bounds__WEBPACK_IMPORTED_MODULE_1__["default"].result(),
      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
  if (clip != null) projection.clipExtent(clip);
  return projection.scale(k * 150).translate([x, y]);
}
function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/gnomonic.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/gnomonic.js ***!
  \********************************************************/
/*! exports provided: gnomonicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gnomonicRaw", function() { return gnomonicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function gnomonicRaw(x, y) {
  var cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
      k = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}
gnomonicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math__WEBPACK_IMPORTED_MODULE_0__["atan"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(gnomonicRaw).scale(144.049).clipAngle(60);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _clip_extent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/extent */ "./node_modules/d3-geo/src/clip/extent.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");





function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? _identity__WEBPACK_IMPORTED_MODULE_1__["default"] : Object(_transform__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
    point: function point(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var k = 1,
      tx = 0,
      ty = 0,
      sx = 1,
      sy = 1,
      transform = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      // scale, translate and reflect
  x0 = null,
      y0,
      x1,
      y1,
      clip = _identity__WEBPACK_IMPORTED_MODULE_1__["default"],
      // clip extent
  cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function stream(_stream) {
      return cache && cacheStream === _stream ? cache : cache = transform(clip(cacheStream = _stream));
    },
    clipExtent: function clipExtent(_) {
      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_1__["default"]) : Object(_clip_extent__WEBPACK_IMPORTED_MODULE_0__["clipExtent"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function scale(_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function translate(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function reflectX(_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function reflectY(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function fitExtent(extent, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitExtent"])(projection, extent, object);
    },
    fitSize: function fitSize(size, object) {
      return Object(_fit__WEBPACK_IMPORTED_MODULE_3__["fitSize"])(projection, size, object);
    }
  };
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/index.js ***!
  \*****************************************************/
/*! exports provided: default, projectionMutator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectionMutator", function() { return projectionMutator; });
/* harmony import */ var _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../clip/antimeridian */ "./node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../clip/circle */ "./node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_extent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/extent */ "./node_modules/d3-geo/src/clip/extent.js");
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../compose */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../identity */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../rotation */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fit */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resample */ "./node_modules/d3-geo/src/projection/resample.js");










var transformRadians = Object(_transform__WEBPACK_IMPORTED_MODULE_7__["transformer"])({
  point: function point(x, y) {
    this.stream.point(x * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], y * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]);
  }
});
function projection(project) {
  return projectionMutator(function () {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project,
      k = 150,
      // scale
  x = 480,
      y = 250,
      // translate
  dx,
      dy,
      lambda = 0,
      phi = 0,
      // center
  deltaLambda = 0,
      deltaPhi = 0,
      deltaGamma = 0,
      rotate,
      projectRotate,
      // rotate
  theta = null,
      preclip = _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"],
      // clip angle
  x0 = null,
      y0,
      x1,
      y1,
      postclip = _identity__WEBPACK_IMPORTED_MODULE_4__["default"],
      // clip extent
  delta2 = 0.5,
      projectResample = Object(_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2),
      // precision
  cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], point[1] * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], point[1] * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
  };

  projection.clipAngle = function (_) {
    return arguments.length ? (preclip = +_ ? Object(_clip_circle__WEBPACK_IMPORTED_MODULE_1__["default"])(theta = _ * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], 6 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"]) : (theta = null, _clip_antimeridian__WEBPACK_IMPORTED_MODULE_0__["default"]), reset()) : theta * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"];
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity__WEBPACK_IMPORTED_MODULE_4__["default"]) : Object(_clip_extent__WEBPACK_IMPORTED_MODULE_2__["clipExtent"])(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function (_) {
    return arguments.length ? (lambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], phi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], recenter()) : [lambda * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], phi * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.rotate = function (_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaPhi = _[1] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"], deltaGamma = _.length > 2 ? _[2] % 360 * _math__WEBPACK_IMPORTED_MODULE_5__["radians"] : 0, recenter()) : [deltaLambda * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaPhi * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"], deltaGamma * _math__WEBPACK_IMPORTED_MODULE_5__["degrees"]];
  };

  projection.precision = function (_) {
    return arguments.length ? (projectResample = Object(_resample__WEBPACK_IMPORTED_MODULE_9__["default"])(projectTransform, delta2 = _ * _), reset()) : Object(_math__WEBPACK_IMPORTED_MODULE_5__["sqrt"])(delta2);
  };

  projection.fitExtent = function (extent, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitExtent"])(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return Object(_fit__WEBPACK_IMPORTED_MODULE_8__["fitSize"])(projection, size, object);
  };

  function recenter() {
    projectRotate = Object(_compose__WEBPACK_IMPORTED_MODULE_3__["default"])(rotate = Object(_rotation__WEBPACK_IMPORTED_MODULE_6__["rotateRadians"])(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function () {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/mercator.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/mercator.js ***!
  \********************************************************/
/*! exports provided: mercatorRaw, default, mercatorProjection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorRaw", function() { return mercatorRaw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mercatorProjection", function() { return mercatorProjection; });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");


function mercatorRaw(lambda, phi) {
  return [lambda, Object(_math__WEBPACK_IMPORTED_MODULE_1__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["tan"])((_math__WEBPACK_IMPORTED_MODULE_1__["halfPi"] + phi) / 2))];
}

mercatorRaw.invert = function (x, y) {
  return [x, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["exp"])(y)) - _math__WEBPACK_IMPORTED_MODULE_1__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return mercatorProjection(mercatorRaw).scale(961 / _math__WEBPACK_IMPORTED_MODULE_1__["tau"]);
});
function mercatorProjection(project) {
  var m = Object(_index__WEBPACK_IMPORTED_MODULE_0__["default"])(project),
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      clipAuto;

  m.scale = function (_) {
    return arguments.length ? (scale(_), clipAuto && m.clipExtent(null), m) : scale();
  };

  m.translate = function (_) {
    return arguments.length ? (translate(_), clipAuto && m.clipExtent(null), m) : translate();
  };

  m.clipExtent = function (_) {
    if (!arguments.length) return clipAuto ? null : clipExtent();

    if (clipAuto = _ == null) {
      var k = _math__WEBPACK_IMPORTED_MODULE_1__["pi"] * scale(),
          t = translate();
      _ = [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]];
    }

    clipExtent(_);
    return m;
  };

  return m.clipExtent(null);
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/orthographic.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/orthographic.js ***!
  \************************************************************/
/*! exports provided: orthographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthographicRaw", function() { return orthographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function orthographicRaw(x, y) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y) * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x), Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y)];
}
orthographicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(_math__WEBPACK_IMPORTED_MODULE_0__["asin"]);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(orthographicRaw).scale(249.5).clipAngle(90 + _math__WEBPACK_IMPORTED_MODULE_0__["epsilon"]);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/resample.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/resample.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _cartesian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cartesian */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transform */ "./node_modules/d3-geo/src/transform.js");



var maxDepth = 16,
    // maximum depth of subdivision
cosMinDistance = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(30 * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]); // cos(minimum angular distance)

/* harmony default export */ __webpack_exports__["default"] = (function (project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
});

function resampleNone(project) {
  return Object(_transform__WEBPACK_IMPORTED_MODULE_2__["transformer"])({
    point: function point(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {
  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;

    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sqrt"])(a * a + b * b + c * c),
          phi2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(c /= m),
          lambda2 = Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(c) - 1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])(lambda0 - lambda1) < _math__WEBPACK_IMPORTED_MODULE_1__["epsilon"] ? (lambda0 + lambda1) / 2 : Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;

      if (dz * dz / d2 > delta2 // perpendicular projected distance
      || Object(_math__WEBPACK_IMPORTED_MODULE_1__["abs"])((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }

  return function (stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
    lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function polygonStart() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function polygonEnd() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = Object(_cartesian__WEBPACK_IMPORTED_MODULE_0__["cartesian"])([lambda, phi]),
          p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/stereographic.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/stereographic.js ***!
  \*************************************************************/
/*! exports provided: stereographicRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stereographicRaw", function() { return stereographicRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index */ "./node_modules/d3-geo/src/projection/index.js");



function stereographicRaw(x, y) {
  var cy = Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(y),
      k = 1 + Object(_math__WEBPACK_IMPORTED_MODULE_0__["cos"])(x) * cy;
  return [cy * Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(x) / k, Object(_math__WEBPACK_IMPORTED_MODULE_0__["sin"])(y) / k];
}
stereographicRaw.invert = Object(_azimuthal__WEBPACK_IMPORTED_MODULE_1__["azimuthalInvert"])(function (z) {
  return 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(z);
});
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return Object(_index__WEBPACK_IMPORTED_MODULE_2__["default"])(stereographicRaw).scale(250).clipAngle(142);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/projection/transverseMercator.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \******************************************************************/
/*! exports provided: transverseMercatorRaw, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transverseMercatorRaw", function() { return transverseMercatorRaw; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator */ "./node_modules/d3-geo/src/projection/mercator.js");


function transverseMercatorRaw(lambda, phi) {
  return [Object(_math__WEBPACK_IMPORTED_MODULE_0__["log"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["tan"])((_math__WEBPACK_IMPORTED_MODULE_0__["halfPi"] + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function (x, y) {
  return [-y, 2 * Object(_math__WEBPACK_IMPORTED_MODULE_0__["atan"])(Object(_math__WEBPACK_IMPORTED_MODULE_0__["exp"])(x)) - _math__WEBPACK_IMPORTED_MODULE_0__["halfPi"]];
};

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var m = Object(_mercator__WEBPACK_IMPORTED_MODULE_1__["mercatorProjection"])(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function (_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function (_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90]).scale(159.155);
});

/***/ }),

/***/ "./node_modules/d3-geo/src/rotation.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/rotation.js ***!
  \*********************************************/
/*! exports provided: rotateRadians, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateRadians", function() { return rotateRadians; });
/* harmony import */ var _compose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math__WEBPACK_IMPORTED_MODULE_1__["tau"]) ? deltaPhi || deltaGamma ? Object(_compose__WEBPACK_IMPORTED_MODULE_0__["default"])(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}

function forwardRotationLambda(deltaLambda) {
  return function (lambda, phi) {
    return lambda += deltaLambda, [lambda > _math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda - _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda < -_math__WEBPACK_IMPORTED_MODULE_1__["pi"] ? lambda + _math__WEBPACK_IMPORTED_MODULE_1__["tau"] : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaPhi),
      sinDeltaPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaPhi),
      cosDeltaGamma = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(deltaGamma),
      sinDeltaGamma = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaGamma + y * sinDeltaGamma)];
  }

  rotation.invert = function (lambda, phi) {
    var cosPhi = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(phi),
        x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["cos"])(lambda) * cosPhi,
        y = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(lambda) * cosPhi,
        z = Object(_math__WEBPACK_IMPORTED_MODULE_1__["sin"])(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [Object(_math__WEBPACK_IMPORTED_MODULE_1__["atan2"])(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), Object(_math__WEBPACK_IMPORTED_MODULE_1__["asin"])(k * cosDeltaPhi - x * sinDeltaPhi)];
  };

  return rotation;
}

/* harmony default export */ __webpack_exports__["default"] = (function (rotate) {
  rotate = rotateRadians(rotate[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], rotate.length > 2 ? rotate[2] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"] : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  }

  forward.invert = function (coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"], coordinates[1] * _math__WEBPACK_IMPORTED_MODULE_1__["radians"]);
    return coordinates[0] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates[1] *= _math__WEBPACK_IMPORTED_MODULE_1__["degrees"], coordinates;
  };

  return forward;
});

/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function Feature(feature, stream) {
    streamGeometry(feature.geometry, stream);
  },
  FeatureCollection: function FeatureCollection(object, stream) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) {
      streamGeometry(features[i].geometry, stream);
    }
  }
};
var streamGeometryType = {
  Sphere: function Sphere(object, stream) {
    stream.sphere();
  },
  Point: function Point(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function MultiPoint(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
    }
  },
  LineString: function LineString(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function MultiLineString(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamLine(coordinates[i], stream, 0);
    }
  },
  Polygon: function Polygon(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function MultiPolygon(object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) {
      streamPolygon(coordinates[i], stream);
    }
  },
  GeometryCollection: function GeometryCollection(object, stream) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) {
      streamGeometry(geometries[i], stream);
    }
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1,
      n = coordinates.length - closed,
      coordinate;
  stream.lineStart();

  while (++i < n) {
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  }

  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1,
      n = coordinates.length;
  stream.polygonStart();

  while (++i < n) {
    streamLine(coordinates[i], stream, 1);
  }

  stream.polygonEnd();
}

/* harmony default export */ __webpack_exports__["default"] = (function (object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
});

/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/*! exports provided: default, transformer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformer", function() { return transformer; });
/* harmony default export */ __webpack_exports__["default"] = (function (methods) {
  return {
    stream: transformer(methods)
  };
});
function transformer(methods) {
  return function (stream) {
    var s = new TransformStream();

    for (var key in methods) {
      s[key] = methods[key];
    }

    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function point(x, y) {
    this.stream.point(x, y);
  },
  sphere: function sphere() {
    this.stream.sphere();
  },
  lineStart: function lineStart() {
    this.stream.lineStart();
  },
  lineEnd: function lineEnd() {
    this.stream.lineEnd();
  },
  polygonStart: function polygonStart() {
    this.stream.polygonStart();
  },
  polygonEnd: function polygonEnd() {
    this.stream.polygonEnd();
  }
};

/***/ }),

/***/ "./node_modules/d3-interpolate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-interpolate/index.js ***!
  \**********************************************/
/*! exports provided: interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateNumber, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, quantize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/value */ "./node_modules/d3-interpolate/src/value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return _src_value__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/array */ "./node_modules/d3-interpolate/src/array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return _src_array__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_basis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/basis */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return _src_basis__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_basisClosed__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/basisClosed */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return _src_basisClosed__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_date__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/date */ "./node_modules/d3-interpolate/src/date.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return _src_date__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/number */ "./node_modules/d3-interpolate/src/number.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return _src_number__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/object */ "./node_modules/d3-interpolate/src/object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return _src_object__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_round__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/round */ "./node_modules/d3-interpolate/src/round.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return _src_round__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_string__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/string */ "./node_modules/d3-interpolate/src/string.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return _src_string__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_transform_index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/transform/index */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return _src_transform_index__WEBPACK_IMPORTED_MODULE_9__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return _src_transform_index__WEBPACK_IMPORTED_MODULE_9__["interpolateTransformSvg"]; });

/* harmony import */ var _src_zoom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/zoom */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return _src_zoom__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_rgb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/rgb */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return _src_rgb__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return _src_rgb__WEBPACK_IMPORTED_MODULE_11__["rgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return _src_rgb__WEBPACK_IMPORTED_MODULE_11__["rgbBasisClosed"]; });

/* harmony import */ var _src_hsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/hsl */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return _src_hsl__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return _src_hsl__WEBPACK_IMPORTED_MODULE_12__["hslLong"]; });

/* harmony import */ var _src_lab__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/lab */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return _src_lab__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_hcl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/hcl */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return _src_hcl__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return _src_hcl__WEBPACK_IMPORTED_MODULE_14__["hclLong"]; });

/* harmony import */ var _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/cubehelix */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return _src_cubehelix__WEBPACK_IMPORTED_MODULE_15__["cubehelixLong"]; });

/* harmony import */ var _src_quantize__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/quantize */ "./node_modules/d3-interpolate/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _src_quantize__WEBPACK_IMPORTED_MODULE_16__["default"]; });



















/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value */ "./node_modules/d3-interpolate/src/value.js");

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(nb),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) {
    x[i] = Object(_value__WEBPACK_IMPORTED_MODULE_0__["default"])(a[i], b[i]);
  }

  for (; i < nb; ++i) {
    c[i] = b[i];
  }

  return function (t) {
    for (i = 0; i < na; ++i) {
      c[i] = x[i](t);
    }

    return c;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/*! exports provided: basis, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "basis", function() { return basis; });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
      t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
/* harmony default export */ __webpack_exports__["default"] = (function (values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-interpolate/src/basis.js");

/* harmony default export */ __webpack_exports__["default"] = (function (values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return Object(_basis__WEBPACK_IMPORTED_MODULE_0__["basis"])((t - i / n) * n, v0, v1, v2, v3);
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/*! exports provided: hue, gamma, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hue", function() { return hue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gamma", function() { return gamma; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return nogamma; });
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : Object(_constant__WEBPACK_IMPORTED_MODULE_0__["default"])(isNaN(a) ? b : a);
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/*! exports provided: default, cubehelixLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubehelixLong", function() { return cubehelixLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["cubehelix"])(end)).h),
          s = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
          l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
          opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;
    return cubehelix;
  }(1);
}

/* harmony default export */ __webpack_exports__["default"] = (cubehelix(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var cubehelixLong = cubehelix(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var d = new Date();
  return a = +a, b -= a, function (t) {
    return d.setTime(a + b * t), d;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/*! exports provided: default, hclLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hclLong", function() { return hclLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function (start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hcl"])(end)).h),
        c = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.c, end.c),
        l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

/* harmony default export */ __webpack_exports__["default"] = (hcl(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hclLong = hcl(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/*! exports provided: default, hslLong */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hslLong", function() { return hslLong; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function (start, end) {
    var h = hue((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(start)).h, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["hsl"])(end)).h),
        s = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.s, end.s),
        l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.l, end.l),
        opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

/* harmony default export */ __webpack_exports__["default"] = (hsl(_color__WEBPACK_IMPORTED_MODULE_1__["hue"]));
var hslLong = hsl(_color__WEBPACK_IMPORTED_MODULE_1__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return lab; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");


function lab(start, end) {
  var l = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(start)).l, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["lab"])(end)).l),
      a = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.a, end.a),
      b = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.b, end.b),
      opacity = Object(_color__WEBPACK_IMPORTED_MODULE_1__["default"])(start.opacity, end.opacity);
  return function (t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return a = +a, b -= a, function (t) {
    return a + b * t;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _value__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value */ "./node_modules/d3-interpolate/src/value.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || _typeof(a) !== "object") a = {};
  if (b === null || _typeof(b) !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = Object(_value__WEBPACK_IMPORTED_MODULE_0__["default"])(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) {
      c[k] = i[k](t);
    }

    return c;
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (interpolator, n) {
  var samples = new Array(n);

  for (var i = 0; i < n; ++i) {
    samples[i] = interpolator(i / (n - 1));
  }

  return samples;
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/*! exports provided: default, rgbBasis, rgbBasisClosed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasis", function() { return rgbBasis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgbBasisClosed", function() { return rgbBasisClosed; });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _basis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basisClosed */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color */ "./node_modules/d3-interpolate/src/color.js");




/* harmony default export */ __webpack_exports__["default"] = ((function rgbGamma(y) {
  var color = Object(_color__WEBPACK_IMPORTED_MODULE_3__["gamma"])(y);

  function rgb(start, end) {
    var r = color((start = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(start)).r, (end = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = color(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;
  return rgb;
})(1));

function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i,
        color;

    for (i = 0; i < n; ++i) {
      color = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["rgb"])(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }

    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis__WEBPACK_IMPORTED_MODULE_1__["default"]);
var rgbBasisClosed = rgbSpline(_basisClosed__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  return a = +a, b -= a, function (t) {
    return Math.round(a + b * t);
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number */ "./node_modules/d3-interpolate/src/number.js");

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators
  // Coerce inputs to strings.

  a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(am, bm)
      });
    }

    bi = reB.lastIndex;
  } // Add remains of b.


  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  } // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.


  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) {
      s[(o = q[i]).i] = o.x(t);
    }

    return s.join("");
  });
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/*! exports provided: identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
/* harmony default export */ __webpack_exports__["default"] = (function (a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/*! exports provided: interpolateTransformCss, interpolateTransformSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return interpolateTransformCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return interpolateTransformSvg; });
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)
      }, {
        i: i - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(xa, xb)
      }, {
        i: i - 2,
        x: Object(_number__WEBPACK_IMPORTED_MODULE_0__["default"])(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function (a, b) {
    var s = [],
        // string constants and placeholders
    q = []; // number interpolators

    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc

    return function (t) {
      var i = -1,
          n = q.length,
          o;

      while (++i < n) {
        s[(o = q[i]).i] = o.x(t);
      }

      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse__WEBPACK_IMPORTED_MODULE_1__["parseCss"], "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse__WEBPACK_IMPORTED_MODULE_1__["parseSvg"], ", ", ")", ")");

/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/*! exports provided: parseCss, parseSvg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseCss", function() { return parseCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSvg", function() { return parseSvg; });
/* harmony import */ var _decompose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose */ "./node_modules/d3-interpolate/src/transform/decompose.js");

var cssNode, cssRoot, cssView, svgNode;
function parseCss(value) {
  if (value === "none") return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return Object(_decompose__WEBPACK_IMPORTED_MODULE_0__["default"])(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null) return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose__WEBPACK_IMPORTED_MODULE_0__["identity"];
  value = value.matrix;
  return Object(_decompose__WEBPACK_IMPORTED_MODULE_0__["default"])(value.a, value.b, value.c, value.d, value.e, value.f);
}

/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var _rgb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./date */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./object */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-interpolate/src/constant.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }









/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var t = _typeof(b),
      c;

  return b == null || t === "boolean" ? Object(_constant__WEBPACK_IMPORTED_MODULE_7__["default"])(b) : (t === "number" ? _number__WEBPACK_IMPORTED_MODULE_4__["default"] : t === "string" ? (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, _rgb__WEBPACK_IMPORTED_MODULE_1__["default"]) : _string__WEBPACK_IMPORTED_MODULE_6__["default"] : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? _rgb__WEBPACK_IMPORTED_MODULE_1__["default"] : b instanceof Date ? _date__WEBPACK_IMPORTED_MODULE_3__["default"] : Array.isArray(b) ? _array__WEBPACK_IMPORTED_MODULE_2__["default"] : isNaN(b) ? _object__WEBPACK_IMPORTED_MODULE_5__["default"] : _number__WEBPACK_IMPORTED_MODULE_4__["default"])(a, b);
});

/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
} // p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]


/* harmony default export */ __webpack_exports__["default"] = (function (p0, p1) {
  var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S; // Special case for u0 ≅ u1.

  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;

    i = function i(t) {
      return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
    };
  } // General case.
  else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;

      i = function i(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
      };
    }

  i.duration = S * 1000;
  return i;
});

/***/ }),

/***/ "./node_modules/d3-request/index.js":
/*!******************************************!*\
  !*** ./node_modules/d3-request/index.js ***!
  \******************************************/
/*! exports provided: request, html, json, text, xml, csv, tsv */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/request */ "./node_modules/d3-request/src/request.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "request", function() { return _src_request__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/html */ "./node_modules/d3-request/src/html.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return _src_html__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/json */ "./node_modules/d3-request/src/json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "json", function() { return _src_json__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/text */ "./node_modules/d3-request/src/text.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "text", function() { return _src_text__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_xml__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/xml */ "./node_modules/d3-request/src/xml.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return _src_xml__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_csv__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/csv */ "./node_modules/d3-request/src/csv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return _src_csv__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_tsv__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/tsv */ "./node_modules/d3-request/src/tsv.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return _src_tsv__WEBPACK_IMPORTED_MODULE_6__["default"]; });









/***/ }),

/***/ "./node_modules/d3-request/src/csv.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/csv.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/index.js");
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-request/src/dsv.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])("text/csv", d3_dsv__WEBPACK_IMPORTED_MODULE_0__["csvParse"]));

/***/ }),

/***/ "./node_modules/d3-request/src/dsv.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/dsv.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ "./node_modules/d3-request/src/request.js");

/* harmony default export */ __webpack_exports__["default"] = (function (defaultMimeType, parse) {
  return function (url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url).mimeType(defaultMimeType);

    r.row = function (_) {
      return arguments.length ? r.response(responseOf(parse, row = _)) : row;
    };

    r.row(row);
    return callback ? r.get(callback) : r;
  };
});

function responseOf(parse, row) {
  return function (request) {
    return parse(request.responseText, row);
  };
}

/***/ }),

/***/ "./node_modules/d3-request/src/html.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/html.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("text/html", function (xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
}));

/***/ }),

/***/ "./node_modules/d3-request/src/json.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/json.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("application/json", function (xhr) {
  return JSON.parse(xhr.responseText);
}));

/***/ }),

/***/ "./node_modules/d3-request/src/request.js":
/*!************************************************!*\
  !*** ./node_modules/d3-request/src/request.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "./node_modules/d3-collection/index.js");
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function (url, callback) {
  var request,
      event = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["dispatch"])("beforesend", "progress", "load", "error"),
      _mimeType,
      headers = Object(d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"])(),
      xhr = new XMLHttpRequest(),
      _user = null,
      _password = null,
      _response,
      _responseType,
      _timeout = 0; // If IE does not support CORS, use XDomainRequest.


  if (typeof XDomainRequest !== "undefined" && !("withCredentials" in xhr) && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest();
  "onload" in xhr ? xhr.onload = xhr.onerror = xhr.ontimeout = respond : xhr.onreadystatechange = function (o) {
    xhr.readyState > 3 && respond(o);
  };

  function respond(o) {
    var status = xhr.status,
        result;

    if (!status && hasResponse(xhr) || status >= 200 && status < 300 || status === 304) {
      if (_response) {
        try {
          result = _response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }

      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function (e) {
    event.call("progress", request, e);
  };

  request = {
    header: function header(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);else headers.set(name, value + "");
      return request;
    },
    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function mimeType(value) {
      if (!arguments.length) return _mimeType;
      _mimeType = value == null ? null : value + "";
      return request;
    },
    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function responseType(value) {
      if (!arguments.length) return _responseType;
      _responseType = value;
      return request;
    },
    timeout: function timeout(value) {
      if (!arguments.length) return _timeout;
      _timeout = +value;
      return request;
    },
    user: function user(value) {
      return arguments.length < 1 ? _user : (_user = value == null ? null : value + "", request);
    },
    password: function password(value) {
      return arguments.length < 1 ? _password : (_password = value == null ? null : value + "", request);
    },
    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function response(value) {
      _response = value;
      return request;
    },
    // Alias for send("GET", …).
    get: function get(data, callback) {
      return request.send("GET", data, callback);
    },
    // Alias for send("POST", …).
    post: function post(data, callback) {
      return request.send("POST", data, callback);
    },
    // If callback is non-null, it will be used for error and load events.
    send: function send(method, data, callback) {
      xhr.open(method, url, true, _user, _password);
      if (_mimeType != null && !headers.has("accept")) headers.set("accept", _mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
      if (_mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(_mimeType);
      if (_responseType != null) xhr.responseType = _responseType;
      if (_timeout > 0) xhr.timeout = _timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function (xhr) {
        callback(null, xhr);
      });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },
    abort: function abort() {
      xhr.abort();
      return request;
    },
    on: function on() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
});

function fixCallback(callback) {
  return function (error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text" ? xhr.response // null on error
  : xhr.responseText; // "" on error
}

/***/ }),

/***/ "./node_modules/d3-request/src/text.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/text.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("text/plain", function (xhr) {
  return xhr.responseText;
}));

/***/ }),

/***/ "./node_modules/d3-request/src/tsv.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/tsv.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/index.js");
/* harmony import */ var _dsv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dsv */ "./node_modules/d3-request/src/dsv.js");


/* harmony default export */ __webpack_exports__["default"] = (Object(_dsv__WEBPACK_IMPORTED_MODULE_1__["default"])("text/tab-separated-values", d3_dsv__WEBPACK_IMPORTED_MODULE_0__["tsvParse"]));

/***/ }),

/***/ "./node_modules/d3-request/src/type.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-request/src/type.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ "./node_modules/d3-request/src/request.js");

/* harmony default export */ __webpack_exports__["default"] = (function (defaultMimeType, response) {
  return function (url, callback) {
    var r = Object(_request__WEBPACK_IMPORTED_MODULE_0__["default"])(url).mimeType(defaultMimeType).response(response);

    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }

    return r;
  };
});

/***/ }),

/***/ "./node_modules/d3-request/src/xml.js":
/*!********************************************!*\
  !*** ./node_modules/d3-request/src/xml.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./type */ "./node_modules/d3-request/src/type.js");

/* harmony default export */ __webpack_exports__["default"] = (Object(_type__WEBPACK_IMPORTED_MODULE_0__["default"])("application/xml", function (xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
}));

/***/ }),

/***/ "./node_modules/d3-selection/index.js":
/*!********************************************!*\
  !*** ./node_modules/d3-selection/index.js ***!
  \********************************************/
/*! exports provided: creator, local, matcher, mouse, namespace, namespaces, select, selectAll, selection, selector, selectorAll, touch, touches, window, event, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return _src_creator__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_local__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/local */ "./node_modules/d3-selection/src/local.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return _src_local__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_matcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/matcher */ "./node_modules/d3-selection/src/matcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return _src_matcher__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_mouse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/mouse */ "./node_modules/d3-selection/src/mouse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return _src_mouse__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_namespace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/namespace */ "./node_modules/d3-selection/src/namespace.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return _src_namespace__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_namespaces__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/namespaces */ "./node_modules/d3-selection/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _src_namespaces__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_select__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/select */ "./node_modules/d3-selection/src/select.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return _src_select__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_selectAll__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/selectAll */ "./node_modules/d3-selection/src/selectAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return _src_selectAll__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_selection_index__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/selection/index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return _src_selection_index__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_selector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/selector */ "./node_modules/d3-selection/src/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return _src_selector__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_selectorAll__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/selectorAll */ "./node_modules/d3-selection/src/selectorAll.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return _src_selectorAll__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_touch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/touch */ "./node_modules/d3-selection/src/touch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return _src_touch__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_touches__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/touches */ "./node_modules/d3-selection/src/touches.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return _src_touches__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_window__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/window */ "./node_modules/d3-selection/src/window.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _src_window__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_selection_on__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/selection/on */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "event", function() { return _src_selection_on__WEBPACK_IMPORTED_MODULE_14__["event"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return _src_selection_on__WEBPACK_IMPORTED_MODULE_14__["customEvent"]; });

















/***/ }),

/***/ "./node_modules/d3-selection/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/constant.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-selection/src/creator.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/creator.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespace */ "./node_modules/d3-selection/src/namespace.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-selection/src/namespaces.js");



function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"] && document.documentElement.namespaceURI === _namespaces__WEBPACK_IMPORTED_MODULE_1__["xhtml"] ? document.createElement(name) : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/local.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/local.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return local; });
var nextId = 0;
function local() {
  return new Local();
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function get(node) {
    var id = this._;

    while (!(id in node)) {
      if (!(node = node.parentNode)) return;
    }

    return node[id];
  },
  set: function set(node, value) {
    return node[this._] = value;
  },
  remove: function remove(node) {
    return this._ in node && delete node[this._];
  },
  toString: function toString() {
    return this._;
  }
};

/***/ }),

/***/ "./node_modules/d3-selection/src/matcher.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/matcher.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var matcher = function matcher(selector) {
  return function () {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;

    matcher = function matcher(selector) {
      return function () {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

/* harmony default export */ __webpack_exports__["default"] = (matcher);

/***/ }),

/***/ "./node_modules/d3-selection/src/mouse.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/mouse.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");


/* harmony default export */ __webpack_exports__["default"] = (function (node) {
  var event = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])();
  if (event.changedTouches) event = event.changedTouches[0];
  return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, event);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/namespace.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespace.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/d3-selection/src/namespaces.js");

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var prefix = name += "",
      i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(prefix) ? {
    space: _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"][prefix],
    local: name
  } : name;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/namespaces.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-selection/src/namespaces.js ***!
  \*****************************************************/
/*! exports provided: xhtml, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xhtml", function() { return xhtml; });
var xhtml = "http://www.w3.org/1999/xhtml";
/* harmony default export */ __webpack_exports__["default"] = ({
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
});

/***/ }),

/***/ "./node_modules/d3-selection/src/point.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/point.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
});

/***/ }),

/***/ "./node_modules/d3-selection/src/select.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/select.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return typeof selector === "string" ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[document.querySelector(selector)]], [document.documentElement]) : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([[selector]], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selectAll.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-selection/src/selectAll.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return typeof selector === "string" ? new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([document.querySelectorAll(selector)], [document.documentElement]) : new _selection_index__WEBPACK_IMPORTED_MODULE_0__["Selection"]([selector == null ? [] : selector], _selection_index__WEBPACK_IMPORTED_MODULE_0__["root"]);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/append.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/append.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-selection/src/creator.js");

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/attr.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/attr.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _namespace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../namespace */ "./node_modules/d3-selection/src/namespace.js");


function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var fullname = Object(_namespace__WEBPACK_IMPORTED_MODULE_0__["default"])(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }

  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/call.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/call.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/classed.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/classed.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function add(name) {
    var i = this._names.indexOf(name);

    if (i < 0) {
      this._names.push(name);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function remove(name) {
    var i = this._names.indexOf(name);

    if (i >= 0) {
      this._names.splice(i, 1);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function contains(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) {
    list.add(names[i]);
  }
}

function classedRemove(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) {
    list.remove(names[i]);
  }
}

function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()),
        i = -1,
        n = names.length;

    while (++i < n) {
      if (!list.contains(names[i])) return false;
    }

    return true;
  }

  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/data.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/data.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./node_modules/d3-selection/src/constant.js");



var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length; // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.

  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  } // Put any non-null nodes that don’t fit into exit.


  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue; // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.

  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);

      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  } // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.


  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);

    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter__WEBPACK_IMPORTED_MODULE_1__["EnterNode"](parent, data[i]);
    }
  } // Add any remaining nodes that were not bound to data to exit.


  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (function (value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function (d) {
      data[++j] = d;
    });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;
  if (typeof value !== "function") value = Object(_constant__WEBPACK_IMPORTED_MODULE_2__["default"])(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.

    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;

        while (!(next = updateGroup[i1]) && ++i1 < dataLength) {
          ;
        }

        previous._next = next || null;
      }
    }
  }

  update = new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/datum.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/datum.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/dispatch.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/dispatch.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-selection/src/window.js");


function dispatchEvent(node, type, params) {
  var window = Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node),
      event = window.CustomEvent;

  if (event) {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/each.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/empty.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/empty.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return !this.node();
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/enter.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/enter.js ***!
  \**********************************************************/
/*! exports provided: default, EnterNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EnterNode", function() { return EnterNode; });
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._enter || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function appendChild(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function insertBefore(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function querySelector(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function querySelectorAll(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/exit.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/exit.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sparse */ "./node_modules/d3-selection/src/selection/sparse.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new _index__WEBPACK_IMPORTED_MODULE_1__["Selection"](this._exit || this._groups.map(_sparse__WEBPACK_IMPORTED_MODULE_0__["default"]), this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/filter.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/filter.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _matcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matcher */ "./node_modules/d3-selection/src/matcher.js");


/* harmony default export */ __webpack_exports__["default"] = (function (match) {
  if (typeof match !== "function") match = Object(_matcher__WEBPACK_IMPORTED_MODULE_1__["default"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/html.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/html.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/index.js ***!
  \**********************************************************/
/*! exports provided: root, Selection, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "root", function() { return root; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Selection", function() { return Selection; });
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./select */ "./node_modules/d3-selection/src/selection/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-selection/src/selection/selectAll.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-selection/src/selection/filter.js");
/* harmony import */ var _data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data */ "./node_modules/d3-selection/src/selection/data.js");
/* harmony import */ var _enter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enter */ "./node_modules/d3-selection/src/selection/enter.js");
/* harmony import */ var _exit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./exit */ "./node_modules/d3-selection/src/selection/exit.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-selection/src/selection/merge.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./order */ "./node_modules/d3-selection/src/selection/order.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sort */ "./node_modules/d3-selection/src/selection/sort.js");
/* harmony import */ var _call__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./call */ "./node_modules/d3-selection/src/selection/call.js");
/* harmony import */ var _nodes__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./nodes */ "./node_modules/d3-selection/src/selection/nodes.js");
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./node */ "./node_modules/d3-selection/src/selection/node.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./size */ "./node_modules/d3-selection/src/selection/size.js");
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./empty */ "./node_modules/d3-selection/src/selection/empty.js");
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./each */ "./node_modules/d3-selection/src/selection/each.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-selection/src/selection/attr.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./style */ "./node_modules/d3-selection/src/selection/style.js");
/* harmony import */ var _property__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./property */ "./node_modules/d3-selection/src/selection/property.js");
/* harmony import */ var _classed__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./classed */ "./node_modules/d3-selection/src/selection/classed.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./text */ "./node_modules/d3-selection/src/selection/text.js");
/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./html */ "./node_modules/d3-selection/src/selection/html.js");
/* harmony import */ var _raise__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./raise */ "./node_modules/d3-selection/src/selection/raise.js");
/* harmony import */ var _lower__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lower */ "./node_modules/d3-selection/src/selection/lower.js");
/* harmony import */ var _append__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./append */ "./node_modules/d3-selection/src/selection/append.js");
/* harmony import */ var _insert__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./insert */ "./node_modules/d3-selection/src/selection/insert.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-selection/src/selection/remove.js");
/* harmony import */ var _datum__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./datum */ "./node_modules/d3-selection/src/selection/datum.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./on */ "./node_modules/d3-selection/src/selection/on.js");
/* harmony import */ var _dispatch__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./dispatch */ "./node_modules/d3-selection/src/selection/dispatch.js");





























var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select__WEBPACK_IMPORTED_MODULE_0__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_1__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_2__["default"],
  data: _data__WEBPACK_IMPORTED_MODULE_3__["default"],
  enter: _enter__WEBPACK_IMPORTED_MODULE_4__["default"],
  exit: _exit__WEBPACK_IMPORTED_MODULE_5__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_6__["default"],
  order: _order__WEBPACK_IMPORTED_MODULE_7__["default"],
  sort: _sort__WEBPACK_IMPORTED_MODULE_8__["default"],
  call: _call__WEBPACK_IMPORTED_MODULE_9__["default"],
  nodes: _nodes__WEBPACK_IMPORTED_MODULE_10__["default"],
  node: _node__WEBPACK_IMPORTED_MODULE_11__["default"],
  size: _size__WEBPACK_IMPORTED_MODULE_12__["default"],
  empty: _empty__WEBPACK_IMPORTED_MODULE_13__["default"],
  each: _each__WEBPACK_IMPORTED_MODULE_14__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_15__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_16__["default"],
  property: _property__WEBPACK_IMPORTED_MODULE_17__["default"],
  classed: _classed__WEBPACK_IMPORTED_MODULE_18__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_19__["default"],
  html: _html__WEBPACK_IMPORTED_MODULE_20__["default"],
  raise: _raise__WEBPACK_IMPORTED_MODULE_21__["default"],
  lower: _lower__WEBPACK_IMPORTED_MODULE_22__["default"],
  append: _append__WEBPACK_IMPORTED_MODULE_23__["default"],
  insert: _insert__WEBPACK_IMPORTED_MODULE_24__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_25__["default"],
  datum: _datum__WEBPACK_IMPORTED_MODULE_26__["default"],
  on: _on__WEBPACK_IMPORTED_MODULE_27__["default"],
  dispatch: _dispatch__WEBPACK_IMPORTED_MODULE_28__["default"]
};
/* harmony default export */ __webpack_exports__["default"] = (selection);

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/insert.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/insert.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _creator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../creator */ "./node_modules/d3-selection/src/creator.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-selection/src/selector.js");



function constantNull() {
  return null;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, before) {
  var create = typeof name === "function" ? name : Object(_creator__WEBPACK_IMPORTED_MODULE_0__["default"])(name),
      select = before == null ? constantNull : typeof before === "function" ? before : Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/lower.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/lower.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.each(lower);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/merge.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/merge.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (selection) {
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](merges, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/node.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/nodes.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/nodes.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var nodes = new Array(this.size()),
      i = -1;
  this.each(function () {
    nodes[++i] = this;
  });
  return nodes;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/on.js ***!
  \*******************************************************/
/*! exports provided: event, default, customEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return customEvent; });
var filterEvents = {};
var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!("onmouseenter" in element)) {
    filterEvents = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    };
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function (event) {
    var related = event.relatedTarget;

    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function (event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).

    event = event1;

    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {
      type: t,
      name: name
    };
  });
}

function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;

    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }

    if (++i) on.length = i;else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function (d, i, group) {
    var on = this.__on,
        o,
        listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {
      type: typename.type,
      name: typename.name,
      value: value,
      listener: listener,
      capture: capture
    };
    if (!on) this.__on = [o];else on.push(o);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (typename, value, capture) {
  var typenames = parseTypenames(typename + ""),
      i,
      n = typenames.length,
      t;

  if (arguments.length < 2) {
    var on = this.node().__on;

    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;

  for (i = 0; i < n; ++i) {
    this.each(on(typenames[i], value, capture));
  }

  return this;
});
function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;

  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/order.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/order.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/property.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/property.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/raise.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/raise.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.each(raise);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/remove.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/remove.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.each(remove);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/select.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/select.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selector */ "./node_modules/d3-selection/src/selector.js");


/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  if (typeof select !== "function") select = Object(_selector__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/selectAll.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/selectAll.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");
/* harmony import */ var _selectorAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../selectorAll */ "./node_modules/d3-selection/src/selectorAll.js");


/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  if (typeof select !== "function") select = Object(_selectorAll__WEBPACK_IMPORTED_MODULE_1__["default"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](subgroups, parents);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/size.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/size.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var size = 0;
  this.each(function () {
    ++size;
  });
  return size;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sort.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-selection/src/selection/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }

    sortgroup.sort(compareNode);
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Selection"](sortgroups, this._parents).order();
});

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/sparse.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/sparse.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (update) {
  return new Array(update.length);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/style.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/style.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../window */ "./node_modules/d3-selection/src/window.js");


function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value, priority) {
  var node;
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : Object(_window__WEBPACK_IMPORTED_MODULE_0__["default"])(node = this.node()).getComputedStyle(node, null).getPropertyValue(name);
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selection/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-selection/src/selection/text.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selector.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-selection/src/selector.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function none() {}

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return selector == null ? none : function () {
    return this.querySelector(selector);
  };
});

/***/ }),

/***/ "./node_modules/d3-selection/src/selectorAll.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/selectorAll.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function empty() {
  return [];
}

/* harmony default export */ __webpack_exports__["default"] = (function (selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
});

/***/ }),

/***/ "./node_modules/d3-selection/src/sourceEvent.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-selection/src/sourceEvent.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selection_on__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selection/on */ "./node_modules/d3-selection/src/selection/on.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var current = _selection_on__WEBPACK_IMPORTED_MODULE_0__["event"],
      source;

  while (source = current.sourceEvent) {
    current = source;
  }

  return current;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/touch.js":
/*!************************************************!*\
  !*** ./node_modules/d3-selection/src/touch.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");


/* harmony default export */ __webpack_exports__["default"] = (function (node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touch);
    }
  }

  return null;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/touches.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-selection/src/touches.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sourceEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sourceEvent */ "./node_modules/d3-selection/src/sourceEvent.js");
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./node_modules/d3-selection/src/point.js");


/* harmony default export */ __webpack_exports__["default"] = (function (node, touches) {
  if (touches == null) touches = Object(_sourceEvent__WEBPACK_IMPORTED_MODULE_0__["default"])().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = Object(_point__WEBPACK_IMPORTED_MODULE_1__["default"])(node, touches[i]);
  }

  return points;
});

/***/ }),

/***/ "./node_modules/d3-selection/src/window.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-selection/src/window.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (node) {
  return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node
  node.document && node // node is a Window
  || node.defaultView; // node is a Document
});

/***/ }),

/***/ "./node_modules/d3-timer/index.js":
/*!****************************************!*\
  !*** ./node_modules/d3-timer/index.js ***!
  \****************************************/
/*! exports provided: now, timer, timerFlush, timeout, interval */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "now", function() { return _src_timer__WEBPACK_IMPORTED_MODULE_0__["now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return _src_timer__WEBPACK_IMPORTED_MODULE_0__["timer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return _src_timer__WEBPACK_IMPORTED_MODULE_0__["timerFlush"]; });

/* harmony import */ var _src_timeout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/timeout */ "./node_modules/d3-timer/src/timeout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "timeout", function() { return _src_timeout__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_interval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/interval */ "./node_modules/d3-timer/src/interval.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interval", function() { return _src_interval__WEBPACK_IMPORTED_MODULE_2__["default"]; });





/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ "./node_modules/d3-timer/src/timer.js");

/* harmony default export */ __webpack_exports__["default"] = (function (callback, delay, time) {
  var t = new _timer__WEBPACK_IMPORTED_MODULE_0__["Timer"](),
      total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? Object(_timer__WEBPACK_IMPORTED_MODULE_0__["now"])() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
});

/***/ }),

/***/ "./node_modules/d3-timer/src/timeout.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-timer/src/timeout.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer */ "./node_modules/d3-timer/src/timer.js");

/* harmony default export */ __webpack_exports__["default"] = (function (callback, delay, time) {
  var t = new _timer__WEBPACK_IMPORTED_MODULE_0__["Timer"]();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
});

/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/*! exports provided: now, Timer, timer, timerFlush */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timer", function() { return Timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timer", function() { return timer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timerFlush", function() { return timerFlush; });
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var frame = 0,
    // is an animation frame pending?
timeout = 0,
    // is a timeout pending?
interval = 0,
    // are any timers active?
pokeDelay = 1000,
    // how frequently we check for clock skew
taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === "object" && performance.now ? performance : Date,
    setFrame = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }

    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now(); // Get the current time, if not already set.

  ++frame; // Pretend we’ve set an alarm, if we haven’t already.

  var t = taskHead,
      e;

  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }

  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;

  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(),
      delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0,
      t1 = taskHead,
      t2,
      time = Infinity;

  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }

  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.

  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

/***/ }),

/***/ "./node_modules/d3-transition/index.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-transition/index.js ***!
  \*********************************************/
/*! exports provided: transition, active, interrupt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_selection_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/selection/index */ "./node_modules/d3-transition/src/selection/index.js");
/* harmony import */ var _src_transition_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/transition/index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return _src_transition_index__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_active__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/active */ "./node_modules/d3-transition/src/active.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "active", function() { return _src_active__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_interrupt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/interrupt */ "./node_modules/d3-transition/src/interrupt.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interrupt", function() { return _src_interrupt__WEBPACK_IMPORTED_MODULE_3__["default"]; });






/***/ }),

/***/ "./node_modules/d3-transition/src/active.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-transition/src/active.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition/schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


var root = [null];
/* harmony default export */ __webpack_exports__["default"] = (function (node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).state > _transition_schedule__WEBPACK_IMPORTED_MODULE_1__["SCHEDULED"] && schedule.name === name) {
        return new _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"]([[node]], root, name, +i);
      }
    }
  }

  return null;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/interrupt.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-transition/src/interrupt.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition/schedule */ "./node_modules/d3-transition/src/transition/schedule.js");

/* harmony default export */ __webpack_exports__["default"] = (function (node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;
  if (!schedules) return;
  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty = false;
      continue;
    }

    active = schedule.state > _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["STARTING"] && schedule.state < _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["ENDING"];
    schedule.state = _transition_schedule__WEBPACK_IMPORTED_MODULE_0__["ENDED"];
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/index.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _interrupt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interrupt */ "./node_modules/d3-transition/src/selection/interrupt.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition */ "./node_modules/d3-transition/src/selection/transition.js");



d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.interrupt = _interrupt__WEBPACK_IMPORTED_MODULE_1__["default"];
d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.transition = _transition__WEBPACK_IMPORTED_MODULE_2__["default"];

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/interrupt.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/interrupt.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _interrupt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interrupt */ "./node_modules/d3-transition/src/interrupt.js");

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  return this.each(function () {
    Object(_interrupt__WEBPACK_IMPORTED_MODULE_0__["default"])(this, name);
  });
});

/***/ }),

/***/ "./node_modules/d3-transition/src/selection/transition.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/selection/transition.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transition_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transition/index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _transition_schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transition/schedule */ "./node_modules/d3-transition/src/transition/schedule.js");
/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/index.js");




var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: d3_ease__WEBPACK_IMPORTED_MODULE_2__["easeCubicInOut"]
};

function inherit(node, id) {
  var timing;

  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), defaultTiming;
    }
  }

  return timing;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name) {
  var id, timing;

  if (name instanceof _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"]) {
    id = name._id, name = name._name;
  } else {
    id = Object(_transition_index__WEBPACK_IMPORTED_MODULE_0__["newId"])(), (timing = defaultTiming).time = Object(d3_timer__WEBPACK_IMPORTED_MODULE_3__["now"])(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        Object(_transition_schedule__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _transition_index__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attr.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attr.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate */ "./node_modules/d3-transition/src/transition/interpolate.js");





function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["namespace"])(name),
      i = fullname === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformSvg"] : _interpolate__WEBPACK_IMPORTED_MODULE_3__["default"];
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, Object(_tween__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/attrTween.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/attrTween.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");


function attrTweenNS(fullname, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }

  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttribute(name, i(t));
    };
  }

  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["namespace"])(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/delay.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/delay.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function delayFunction(id, value) {
  return function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["init"])(this, id).delay = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).delay;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/duration.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/duration.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function durationFunction(id, value) {
  return function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).duration = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).duration;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/ease.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/ease.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id).ease = value;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  var id = this._id;
  return arguments.length ? this.each(easeConstant(id, value)) : Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).ease;
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/filter.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function (match) {
  if (typeof match !== "function") match = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["matcher"])(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, this._name, this._id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/index.js ***!
  \************************************************************/
/*! exports provided: Transition, default, newId */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return Transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newId", function() { return newId; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _attr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./attr */ "./node_modules/d3-transition/src/transition/attr.js");
/* harmony import */ var _attrTween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attrTween */ "./node_modules/d3-transition/src/transition/attrTween.js");
/* harmony import */ var _delay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./delay */ "./node_modules/d3-transition/src/transition/delay.js");
/* harmony import */ var _duration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./duration */ "./node_modules/d3-transition/src/transition/duration.js");
/* harmony import */ var _ease__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ease */ "./node_modules/d3-transition/src/transition/ease.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filter */ "./node_modules/d3-transition/src/transition/filter.js");
/* harmony import */ var _merge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./merge */ "./node_modules/d3-transition/src/transition/merge.js");
/* harmony import */ var _on__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./on */ "./node_modules/d3-transition/src/transition/on.js");
/* harmony import */ var _remove__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./remove */ "./node_modules/d3-transition/src/transition/remove.js");
/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./select */ "./node_modules/d3-transition/src/transition/select.js");
/* harmony import */ var _selectAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./selectAll */ "./node_modules/d3-transition/src/transition/selectAll.js");
/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./selection */ "./node_modules/d3-transition/src/transition/selection.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./style */ "./node_modules/d3-transition/src/transition/style.js");
/* harmony import */ var _styleTween__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./styleTween */ "./node_modules/d3-transition/src/transition/styleTween.js");
/* harmony import */ var _text__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./text */ "./node_modules/d3-transition/src/transition/text.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./transition */ "./node_modules/d3-transition/src/transition/transition.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");


















var id = 0;
function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}
function transition(name) {
  return Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"])().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select__WEBPACK_IMPORTED_MODULE_10__["default"],
  selectAll: _selectAll__WEBPACK_IMPORTED_MODULE_11__["default"],
  filter: _filter__WEBPACK_IMPORTED_MODULE_6__["default"],
  merge: _merge__WEBPACK_IMPORTED_MODULE_7__["default"],
  selection: _selection__WEBPACK_IMPORTED_MODULE_12__["default"],
  transition: _transition__WEBPACK_IMPORTED_MODULE_16__["default"],
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on__WEBPACK_IMPORTED_MODULE_8__["default"],
  attr: _attr__WEBPACK_IMPORTED_MODULE_1__["default"],
  attrTween: _attrTween__WEBPACK_IMPORTED_MODULE_2__["default"],
  style: _style__WEBPACK_IMPORTED_MODULE_13__["default"],
  styleTween: _styleTween__WEBPACK_IMPORTED_MODULE_14__["default"],
  text: _text__WEBPACK_IMPORTED_MODULE_15__["default"],
  remove: _remove__WEBPACK_IMPORTED_MODULE_9__["default"],
  tween: _tween__WEBPACK_IMPORTED_MODULE_17__["default"],
  delay: _delay__WEBPACK_IMPORTED_MODULE_3__["default"],
  duration: _duration__WEBPACK_IMPORTED_MODULE_4__["default"],
  ease: _ease__WEBPACK_IMPORTED_MODULE_5__["default"]
};

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/interpolate.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/interpolate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");


/* harmony default export */ __webpack_exports__["default"] = (function (a, b) {
  var c;
  return (typeof b === "number" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateNumber"] : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_0__["color"] ? d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"] : (c = Object(d3_color__WEBPACK_IMPORTED_MODULE_0__["color"])(b)) ? (b = c, d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateRgb"]) : d3_interpolate__WEBPACK_IMPORTED_MODULE_1__["interpolateString"])(a, b);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/merge.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/merge.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");

/* harmony default export */ __webpack_exports__["default"] = (function (transition) {
  if (transition._id !== this._id) throw new Error();

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Transition"](merges, this._parents, this._name, this._id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/on.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/on.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0,
      on1,
      sit = start(name) ? _schedule__WEBPACK_IMPORTED_MODULE_0__["init"] : _schedule__WEBPACK_IMPORTED_MODULE_0__["set"];
  return function () {
    var schedule = sit(this, id),
        on = schedule.on; // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.

    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, listener) {
  var id = this._id;
  return arguments.length < 2 ? Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/remove.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/remove.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function removeFunction(id) {
  return function () {
    var parent = this.parentNode;

    for (var i in this.__transition) {
      if (+i !== id) return;
    }

    if (parent) parent.removeChild(this);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  return this.on("end.remove", removeFunction(this._id));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/schedule.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/schedule.js ***!
  \***************************************************************/
/*! exports provided: CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, default, init, set, get */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CREATED", function() { return CREATED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCHEDULED", function() { return SCHEDULED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTING", function() { return STARTING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STARTED", function() { return STARTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RUNNING", function() { return RUNNING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDING", function() { return ENDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENDED", function() { return ENDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init", function() { return init; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/index.js");


var emptyOn = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "end", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
/* harmony default export */ __webpack_exports__["default"] = (function (node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index,
    // For context during callback.
    group: group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
});
function init(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error("too late");
  return schedule;
}
function set(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error("too late");
  return schedule;
}
function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("too late");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween; // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!

  schedules[id] = self;
  self.timer = Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timer"])(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.

    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.

    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!

      if (o.state === STARTED) return Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(start); // Interrupt the active transition, if any.
      // Dispatch the interrupt event.

      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          delete schedules[i];
        }
    } // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.


    Object(d3_timer__WEBPACK_IMPORTED_MODULE_1__["timeout"])(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    }); // Dispatch the start event.
    // Note this must be done before the tween are initialized.

    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted

    self.state = STARTED; // Initialize the tween, deleting null tween.

    tween = new Array(n = self.tween.length);

    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }

    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    } // Dispatch the end event.


    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];

    for (var i in schedules) {
      return;
    } // eslint-disable-line no-unused-vars


    delete node.__transition;
  }
}

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/select.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/select.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selector"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["default"])(subgroup[i], name, id, i, subgroup, Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id));
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, this._parents, name, id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selectAll.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selectAll.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");



/* harmony default export */ __webpack_exports__["default"] = (function (select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = Object(d3_selection__WEBPACK_IMPORTED_MODULE_0__["selectorAll"])(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["get"])(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            Object(_schedule__WEBPACK_IMPORTED_MODULE_2__["default"])(child, name, id, k, children, inherit);
          }
        }

        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_1__["Transition"](subgroups, parents, name, id);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/selection.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/selection.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");

var Selection = d3_selection__WEBPACK_IMPORTED_MODULE_0__["selection"].prototype.constructor;
/* harmony default export */ __webpack_exports__["default"] = (function () {
  return new Selection(this._groups, this._parents);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/style.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/style.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");
/* harmony import */ var _interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpolate */ "./node_modules/d3-transition/src/transition/interpolate.js");





function styleRemove(name, interpolate) {
  var value00, value10, interpolate0;
  return function () {
    var style = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["window"])(this).getComputedStyle(this, null),
        value0 = style.getPropertyValue(name),
        value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["window"])(this).getComputedStyle(this, null).getPropertyValue(name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var style = Object(d3_selection__WEBPACK_IMPORTED_MODULE_1__["window"])(this).getComputedStyle(this, null),
        value0 = style.getPropertyValue(name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), style.getPropertyValue(name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value, priority) {
  var i = (name += "") === "transform" ? d3_interpolate__WEBPACK_IMPORTED_MODULE_0__["interpolateTransformCss"] : _interpolate__WEBPACK_IMPORTED_MODULE_3__["default"];
  return value == null ? this.styleTween(name, styleRemove(name, i)).on("end.style." + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === "function" ? styleFunction(name, i, Object(_tween__WEBPACK_IMPORTED_MODULE_2__["tweenValue"])(this, "style." + name, value)) : styleConstant(name, i, value + ""), priority);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/styleTween.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/styleTween.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function styleTween(name, value, priority) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.style.setProperty(name, i(t), priority);
    };
  }

  tween._value = value;
  return tween;
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/text.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tween */ "./node_modules/d3-transition/src/transition/tween.js");


function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (value) {
  return this.tween("text", typeof value === "function" ? textFunction(Object(_tween__WEBPACK_IMPORTED_MODULE_0__["tweenValue"])(this, "text", value)) : textConstant(value == null ? "" : value + ""));
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/transition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/transition.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index */ "./node_modules/d3-transition/src/transition/index.js");
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


/* harmony default export */ __webpack_exports__["default"] = (function () {
  var name = this._name,
      id0 = this._id,
      id1 = Object(_index__WEBPACK_IMPORTED_MODULE_0__["newId"])();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = Object(_schedule__WEBPACK_IMPORTED_MODULE_1__["get"])(node, id0);
        Object(_schedule__WEBPACK_IMPORTED_MODULE_1__["default"])(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index__WEBPACK_IMPORTED_MODULE_0__["Transition"](groups, this._parents, name, id1);
});

/***/ }),

/***/ "./node_modules/d3-transition/src/transition/tween.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-transition/src/transition/tween.js ***!
  \************************************************************/
/*! exports provided: default, tweenValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tweenValue", function() { return tweenValue; });
/* harmony import */ var _schedule__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./schedule */ "./node_modules/d3-transition/src/transition/schedule.js");


function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = tween0 = tween;

      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();

      for (var t = {
        name: name,
        value: value
      }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }

      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (function (name, value) {
  var id = this._id;
  name += "";

  if (arguments.length < 2) {
    var tween = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(this.node(), id).tween;

    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }

    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
});
function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function () {
    var schedule = Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["set"])(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function (node) {
    return Object(_schedule__WEBPACK_IMPORTED_MODULE_0__["get"])(node, id).value[name];
  };
}

/***/ }),

/***/ "./node_modules/d3-zoom/index.js":
/*!***************************************!*\
  !*** ./node_modules/d3-zoom/index.js ***!
  \***************************************/
/*! exports provided: zoom, zoomTransform, zoomIdentity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/zoom */ "./node_modules/d3-zoom/src/zoom.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return _src_zoom__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/transform */ "./node_modules/d3-zoom/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_1__["identity"]; });




/***/ }),

/***/ "./node_modules/d3-zoom/src/constant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-zoom/src/constant.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return function () {
    return x;
  };
});

/***/ }),

/***/ "./node_modules/d3-zoom/src/event.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-zoom/src/event.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomEvent; });
function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/noevent.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-zoom/src/noevent.js ***!
  \*********************************************/
/*! exports provided: nopropagation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nopropagation", function() { return nopropagation; });
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");

function nopropagation() {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
}
/* harmony default export */ __webpack_exports__["default"] = (function () {
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].preventDefault();
  d3_selection__WEBPACK_IMPORTED_MODULE_0__["event"].stopImmediatePropagation();
});

/***/ }),

/***/ "./node_modules/d3-zoom/src/transform.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-zoom/src/transform.js ***!
  \***********************************************/
/*! exports provided: Transform, identity, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return Transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transform; });
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function scale(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function translate(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function apply(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function applyX(x) {
    return x * this.k + this.x;
  },
  applyY: function applyY(y) {
    return y * this.k + this.y;
  },
  invert: function invert(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function invertX(x) {
    return (x - this.x) / this.k;
  },
  invertY: function invertY(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function rescaleX(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function rescaleY(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function toString() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
  return node.__zoom || identity;
}

/***/ }),

/***/ "./node_modules/d3-zoom/src/zoom.js":
/*!******************************************!*\
  !*** ./node_modules/d3-zoom/src/zoom.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony import */ var d3_transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-transition */ "./node_modules/d3-transition/index.js");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constant */ "./node_modules/d3-zoom/src/constant.js");
/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./event */ "./node_modules/d3-zoom/src/event.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transform */ "./node_modules/d3-zoom/src/transform.js");
/* harmony import */ var _noevent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./noevent */ "./node_modules/d3-zoom/src/noevent.js");








 // Ignore right-click, since that should open the context menu.

function defaultFilter() {
  return !d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].button;
}

function defaultExtent() {
  var e = this,
      w,
      h;

  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }

  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || _transform__WEBPACK_IMPORTED_MODULE_7__["identity"];
}

function defaultWheelDelta() {
  return -d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaY * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__["interpolateZoom"],
      gestures = [],
      listeners = Object(d3_dispatch__WEBPACK_IMPORTED_MODULE_0__["dispatch"])("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function (collection, transform) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);

    if (collection !== selection) {
      schedule(collection, transform);
    } else {
      selection.interrupt().each(function () {
        gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };

  zoom.scaleBy = function (selection, k) {
    zoom.scaleTo(selection, function () {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function (selection, k) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function (selection, x, y) {
    zoom.transform(selection, function () {
      return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function (selection, x, y) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(_transform__WEBPACK_IMPORTED_MODULE_7__["identity"].translate(p[0], p[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
    });
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k,
        y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform__WEBPACK_IMPORTED_MODULE_7__["Transform"](transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, center) {
    transition.on("start.zoom", function () {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function () {
      gesture(this, arguments).end();
    }).tween("zoom", function () {
      var that = this,
          args = arguments,
          g = gesture(that, args),
          e = extent.apply(that, args),
          p = center || centroid(e),
          w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
          a = that.__zoom,
          b = typeof transform === "function" ? transform.apply(that, args) : transform,
          i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function (t) {
        if (t === 1) t = b; // Avoid rounding error on end.
        else {
            var l = i(t),
                k = w / l[2];
            t = new _transform__WEBPACK_IMPORTED_MODULE_7__["Transform"](k, p[0] - l[0] * k, p[1] - l[1] * k);
          }
        g.zoom(null, t);
      };
    });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }

    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function start() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }

      return this;
    },
    zoom: function zoom(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function end() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }

      return this;
    },
    emit: function emit(type) {
      Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["customEvent"])(new _event__WEBPACK_IMPORTED_MODULE_6__["default"](zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this); // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.

    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }

      clearTimeout(g.wheel);
    } // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return; // Otherwise, capture the mouse point and location at the start.
      else {
          g.mouse = [p, t.invert(p)];
          Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
          g.start();
        }

    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        x0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX,
        y0 = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY;
    Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragDisable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    g.mouse = [p, this.__zoom.invert(p)];
    Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
    g.start();

    function mousemoved() {
      Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();

      if (!g.moved) {
        var dx = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientX - x0,
            dy = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }

      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      Object(d3_drag__WEBPACK_IMPORTED_MODULE_1__["dragEnable"])(d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].view, g.moved);
      Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["mouse"])(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (duration > 0) Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).transition().duration(duration).call(schedule, t1, p0);else Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        started,
        n = touches.length,
        i,
        t,
        p;
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();

    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;else if (!g.touch1) g.touch1 = p;
    } // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.


    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);

      if (!g.touch1) {
        g.end();
        p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["select"])(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function () {
        touchstarting = null;
      }, touchDelay);
      Object(d3_transition__WEBPACK_IMPORTED_MODULE_4__["interrupt"])(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length,
        i,
        t,
        p,
        l;
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["default"])();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    for (i = 0; i < n; ++i) {
      t = touches[i], p = Object(d3_selection__WEBPACK_IMPORTED_MODULE_3__["touch"])(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }

    t = g.that.__zoom;

    if (g.touch1) {
      var p0 = g.touch0[0],
          l0 = g.touch0[1],
          p1 = g.touch1[0],
          l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = d3_selection__WEBPACK_IMPORTED_MODULE_3__["event"].changedTouches,
        n = touches.length,
        i,
        t;
    Object(_noevent__WEBPACK_IMPORTED_MODULE_8__["nopropagation"])();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, touchDelay);

    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }

    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else g.end();
  }

  zoom.wheelDelta = function (_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])(+_), zoom) : wheelDelta;
  };

  zoom.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : filter;
  };

  zoom.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])(!!_), zoom) : touchable;
  };

  zoom.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : Object(_constant__WEBPACK_IMPORTED_MODULE_5__["default"])([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function (_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function (_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function (_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function (_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function (_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
});

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/promise-polyfill/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/src/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(setImmediate) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {} // Polyfill for Function.prototype.bind


function bind(fn, thisArg) {
  return function () {
    fn.apply(thisArg, arguments);
  };
}

function Promise(fn) {
  if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  this._state = 0;
  this._handled = false;
  this._value = undefined;
  this._deferreds = [];
  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }

  if (self._state === 0) {
    self._deferreds.push(deferred);

    return;
  }

  self._handled = true;

  Promise._immediateFn(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;

    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }

    var ret;

    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }

    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');

    if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {
      var then = newValue.then;

      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }

    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function () {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }

  self._deferreds = null;
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}
/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */


function doResolve(fn, self) {
  var done = false;

  try {
    fn(function (value) {
      if (done) return;
      done = true;
      resolve(self, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(self, reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function (onFulfilled, onRejected) {
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = function (callback) {
  var constructor = this.constructor;
  return this.then(function (value) {
    return constructor.resolve(callback()).then(function () {
      return value;
    });
  }, function (reason) {
    return constructor.resolve(callback()).then(function () {
      return constructor.reject(reason);
    });
  });
};

Promise.all = function (arr) {
  return new Promise(function (resolve, reject) {
    if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
          var then = val.then;

          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }

        args[i] = val;

        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function (value) {
  if (value && _typeof(value) === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function (resolve) {
    resolve(value);
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
}; // Use polyfill for setImmediate for performance gains


Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
  setImmediate(fn);
} || function (fn) {
  setTimeoutFunc(fn, 0);
};

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ __webpack_exports__["default"] = (Promise);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/topojson-client/index.js":
/*!***********************************************!*\
  !*** ./node_modules/topojson-client/index.js ***!
  \***********************************************/
/*! exports provided: bbox, feature, mesh, meshArcs, merge, mergeArcs, neighbors, quantize, transform, untransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/bbox */ "./node_modules/topojson-client/src/bbox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return _src_bbox__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/feature */ "./node_modules/topojson-client/src/feature.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "feature", function() { return _src_feature__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_mesh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/mesh */ "./node_modules/topojson-client/src/mesh.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mesh", function() { return _src_mesh__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "meshArcs", function() { return _src_mesh__WEBPACK_IMPORTED_MODULE_2__["meshArcs"]; });

/* harmony import */ var _src_merge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/merge */ "./node_modules/topojson-client/src/merge.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return _src_merge__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mergeArcs", function() { return _src_merge__WEBPACK_IMPORTED_MODULE_3__["mergeArcs"]; });

/* harmony import */ var _src_neighbors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/neighbors */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "neighbors", function() { return _src_neighbors__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_quantize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/quantize */ "./node_modules/topojson-client/src/quantize.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return _src_quantize__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_transform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/transform */ "./node_modules/topojson-client/src/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return _src_transform__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_untransform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/untransform */ "./node_modules/topojson-client/src/untransform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "untransform", function() { return _src_untransform__WEBPACK_IMPORTED_MODULE_7__["default"]; });










/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform */ "./node_modules/topojson-client/src/transform.js");

/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  var bbox = topology.bbox;

  function bboxPoint(p0) {
    p1[0] = p0[0], p1[1] = p0[1], t(p1);
    if (p1[0] < x0) x0 = p1[0];
    if (p1[0] > x1) x1 = p1[0];
    if (p1[1] < y0) y0 = p1[1];
    if (p1[1] > y1) y1 = p1[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(bboxGeometry);
        break;

      case "Point":
        bboxPoint(o.coordinates);
        break;

      case "MultiPoint":
        o.coordinates.forEach(bboxPoint);
        break;
    }
  }

  if (!bbox) {
    var t = Object(_transform__WEBPACK_IMPORTED_MODULE_0__["default"])(topology),
        p0,
        p1 = new Array(2),
        name,
        x0 = Infinity,
        y0 = x0,
        x1 = -x0,
        y1 = -x0;
    topology.arcs.forEach(function (arc) {
      var i = -1,
          n = arc.length;

      while (++i < n) {
        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);
        if (p1[0] < x0) x0 = p1[0];
        if (p1[0] > x1) x1 = p1[0];
        if (p1[1] < y0) y0 = p1[1];
        if (p1[1] > y1) y1 = p1[1];
      }
    });

    for (name in topology.objects) {
      bboxGeometry(topology.objects[name]);
    }

    bbox = topology.bbox = [x0, y0, x1, y1];
  }

  return bbox;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (a, x) {
  var lo = 0,
      hi = a.length;

  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;else hi = mid;
  }

  return lo;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/*! exports provided: default, feature, object */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "feature", function() { return feature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "object", function() { return object; });
/* harmony import */ var _reverse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ __webpack_exports__["default"] = (function (topology, o) {
  return o.type === "GeometryCollection" ? {
    type: "FeatureCollection",
    features: o.geometries.map(function (o) {
      return feature(topology, o);
    })
  } : feature(topology, o);
});
function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {
    type: "Feature",
    properties: properties,
    geometry: geometry
  } : bbox == null ? {
    type: "Feature",
    id: id,
    properties: properties,
    geometry: geometry
  } : {
    type: "Feature",
    id: id,
    bbox: bbox,
    properties: properties,
    geometry: geometry
  };
}
function object(topology, o) {
  var transformPoint = Object(_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(topology),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();

    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k].slice(), k));
    }

    if (i < 0) Object(_reverse__WEBPACK_IMPORTED_MODULE_0__["default"])(points, n);
  }

  function point(p) {
    return transformPoint(p.slice());
  }

  function line(arcs) {
    var points = [];

    for (var i = 0, n = arcs.length; i < n; ++i) {
      arc(arcs[i], points);
    }

    if (points.length < 2) points.push(points[0].slice());
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);

    while (points.length < 4) {
      points.push(points[0].slice());
    }

    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type,
        coordinates;

    switch (type) {
      case "GeometryCollection":
        return {
          type: type,
          geometries: o.geometries.map(geometry)
        };

      case "Point":
        coordinates = point(o.coordinates);
        break;

      case "MultiPoint":
        coordinates = o.coordinates.map(point);
        break;

      case "LineString":
        coordinates = line(o.arcs);
        break;

      case "MultiLineString":
        coordinates = o.arcs.map(line);
        break;

      case "Polygon":
        coordinates = polygon(o.arcs);
        break;

      case "MultiPolygon":
        coordinates = o.arcs.map(polygon);
        break;

      default:
        return null;
    }

    return {
      type: type,
      coordinates: coordinates
    };
  }

  return geometry(o);
}

/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (x) {
  return x;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/*! exports provided: default, mergeArcs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeArcs", function() { return mergeArcs; });
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1,
      n = ring.length,
      a,
      b = ring[n - 1],
      area = 0;

  while (++i < n) {
    a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  }

  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  return Object(_feature__WEBPACK_IMPORTED_MODULE_0__["object"])(topology, mergeArcs.apply(this, arguments));
});
function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];
  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;

      case "Polygon":
        extract(o.arcs);
        break;

      case "MultiPolygon":
        o.arcs.forEach(extract);
        break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function (ring) {
      ring.forEach(function (arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea(Object(_feature__WEBPACK_IMPORTED_MODULE_0__["object"])(topology, {
      type: "Polygon",
      arcs: [ring]
    }).coordinates[0]);
  }

  polygons.forEach(function (polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);

      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function (ring) {
          ring.forEach(function (arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });
  polygons.forEach(function (polygon) {
    delete polygon._;
  });
  return {
    type: "MultiPolygon",
    arcs: groups.map(function (polygons) {
      var arcs = [],
          n; // Extract the exterior (unique) arcs.

      polygons.forEach(function (polygon) {
        polygon.forEach(function (ring) {
          ring.forEach(function (arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      }); // Stitch the arcs into one or more rings.

      arcs = Object(_stitch__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs); // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.

      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    })
  };
}

/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/*! exports provided: default, meshArcs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshArcs", function() { return meshArcs; });
/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch */ "./node_modules/topojson-client/src/stitch.js");


/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  return Object(_feature__WEBPACK_IMPORTED_MODULE_0__["object"])(topology, meshArcs.apply(this, arguments));
});
function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) {
    arcs[i] = i;
  }
  return {
    type: "MultiLineString",
    arcs: Object(_stitch__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs)
  };
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({
      i: i,
      g: geom
    });
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection":
        o.geometries.forEach(geometry);
        break;

      case "LineString":
        extract1(o.arcs);
        break;

      case "MultiLineString":
      case "Polygon":
        extract2(o.arcs);
        break;

      case "MultiPolygon":
        extract3(o.arcs);
        break;
    }
  }

  geometry(object);
  geomsByArc.forEach(filter == null ? function (geoms) {
    arcs.push(geoms[0].i);
  } : function (geoms) {
    if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
  });
  return arcs;
}

/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bisect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect */ "./node_modules/topojson-client/src/bisect.js");

/* harmony default export */ __webpack_exports__["default"] = (function (objects) {
  var indexesByArc = {},
      // arc index -> array of object indexes
  neighbors = objects.map(function () {
    return [];
  });

  function line(arcs, i) {
    arcs.forEach(function (a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function (arc) {
      line(arc, i);
    });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function (o) {
      geometry(o, i);
    });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function MultiPolygon(arcs, i) {
      arcs.forEach(function (arc) {
        polygon(arc, i);
      });
    }
  };
  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j],
            ik = indexes[k],
            n;
        if ((n = neighbors[ij])[i = Object(_bisect__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = Object(_bisect__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox */ "./node_modules/topojson-client/src/bbox.js");

/* harmony default export */ __webpack_exports__["default"] = (function (topology, n) {
  if (!((n = Math.floor(n)) >= 2)) throw new Error("n must be ≥2");
  if (topology.transform) throw new Error("already quantized");
  var bb = Object(_bbox__WEBPACK_IMPORTED_MODULE_0__["default"])(topology),
      name,
      dx = bb[0],
      kx = (bb[2] - dx) / (n - 1) || 1,
      dy = bb[1],
      ky = (bb[3] - dy) / (n - 1) || 1;

  function quantizePoint(p) {
    p[0] = Math.round((p[0] - dx) / kx);
    p[1] = Math.round((p[1] - dy) / ky);
  }

  function quantizeGeometry(o) {
    switch (o.type) {
      case "GeometryCollection":
        o.geometries.forEach(quantizeGeometry);
        break;

      case "Point":
        quantizePoint(o.coordinates);
        break;

      case "MultiPoint":
        o.coordinates.forEach(quantizePoint);
        break;
    }
  }

  topology.arcs.forEach(function (arc) {
    var i = 1,
        j = 1,
        n = arc.length,
        pi = arc[0],
        x0 = pi[0] = Math.round((pi[0] - dx) / kx),
        y0 = pi[1] = Math.round((pi[1] - dy) / ky),
        pj,
        x1,
        y1;

    for (; i < n; ++i) {
      pi = arc[i];
      x1 = Math.round((pi[0] - dx) / kx);
      y1 = Math.round((pi[1] - dy) / ky);

      if (x1 !== x0 || y1 !== y0) {
        pj = arc[j++];
        pj[0] = x1 - x0, x0 = x1;
        pj[1] = y1 - y0, y0 = y1;
      }
    }

    if (j < 2) {
      pj = arc[j++];
      pj[0] = 0;
      pj[1] = 0;
    }

    arc.length = j;
  });

  for (name in topology.objects) {
    quantizeGeometry(topology.objects[name]);
  }

  topology.transform = {
    scale: [kx, ky],
    translate: [dx, dy]
  };
  return topology;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (array, n) {
  var t,
      j = array.length,
      i = j - n;

  while (i < --j) {
    t = array[i], array[i++] = array[j], array[j] = t;
  }
});

/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (function (topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1; // Stitch empty arcs first, since they may be subsumed by other arcs.

  arcs.forEach(function (i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i],
        t;

    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });
  arcs.forEach(function (i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f,
        g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;

      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;

      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i],
        p0 = arc[0],
        p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {
      p1[0] += dp[0], p1[1] += dp[1];
    });else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function (i) {
        stitchedArcs[i < 0 ? ~i : i] = 1;
      });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function (i) {
    if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
  });
  return fragments;
});

/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "./node_modules/topojson-client/src/identity.js");

/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  if ((transform = topology.transform) == null) return _identity__WEBPACK_IMPORTED_MODULE_0__["default"];
  var transform,
      x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function (point, i) {
    if (!i) x0 = y0 = 0;
    point[0] = (x0 += point[0]) * kx + dx;
    point[1] = (y0 += point[1]) * ky + dy;
    return point;
  };
});

/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "./node_modules/topojson-client/src/identity.js");

/* harmony default export */ __webpack_exports__["default"] = (function (topology) {
  if ((transform = topology.transform) == null) return _identity__WEBPACK_IMPORTED_MODULE_0__["default"];
  var transform,
      x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function (point, i) {
    if (!i) x0 = y0 = 0;
    var x1 = Math.round((point[0] - dx) / kx),
        y1 = Math.round((point[1] - dy) / ky);
    point[0] = x1 - x0, x0 = x1;
    point[1] = y1 - y0, y0 = y1;
    return point;
  };
});

/***/ }),

/***/ "./node_modules/underscore/underscore.js":
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function () {
  // Baseline setup
  // --------------
  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this; // Save the previous value of the `_` variable.

  var previousUnderscore = root._; // Save bytes in the minified (but not gzipped) version:

  var ArrayProto = Array.prototype,
      ObjProto = Object.prototype,
      FuncProto = Function.prototype; // Create quick reference variables for speed access to core prototypes.

  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty; // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.

  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeBind = FuncProto.bind,
      nativeCreate = Object.create; // Naked function reference for surrogate-prototype-swapping.

  var Ctor = function Ctor() {}; // Create a safe reference to the Underscore object for use below.


  var _ = function _(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  }; // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.


  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }

    exports._ = _;
  } else {} // Current version.


  _.VERSION = '1.8.3'; // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.

  var optimizeCb = function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;

    switch (argCount == null ? 3 : argCount) {
      case 1:
        return function (value) {
          return func.call(context, value);
        };

      case 2:
        return function (value, other) {
          return func.call(context, value, other);
        };

      case 3:
        return function (value, index, collection) {
          return func.call(context, value, index, collection);
        };

      case 4:
        return function (accumulator, value, index, collection) {
          return func.call(context, accumulator, value, index, collection);
        };
    }

    return function () {
      return func.apply(context, arguments);
    };
  }; // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.


  var cb = function cb(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };

  _.iteratee = function (value, context) {
    return cb(value, context, Infinity);
  }; // An internal function for creating assigner functions.


  var createAssigner = function createAssigner(keysFunc, undefinedOnly) {
    return function (obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;

      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;

        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }

      return obj;
    };
  }; // An internal function for creating a new object that inherits from another.


  var baseCreate = function baseCreate(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor();
    Ctor.prototype = null;
    return result;
  };

  var property = function property(key) {
    return function (obj) {
      return obj == null ? void 0 : obj[key];
    };
  }; // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094


  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');

  var isArrayLike = function isArrayLike(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  }; // Collection Functions
  // --------------------
  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.


  _.each = _.forEach = function (obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;

    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);

      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }

    return obj;
  }; // Return the results of applying the iteratee to each element.


  _.map = _.collect = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);

    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);

    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }

    return results;
  }; // Create a reducing function iterating left or right.


  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }

      return memo;
    }

    return function (obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);

      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1; // Determine the initial value if none is provided.


      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }

      return iterator(obj, iteratee, memo, keys, index, length);
    };
  } // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.


  _.reduce = _.foldl = _.inject = createReduce(1); // The right-associative version of reduce, also known as `foldr`.

  _.reduceRight = _.foldr = createReduce(-1); // Return the first value which passes a truth test. Aliased as `detect`.

  _.find = _.detect = function (obj, predicate, context) {
    var key;

    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }

    if (key !== void 0 && key !== -1) return obj[key];
  }; // Return all the elements that pass a truth test.
  // Aliased as `select`.


  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);

    _.each(obj, function (value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });

    return results;
  }; // Return all the elements for which a truth test fails.


  _.reject = function (obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  }; // Determine whether all of the elements match a truth test.
  // Aliased as `all`.


  _.every = _.all = function (obj, predicate, context) {
    predicate = cb(predicate, context);

    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;

    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }

    return true;
  }; // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.


  _.some = _.any = function (obj, predicate, context) {
    predicate = cb(predicate, context);

    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;

    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }

    return false;
  }; // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.


  _.contains = _.includes = _.include = function (obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  }; // Invoke a method (with arguments) on every item in a collection.


  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);

    var isFunc = _.isFunction(method);

    return _.map(obj, function (value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  }; // Convenience version of a common use case of `map`: fetching a property.


  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  }; // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.


  _.where = function (obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  }; // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.


  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  }; // Return the maximum element (or element-based computation).


  _.max = function (obj, iteratee, context) {
    var result = -Infinity,
        lastComputed = -Infinity,
        value,
        computed;

    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);

      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];

        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);

      _.each(obj, function (value, index, list) {
        computed = iteratee(value, index, list);

        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }

    return result;
  }; // Return the minimum element (or element-based computation).


  _.min = function (obj, iteratee, context) {
    var result = Infinity,
        lastComputed = Infinity,
        value,
        computed;

    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);

      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];

        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);

      _.each(obj, function (value, index, list) {
        computed = iteratee(value, index, list);

        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }

    return result;
  }; // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).


  _.shuffle = function (obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);

    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }

    return shuffled;
  }; // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.


  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }

    return _.shuffle(obj).slice(0, Math.max(0, n));
  }; // Sort the object's values by a criterion produced by an iteratee.


  _.sortBy = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;

      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }

      return left.index - right.index;
    }), 'value');
  }; // An internal function used for aggregate "group by" operations.


  var group = function group(behavior) {
    return function (obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);

      _.each(obj, function (value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });

      return result;
    };
  }; // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.


  _.groupBy = group(function (result, value, key) {
    if (_.has(result, key)) result[key].push(value);else result[key] = [value];
  }); // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.

  _.indexBy = group(function (result, value, key) {
    result[key] = value;
  }); // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.

  _.countBy = group(function (result, value, key) {
    if (_.has(result, key)) result[key]++;else result[key] = 1;
  }); // Safely create a real, live array from anything iterable.

  _.toArray = function (obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  }; // Return the number of elements in an object.


  _.size = function (obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  }; // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.


  _.partition = function (obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [],
        fail = [];

    _.each(obj, function (value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });

    return [pass, fail];
  }; // Array Functions
  // ---------------
  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.


  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  }; // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.


  _.initial = function (array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  }; // Get the last element of an array. Passing **n** will return the last N
  // values in the array.


  _.last = function (array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  }; // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.


  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  }; // Trim out all falsy values from an array.


  _.compact = function (array) {
    return _.filter(array, _.identity);
  }; // Internal implementation of a recursive `flatten` function.


  var flatten = function flatten(input, shallow, strict, startIndex) {
    var output = [],
        idx = 0;

    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];

      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0,
            len = value.length;
        output.length += len;

        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }

    return output;
  }; // Flatten out an array, either recursively (by default), or just one level.


  _.flatten = function (array, shallow) {
    return flatten(array, shallow, false);
  }; // Return a version of the array that does not contain the specified value(s).


  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  }; // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.


  _.uniq = _.unique = function (array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }

    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];

    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;

      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }

    return result;
  }; // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.


  _.union = function () {
    return _.uniq(flatten(arguments, true, true));
  }; // Produce an array that contains every item shared between all the
  // passed-in arrays.


  _.intersection = function (array) {
    var result = [];
    var argsLength = arguments.length;

    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;

      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }

      if (j === argsLength) result.push(item);
    }

    return result;
  }; // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.


  _.difference = function (array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  }; // Zip together multiple lists into a single array -- elements that share
  // an index go together.


  _.zip = function () {
    return _.unzip(arguments);
  }; // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices


  _.unzip = function (array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }

    return result;
  }; // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.


  _.object = function (list, values) {
    var result = {};

    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }

    return result;
  }; // Generator function to create the findIndex and findLastIndex functions


  function createPredicateIndexFinder(dir) {
    return function (array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;

      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }

      return -1;
    };
  } // Returns the first index on an array-like that passes a predicate test


  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1); // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.

  _.sortedIndex = function (array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0,
        high = getLength(array);

    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1;else high = mid;
    }

    return low;
  }; // Generator function to create the indexOf and lastIndexOf functions


  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function (array, item, idx) {
      var i = 0,
          length = getLength(array);

      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }

      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }

      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }

      return -1;
    };
  } // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.


  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex); // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).

  _.range = function (start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }

    step = step || 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  }; // Function (ahem) Functions
  // ------------------
  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments


  var executeBound = function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  }; // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.


  _.bind = function (func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);

    var bound = function bound() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };

    return bound;
  }; // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.


  _.partial = function (func) {
    var boundArgs = slice.call(arguments, 1);

    var bound = function bound() {
      var position = 0,
          length = boundArgs.length;
      var args = Array(length);

      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }

      while (position < arguments.length) {
        args.push(arguments[position++]);
      }

      return executeBound(func, bound, this, this, args);
    };

    return bound;
  }; // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.


  _.bindAll = function (obj) {
    var i,
        length = arguments.length,
        key;
    if (length <= 1) throw new Error('bindAll must be passed function names');

    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }

    return obj;
  }; // Memoize an expensive function by storing its results.


  _.memoize = function (func, hasher) {
    var memoize = function memoize(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };

    memoize.cache = {};
    return memoize;
  }; // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.


  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  }; // Defers a function, scheduling it to run after the current call stack has
  // cleared.


  _.defer = _.partial(_.delay, _, 1); // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.

  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};

    var later = function later() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    return function () {
      var now = _.now();

      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;

      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }

      return result;
    };
  }; // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.


  _.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function later() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;

        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function () {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);

      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  }; // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.


  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  }; // Returns a negated version of the passed-in predicate.


  _.negate = function (predicate) {
    return function () {
      return !predicate.apply(this, arguments);
    };
  }; // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.


  _.compose = function () {
    var args = arguments;
    var start = args.length - 1;
    return function () {
      var i = start;
      var result = args[start].apply(this, arguments);

      while (i--) {
        result = args[i].call(this, result);
      }

      return result;
    };
  }; // Returns a function that will only be executed on and after the Nth call.


  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  }; // Returns a function that will only be executed up to (but not including) the Nth call.


  _.before = function (times, func) {
    var memo;
    return function () {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }

      if (times <= 1) func = null;
      return memo;
    };
  }; // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.


  _.once = _.partial(_.before, 2); // Object Functions
  // ----------------
  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.

  var hasEnumBug = !{
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto; // Constructor is a special case.

    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];

      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  } // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`


  _.keys = function (obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];

    for (var key in obj) {
      if (_.has(obj, key)) keys.push(key);
    } // Ahem, IE < 9.


    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }; // Retrieve all the property names of an object.


  _.allKeys = function (obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    } // Ahem, IE < 9.


    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }; // Retrieve the values of an object's properties.


  _.values = function (obj) {
    var keys = _.keys(obj);

    var length = keys.length;
    var values = Array(length);

    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }

    return values;
  }; // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object


  _.mapObject = function (obj, iteratee, context) {
    iteratee = cb(iteratee, context);

    var keys = _.keys(obj),
        length = keys.length,
        results = {},
        currentKey;

    for (var index = 0; index < length; index++) {
      currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }

    return results;
  }; // Convert an object into a list of `[key, value]` pairs.


  _.pairs = function (obj) {
    var keys = _.keys(obj);

    var length = keys.length;
    var pairs = Array(length);

    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }

    return pairs;
  }; // Invert the keys and values of an object. The values must be serializable.


  _.invert = function (obj) {
    var result = {};

    var keys = _.keys(obj);

    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }

    return result;
  }; // Return a sorted list of the function names available on the object.
  // Aliased as `methods`


  _.functions = _.methods = function (obj) {
    var names = [];

    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }

    return names.sort();
  }; // Extend a given object with all the properties in passed-in object(s).


  _.extend = createAssigner(_.allKeys); // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

  _.extendOwn = _.assign = createAssigner(_.keys); // Returns the first key on an object that passes a predicate test

  _.findKey = function (obj, predicate, context) {
    predicate = cb(predicate, context);

    var keys = _.keys(obj),
        key;

    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  }; // Return a copy of the object only containing the whitelisted properties.


  _.pick = function (object, oiteratee, context) {
    var result = {},
        obj = object,
        iteratee,
        keys;
    if (obj == null) return result;

    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);

      iteratee = function iteratee(value, key, obj) {
        return key in obj;
      };

      obj = Object(obj);
    }

    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }

    return result;
  }; // Return a copy of the object without the blacklisted properties.


  _.omit = function (obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);

      iteratee = function iteratee(value, key) {
        return !_.contains(keys, key);
      };
    }

    return _.pick(obj, iteratee, context);
  }; // Fill in a given object with default properties.


  _.defaults = createAssigner(_.allKeys, true); // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.

  _.create = function (prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  }; // Create a (shallow-cloned) duplicate of an object.


  _.clone = function (obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  }; // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.


  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  }; // Returns whether an object has a given set of `key:value` pairs.


  _.isMatch = function (object, attrs) {
    var keys = _.keys(attrs),
        length = keys.length;

    if (object == null) return !length;
    var obj = Object(object);

    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }

    return true;
  }; // Internal recursive comparison function for `isEqual`.


  var eq = function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b; // A strict comparison is necessary because `null == undefined`.

    if (a == null || b == null) return a === b; // Unwrap any wrapped objects.

    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped; // Compare `[[Class]]` names.

    var className = toString.call(a);
    if (className !== toString.call(b)) return false;

    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]': // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')

      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;

      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b; // An `egal` comparison is performed for other numeric values.

        return +a === 0 ? 1 / +a === 1 / b : +a === +b;

      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';

    if (!areArrays) {
      if (_typeof(a) != 'object' || _typeof(b) != 'object') return false; // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.

      var aCtor = a.constructor,
          bCtor = b.constructor;

      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && 'constructor' in a && 'constructor' in b) {
        return false;
      }
    } // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.


    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;

    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    } // Add the first object to the stack of traversed objects.


    aStack.push(a);
    bStack.push(b); // Recursively compare objects and arrays.

    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false; // Deep compare the contents, ignoring non-numeric properties.

      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a),
          key;

      length = keys.length; // Ensure that both objects contain the same number of properties before comparing deep equality.

      if (_.keys(b).length !== length) return false;

      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    } // Remove the first object from the stack of traversed objects.


    aStack.pop();
    bStack.pop();
    return true;
  }; // Perform a deep comparison to check if two objects are equal.


  _.isEqual = function (a, b) {
    return eq(a, b);
  }; // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.


  _.isEmpty = function (obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  }; // Is a given value a DOM element?


  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  }; // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray


  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) === '[object Array]';
  }; // Is a given variable an object?


  _.isObject = function (obj) {
    var type = _typeof(obj);

    return type === 'function' || type === 'object' && !!obj;
  }; // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.


  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  }); // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.


  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return _.has(obj, 'callee');
    };
  } // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).


  if (typeof /./ != 'function' && (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) != 'object') {
    _.isFunction = function (obj) {
      return typeof obj == 'function' || false;
    };
  } // Is a given object a finite number?


  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  }; // Is the given value `NaN`? (NaN is the only number which does not equal itself).


  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj !== +obj;
  }; // Is a given value a boolean?


  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  }; // Is a given value equal to null?


  _.isNull = function (obj) {
    return obj === null;
  }; // Is a given variable undefined?


  _.isUndefined = function (obj) {
    return obj === void 0;
  }; // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).


  _.has = function (obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  }; // Utility Functions
  // -----------------
  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.


  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  }; // Keep the identity function around for default iteratees.


  _.identity = function (value) {
    return value;
  }; // Predicate-generating functions. Often useful outside of Underscore.


  _.constant = function (value) {
    return function () {
      return value;
    };
  };

  _.noop = function () {};

  _.property = property; // Generates a function for a given object that returns a given property.

  _.propertyOf = function (obj) {
    return obj == null ? function () {} : function (key) {
      return obj[key];
    };
  }; // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.


  _.matcher = _.matches = function (attrs) {
    attrs = _.extendOwn({}, attrs);
    return function (obj) {
      return _.isMatch(obj, attrs);
    };
  }; // Run a function **n** times.


  _.times = function (n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);

    for (var i = 0; i < n; i++) {
      accum[i] = iteratee(i);
    }

    return accum;
  }; // Return a random integer between min and max (inclusive).


  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }

    return min + Math.floor(Math.random() * (max - min + 1));
  }; // A (possibly faster) way to get the current timestamp as an integer.


  _.now = Date.now || function () {
    return new Date().getTime();
  }; // List of HTML entities for escaping.


  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };

  var unescapeMap = _.invert(escapeMap); // Functions for escaping and unescaping strings to/from HTML interpolation.


  var createEscaper = function createEscaper(map) {
    var escaper = function escaper(match) {
      return map[match];
    }; // Regexes for identifying a key that needs to be escaped


    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function (string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };

  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap); // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.

  _.result = function (object, property, fallback) {
    var value = object == null ? void 0 : object[property];

    if (value === void 0) {
      value = fallback;
    }

    return _.isFunction(value) ? value.call(object) : value;
  }; // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.


  var idCounter = 0;

  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  }; // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.


  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  }; // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.

  var noMatch = /(.)^/; // Certain characters need to be escaped so that they can be put into a
  // string literal.

  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    "\u2028": 'u2028',
    "\u2029": 'u2029'
  };
  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function escapeChar(match) {
    return '\\' + escapes[match];
  }; // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.


  _.template = function (text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings); // Combine delimiters into one regular expression via alternation.

    var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g'); // Compile the template source, escaping string literals appropriately.

    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      } // Adobe VMs need the match returned to produce the correct offest.


      return match;
    });
    source += "';\n"; // If a variable is not specified, place data values in local scope.

    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';
    source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function template(data) {
      return render.call(this, data, _);
    }; // Provide the compiled source as a convenience for precompilation.


    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';
    return template;
  }; // Add a "chain" function. Start chaining a wrapped Underscore object.


  _.chain = function (obj) {
    var instance = _(obj);

    instance._chain = true;
    return instance;
  }; // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.
  // Helper function to continue chaining intermediate results.


  var result = function result(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  }; // Add your own custom functions to the Underscore object.


  _.mixin = function (obj) {
    _.each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];

      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  }; // Add all of the Underscore functions to the wrapper object.


  _.mixin(_); // Add all mutator Array functions to the wrapper.


  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {
    var method = ArrayProto[name];

    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  }); // Add all accessor Array functions to the wrapper.


  _.each(['concat', 'join', 'slice'], function (name) {
    var method = ArrayProto[name];

    _.prototype[name] = function () {
      return result(this, method.apply(this._wrapped, arguments));
    };
  }); // Extracts the result from a wrapped and chained object.


  _.prototype.value = function () {
    return this._wrapped;
  }; // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.


  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function () {
    return '' + this._wrapped;
  }; // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.


  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return _;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}).call(this);

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./public/js/blacklist.js":
/*!********************************!*\
  !*** ./public/js/blacklist.js ***!
  \********************************/
/*! exports provided: contains, deny */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "contains", function() { return contains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deny", function() { return deny; });
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./d3 */ "./public/js/d3.mjs");



var blacklist = [/dailymail/i, /tamilinstanews/i, /xtremeweatherforecast/i, /oracle77.asuscomm/i];
function contains(referrer) {
  var host = referrer.split("/")[2] || "";
  return blacklist.some(function (regex) {
    return regex.test(host);
  });
}
function deny() {
  return _d3__WEBPACK_IMPORTED_MODULE_0__["select"]("body").attr("style", "font-size: 12em; color: red;").text("XX - contact @cambecc").selectAll("*").remove();
}

/***/ }),

/***/ "./public/js/canvas/twod.js":
/*!**********************************!*\
  !*** ./public/js/canvas/twod.js ***!
  \**********************************/
/*! exports provided: makeStrokeRenderer, makeLayerRenderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeStrokeRenderer", function() { return makeStrokeRenderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeLayerRenderer", function() { return makeLayerRenderer; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/*
 * twod: canvas 2d helpers
 *
 * Copyright (c) 2018 Cameron Beccario
 */




function makeStrokeRenderer(mesh, options) {
  return {
    /**
     * @param {CanvasRenderingContext2D} context
     * @param path D3 path function
     */
    renderTo: function renderTo(context, path) {
      underscore__WEBPACK_IMPORTED_MODULE_0__["extend"](context, options);

      context.beginPath();
      path(mesh);
      context.stroke();
    }
  };
}
function makeLayerRenderer(renderers) {
  return {
    /**
     * @param {CanvasRenderingContext2D} context
     * @param path D3 path function
     */
    renderTo: function renderTo(context, path) {
      _micro__WEBPACK_IMPORTED_MODULE_1__["clearContext"](context);
      path.context(context);
      context.lineJoin = "bevel";
      renderers.forEach(function (r) {
        return r.renderTo(context, path);
      });
    }
  };
}

/***/ }),

/***/ "./public/js/clock.js":
/*!****************************!*\
  !*** ./public/js/clock.js ***!
  \****************************/
/*! exports provided: now, calibration, calibrated */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calibration", function() { return calibration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calibrated", function() { return calibrated; });

/*
 * clock: a singleton wall clock that can be calibrated against the server or explicitly set.
 *
 *   const clock = require("./clock");                                    // uncalibrated clock using system time
 *   const clock = require("./clock").calibration({fixed: new Date()});   // clock set to a fixed time
 *   const clock = require("./clock").calibration({server: "/"});         // clock synchronized with server at url
 *
 *   const calibration = clock.calibration();                             // current calibration
 *   clock.calibrated().then(calibration => console.log(calibration));    // promise for pending calibration
 *
 *   clock.now();  // current time according to clock, in millis.
 *
 * Example calibrations:
 *   {skew: 0}                   // uncalibrated
 *   {fixed: 1448172991313}      // fixed
 *   {skew: 0, δ: 200, θ: 300}   // server calibrated
 */
// CONSIDER: switch this to a registry of Clock objects that each have a name. Default instance can have an
// undefined name. This avoids a singleton instance which is unnecessarily restrictive.

var _now = skewClock;
var _calibration = {
  skew: 0
};

var _p = Promise.resolve(_calibration);

function skewClock() {
  return Date.now() + _calibration.skew;
}

function fixedClock() {
  return _calibration.fixed;
}

function calibrate(url) {
  // Calculate offset θ by measuring round-trip time δ of an HTTPS request against the "Date" header of the
  // response (i.e., the server's time). See https://en.wikipedia.org/wiki/Network_Time_Protocol.
  //
  // server      t1--t2
  //            /      \
  // client   t0        t3
  //
  // The precision of t0 and t3 is in milliseconds whereas t1 and t2 is in seconds. But we don't care because
  // we don't need sub-second accuracy.
  return new Promise(function (resolve, reject) {
    var req = new XMLHttpRequest();
    var t0 = Date.now();

    req.onload = function () {
      var t3 = Date.now();
      var t2 = new Date(req.getResponseHeader("Date")).getTime() || NaN;
      var t1 = t2;
      var δ = t3 - t0 - (t2 - t1);
      var θ = (t1 - t0 + (t2 - t3)) / 2; // Use offset when larger than 10 sec and larger than round-trip by an order of magnitude. Seems legit.

      var skew = Math.abs(θ) > Math.max(10000, δ * 10) ? θ : 0;
      resolve({
        skew: skew,
        δ: δ,
        θ: θ
      });
    };

    req.onerror = reject;
    req.open("HEAD", url);
    req.setRequestHeader("Cache-Control", "no-cache");
    req.send();
  });
}
/** @returns {number} unix time */


function now() {
  return _now();
}
/**
 * @param {Object?} c sets the calibration: {server: url} or {fixed: date}. When server specified, an XHR fetches
 *        the server time. The `calibrated` method returns this operation's promise. Example server url: "/"
 * @returns {Object} current calibration {skew: number} or {fixed: number}, or undefined when setting calibration.
 */

function calibration(c) {
  if (c === undefined) {
    return _calibration;
  }

  if (typeof c.server === "string") {
    _p = calibrate(c.server).then(function (c) {
      _now = skewClock;
      return _calibration = c;
    });
  } else {
    var fixed = +new Date(c.fixed);

    if (fixed === fixed) {
      _now = fixedClock;
      _p = Promise.resolve(_calibration = {
        fixed: fixed
      });
    } else {
      _now = skewClock;
      _p = Promise.resolve(_calibration = {
        skew: +c.skew || 0
      });
    }
  }
}
/** @returns {Promise} a promise for the most recently set calibration. */

function calibrated() {
  return _p;
}

/***/ }),

/***/ "./public/js/consts.mjs":
/*!******************************!*\
  !*** ./public/js/consts.mjs ***!
  \******************************/
/*! exports provided: π, τ, DEG, RAD, MISSING */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "π", function() { return π; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "τ", function() { return τ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEG", function() { return DEG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RAD", function() { return RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MISSING", function() { return MISSING; });
var π = Math.PI;
var τ = 2 * π;
var DEG = 360 / τ;
var RAD = τ / 360;
var MISSING = 7e37;

/***/ }),

/***/ "./public/js/d3.mjs":
/*!**************************!*\
  !*** ./public/js/d3.mjs ***!
  \**************************/
/*! exports provided: nest, set, map, keys, values, entries, dispatch, drag, dragDisable, dragEnable, easeLinear, easeQuad, easeQuadIn, easeQuadOut, easeQuadInOut, easeCubic, easeCubicIn, easeCubicOut, easeCubicInOut, easePoly, easePolyIn, easePolyOut, easePolyInOut, easeSin, easeSinIn, easeSinOut, easeSinInOut, easeExp, easeExpIn, easeExpOut, easeExpInOut, easeCircle, easeCircleIn, easeCircleOut, easeCircleInOut, easeBounce, easeBounceIn, easeBounceOut, easeBounceInOut, easeBack, easeBackIn, easeBackOut, easeBackInOut, easeElastic, easeElasticIn, easeElasticOut, easeElasticInOut, geoArea, geoBounds, geoCentroid, geoCircle, geoClipExtent, geoDistance, geoGraticule, geoGraticule10, geoInterpolate, geoLength, geoPath, geoAlbers, geoAlbersUsa, geoAzimuthalEqualArea, geoAzimuthalEqualAreaRaw, geoAzimuthalEquidistant, geoAzimuthalEquidistantRaw, geoConicConformal, geoConicConformalRaw, geoConicEqualArea, geoConicEqualAreaRaw, geoConicEquidistant, geoConicEquidistantRaw, geoEquirectangular, geoEquirectangularRaw, geoGnomonic, geoGnomonicRaw, geoIdentity, geoProjection, geoProjectionMutator, geoMercator, geoMercatorRaw, geoOrthographic, geoOrthographicRaw, geoStereographic, geoStereographicRaw, geoTransverseMercator, geoTransverseMercatorRaw, geoRotation, geoStream, geoTransform, geoAiry, geoAiryRaw, geoAitoff, geoAitoffRaw, geoArmadillo, geoArmadilloRaw, geoAugust, geoAugustRaw, geoBaker, geoBakerRaw, geoBerghaus, geoBerghausRaw, geoBoggs, geoBoggsRaw, geoBonne, geoBonneRaw, geoBottomley, geoBottomleyRaw, geoBromley, geoBromleyRaw, geoChamberlin, geoChamberlinRaw, geoChamberlinAfrica, geoCollignon, geoCollignonRaw, geoCraig, geoCraigRaw, geoCraster, geoCrasterRaw, geoCylindricalEqualArea, geoCylindricalEqualAreaRaw, geoCylindricalStereographic, geoCylindricalStereographicRaw, geoEckert1, geoEckert1Raw, geoEckert2, geoEckert2Raw, geoEckert3, geoEckert3Raw, geoEckert4, geoEckert4Raw, geoEckert5, geoEckert5Raw, geoEckert6, geoEckert6Raw, geoEisenlohr, geoEisenlohrRaw, geoFahey, geoFaheyRaw, geoFoucaut, geoFoucautRaw, geoGilbert, geoGingery, geoGingeryRaw, geoGinzburg4, geoGinzburg4Raw, geoGinzburg5, geoGinzburg5Raw, geoGinzburg6, geoGinzburg6Raw, geoGinzburg8, geoGinzburg8Raw, geoGinzburg9, geoGinzburg9Raw, geoGringorten, geoGringortenRaw, geoGuyou, geoGuyouRaw, geoHammer, geoHammerRaw, geoHammerRetroazimuthal, geoHammerRetroazimuthalRaw, geoHealpix, geoHealpixRaw, geoHill, geoHillRaw, geoHomolosine, geoHomolosineRaw, geoInterrupt, geoInterruptedBoggs, geoInterruptedHomolosine, geoInterruptedMollweide, geoInterruptedMollweideHemispheres, geoInterruptedSinuMollweide, geoInterruptedSinusoidal, geoKavrayskiy7, geoKavrayskiy7Raw, geoLagrange, geoLagrangeRaw, geoLarrivee, geoLarriveeRaw, geoLaskowski, geoLaskowskiRaw, geoLittrow, geoLittrowRaw, geoLoximuthal, geoLoximuthalRaw, geoMiller, geoMillerRaw, geoModifiedStereographic, geoModifiedStereographicRaw, geoModifiedStereographicAlaska, geoModifiedStereographicGs48, geoModifiedStereographicGs50, geoModifiedStereographicMiller, geoModifiedStereographicLee, geoMollweide, geoMollweideRaw, geoMtFlatPolarParabolic, geoMtFlatPolarParabolicRaw, geoMtFlatPolarQuartic, geoMtFlatPolarQuarticRaw, geoMtFlatPolarSinusoidal, geoMtFlatPolarSinusoidalRaw, geoNaturalEarth, geoNaturalEarthRaw, geoNellHammer, geoNellHammerRaw, geoPatterson, geoPattersonRaw, geoPolyconic, geoPolyconicRaw, geoPolyhedral, geoPolyhedralButterfly, geoPolyhedralCollignon, geoPolyhedralWaterman, geoProject, geoGringortenQuincuncial, geoPeirceQuincuncial, geoPierceQuincuncial, geoQuantize, geoQuincuncial, geoRectangularPolyconic, geoRectangularPolyconicRaw, geoRobinson, geoRobinsonRaw, geoSatellite, geoSatelliteRaw, geoSinuMollweide, geoSinuMollweideRaw, geoSinusoidal, geoSinusoidalRaw, geoStitch, geoTimes, geoTimesRaw, geoTwoPointAzimuthal, geoTwoPointAzimuthalRaw, geoTwoPointAzimuthalUsa, geoTwoPointEquidistant, geoTwoPointEquidistantRaw, geoTwoPointEquidistantUsa, geoVanDerGrinten, geoVanDerGrintenRaw, geoVanDerGrinten2, geoVanDerGrinten2Raw, geoVanDerGrinten3, geoVanDerGrinten3Raw, geoVanDerGrinten4, geoVanDerGrinten4Raw, geoWagner4, geoWagner4Raw, geoWagner6, geoWagner6Raw, geoWagner7, geoWagner7Raw, geoWiechel, geoWiechelRaw, geoWinkel3, geoWinkel3Raw, interpolate, interpolateArray, interpolateBasis, interpolateBasisClosed, interpolateDate, interpolateNumber, interpolateObject, interpolateRound, interpolateString, interpolateTransformCss, interpolateTransformSvg, interpolateZoom, interpolateRgb, interpolateRgbBasis, interpolateRgbBasisClosed, interpolateHsl, interpolateHslLong, interpolateLab, interpolateHcl, interpolateHclLong, interpolateCubehelix, interpolateCubehelixLong, quantize, request, html, json, text, xml, csv, tsv, creator, local, matcher, mouse, namespace, namespaces, select, selectAll, selection, selector, selectorAll, touch, touches, window, event, customEvent, zoom, zoomTransform, zoomIdentity */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3_collection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-collection */ "./node_modules/d3-collection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nest", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["nest"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "set", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["set"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "map", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["map"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keys", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["keys"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "values", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["values"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entries", function() { return d3_collection__WEBPACK_IMPORTED_MODULE_0__["entries"]; });

/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dispatch", function() { return d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["dispatch"]; });

/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ "./node_modules/d3-drag/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "drag", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_2__["drag"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragDisable", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_2__["dragDisable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dragEnable", function() { return d3_drag__WEBPACK_IMPORTED_MODULE_2__["dragEnable"]; });

/* harmony import */ var d3_ease__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-ease */ "./node_modules/d3-ease/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeLinear", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeLinear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuad", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeQuad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeQuadIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeQuadOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeQuadInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeQuadInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubic", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCubic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCubicIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCubicOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCubicInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCubicInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePoly", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easePoly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easePolyIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easePolyOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easePolyInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easePolyInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSin", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeSin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeSinIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeSinOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeSinInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeSinInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExp", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeExp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeExpIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeExpOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeExpInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeExpInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircle", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCircleIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCircleOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeCircleInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeCircleInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounce", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBounceIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBounceOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBounceInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBounceInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBack", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBackIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBackOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeBackInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeBackInOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElastic", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeElastic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticIn", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeElasticIn"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeElasticOut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "easeElasticInOut", function() { return d3_ease__WEBPACK_IMPORTED_MODULE_3__["easeElasticInOut"]; });

/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBounds", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoBounds"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCentroid", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoCentroid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCircle", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoCircle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoClipExtent", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoClipExtent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoDistance", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoDistance"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoGraticule"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGraticule10", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoGraticule10"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterpolate", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoInterpolate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLength", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoLength"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPath", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbers", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoAlbers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAlbersUsa", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoAlbersUsa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoAzimuthalEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEqualAreaRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoAzimuthalEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistant", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoAzimuthalEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAzimuthalEquidistantRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoAzimuthalEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformal", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoConicConformal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicConformalRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoConicConformalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualArea", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoConicEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEqualAreaRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoConicEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistant", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoConicEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoConicEquidistantRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoConicEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangular", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoEquirectangular"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEquirectangularRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoEquirectangularRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoGnomonic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGnomonicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoGnomonicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoIdentity", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoIdentity"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjection", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoProjection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProjectionMutator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoProjectionMutator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoMercator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMercatorRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoMercatorRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoOrthographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoOrthographicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoOrthographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographic", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoStereographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStereographicRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercator", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoTransverseMercator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransverseMercatorRaw", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoTransverseMercatorRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRotation", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoRotation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStream", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoStream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTransform", function() { return d3_geo__WEBPACK_IMPORTED_MODULE_4__["geoTransform"]; });

/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiry", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoAiry"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAiryRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoAiryRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoff", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoAitoff"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAitoffRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoAitoffRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadillo", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoArmadillo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoArmadilloRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoArmadilloRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugust", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoAugust"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoAugustRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoAugustRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBaker", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBaker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBakerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBakerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghaus", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBerghaus"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBerghausRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBerghausRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggs", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBoggs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBoggsRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBoggsRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonne", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBonne"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBonneRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBonneRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomley", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBottomley"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBottomleyRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBottomleyRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromley", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBromley"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoBromleyRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoBromleyRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlin", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoChamberlin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoChamberlinRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoChamberlinAfrica", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoChamberlinAfrica"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignon", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCollignon"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCollignonRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCollignonRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraig", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCraig"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraigRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCraigRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCraster", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCraster"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCrasterRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCrasterRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualArea", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCylindricalEqualArea"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalEqualAreaRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCylindricalEqualAreaRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCylindricalStereographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoCylindricalStereographicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoCylindricalStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert1Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert1Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert2Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert2Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert3Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert3Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert5"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert5Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert5Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert6"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEckert6Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEckert6Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohr", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEisenlohr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoEisenlohrRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoEisenlohrRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFahey", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoFahey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFaheyRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoFaheyRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucaut", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoFoucaut"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoFoucautRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoFoucautRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGilbert", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGilbert"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingery", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGingery"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGingeryRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGingeryRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg5"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg5Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg5Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg6"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg6Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg6Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg8"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg8Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg8Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg9"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGinzburg9Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGinzburg9Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringorten", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGringorten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGringortenRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyou", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGuyou"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGuyouRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGuyouRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammer", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHammer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHammerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHammerRetroazimuthal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHammerRetroazimuthalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHammerRetroazimuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpix", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHealpix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHealpixRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHealpixRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHill", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHill"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHillRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHillRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosine", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHomolosine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoHomolosineRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoHomolosineRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterrupt", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoInterrupt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedBoggs", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoInterruptedBoggs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedHomolosine", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoInterruptedHomolosine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoInterruptedMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedMollweideHemispheres", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoInterruptedMollweideHemispheres"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinuMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoInterruptedSinuMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoInterruptedSinusoidal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoInterruptedSinusoidal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoKavrayskiy7"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoKavrayskiy7Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoKavrayskiy7Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrange", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLagrange"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLagrangeRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLagrangeRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarrivee", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLarrivee"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLarriveeRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLarriveeRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowski", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLaskowski"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLaskowskiRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLaskowskiRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrow", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLittrow"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLittrowRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLittrowRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLoximuthal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoLoximuthalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoLoximuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMiller", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMiller"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMillerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMillerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoModifiedStereographic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoModifiedStereographicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicAlaska", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoModifiedStereographicAlaska"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs48", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoModifiedStereographicGs48"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicGs50", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoModifiedStereographicGs50"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicMiller", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoModifiedStereographicMiller"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoModifiedStereographicLee", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoModifiedStereographicLee"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMollweideRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMollweideRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMtFlatPolarParabolic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarParabolicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMtFlatPolarParabolicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuartic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMtFlatPolarQuartic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarQuarticRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMtFlatPolarQuarticRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMtFlatPolarSinusoidal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoMtFlatPolarSinusoidalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoMtFlatPolarSinusoidalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarth", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoNaturalEarth"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNaturalEarthRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoNaturalEarthRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammer", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoNellHammer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoNellHammerRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoNellHammerRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPatterson", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPatterson"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPattersonRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPattersonRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPolyconic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyconicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPolyconicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedral", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPolyhedral"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralButterfly", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPolyhedralButterfly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralCollignon", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPolyhedralCollignon"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPolyhedralWaterman", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPolyhedralWaterman"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoProject", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoProject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoGringortenQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoGringortenQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPeirceQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPeirceQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoPierceQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoPierceQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuantize", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoQuantize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoQuincuncial", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoQuincuncial"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconic", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoRectangularPolyconic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRectangularPolyconicRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoRectangularPolyconicRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinson", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoRobinson"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoRobinsonRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoRobinsonRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatellite", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoSatellite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSatelliteRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoSatelliteRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweide", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoSinuMollweide"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinuMollweideRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoSinuMollweideRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoSinusoidal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoSinusoidalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoSinusoidalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoStitch", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoStitch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimes", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTimes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTimesRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTimesRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthal", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTwoPointAzimuthal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTwoPointAzimuthalRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointAzimuthalUsa", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTwoPointAzimuthalUsa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistant", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTwoPointEquidistant"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTwoPointEquidistantRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoTwoPointEquidistantUsa", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoTwoPointEquidistantUsa"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrinten"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrintenRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrintenRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrinten2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten2Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrinten2Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrinten3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten3Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrinten3Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrinten4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoVanDerGrinten4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoVanDerGrinten4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWagner4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner4Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWagner4Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWagner6"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner6Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWagner6Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWagner7"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWagner7Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWagner7Raw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechel", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWiechel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWiechelRaw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWiechelRaw"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWinkel3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "geoWinkel3Raw", function() { return d3_geo_projection__WEBPACK_IMPORTED_MODULE_5__["geoWinkel3Raw"]; });

/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateArray", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasis", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateBasisClosed", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateBasisClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateDate", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateDate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateNumber", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateObject", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRound", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateRound"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateString", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformCss", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateTransformCss"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateTransformSvg", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateTransformSvg"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateZoom", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateZoom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgb", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateRgb"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasis", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateRgbBasis"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateRgbBasisClosed", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateRgbBasisClosed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHsl", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateHsl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHslLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateHslLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateLab", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateLab"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHcl", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateHcl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateHclLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateHclLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelix", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateCubehelix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "interpolateCubehelixLong", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["interpolateCubehelixLong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["quantize"]; });

/* harmony import */ var d3_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-request */ "./node_modules/d3-request/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "request", function() { return d3_request__WEBPACK_IMPORTED_MODULE_7__["request"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "html", function() { return d3_request__WEBPACK_IMPORTED_MODULE_7__["html"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "json", function() { return d3_request__WEBPACK_IMPORTED_MODULE_7__["json"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "text", function() { return d3_request__WEBPACK_IMPORTED_MODULE_7__["text"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "xml", function() { return d3_request__WEBPACK_IMPORTED_MODULE_7__["xml"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "csv", function() { return d3_request__WEBPACK_IMPORTED_MODULE_7__["csv"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tsv", function() { return d3_request__WEBPACK_IMPORTED_MODULE_7__["tsv"]; });

/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-selection */ "./node_modules/d3-selection/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "creator", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["creator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "local", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["local"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matcher", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["matcher"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mouse", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["mouse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespace", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["namespace"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["namespaces"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "select", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["select"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectAll", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["selectAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selection", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["selection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selector", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["selector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "selectorAll", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["selectorAll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touch", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["touch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "touches", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["touches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "event", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["event"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "customEvent", function() { return d3_selection__WEBPACK_IMPORTED_MODULE_8__["customEvent"]; });

/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-zoom */ "./node_modules/d3-zoom/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_9__["zoom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomTransform", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_9__["zoomTransform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zoomIdentity", function() { return d3_zoom__WEBPACK_IMPORTED_MODULE_9__["zoomIdentity"]; });

/**
 * @license
 *
 * Copyright 2010-2016 Mike Bostock
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the author nor the names of contributors may be used to
 *   endorse or promote products derived from this software without specific prior
 *   written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* Custom D3 Build */











/***/ }),

/***/ "./public/js/decoder.mjs":
/*!*******************************!*\
  !*** ./public/js/decoder.mjs ***!
  \*******************************/
/*! exports provided: decodeUTF8, varpackDecode, undeltaPlane, dequantize, decodePpak, decodePpakBlock, decodeEpak, decodePackedDeltaRle */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeUTF8", function() { return decodeUTF8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "varpackDecode", function() { return varpackDecode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "undeltaPlane", function() { return undeltaPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dequantize", function() { return dequantize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePpak", function() { return decodePpak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePpakBlock", function() { return decodePpakBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeEpak", function() { return decodeEpak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePackedDeltaRle", function() { return decodePackedDeltaRle; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math */ "./public/js/math.mjs");
/**
 * decoder - methods for decoding weather data
 *
 * Copyright (c) 2018 Cameron Beccario
 */

/**
 * Decodes a UTF8 string from an array of bytes.
 *
 * @param {Uint8Array} bytes an array of bytes
 * @returns {String} the decoded String
 */

function decodeUTF8(bytes) {
  var charCodes = [];

  for (var i = 0; i < bytes.length;) {
    var b = bytes[i++];

    switch (b >> 4) {
      case 0xc:
      case 0xd:
        b = (b & 0x1f) << 6 | bytes[i++] & 0x3f;
        break;

      case 0xe:
        b = (b & 0x0f) << 12 | (bytes[i++] & 0x3f) << 6 | bytes[i++] & 0x3f;
        break;

      default: // use value as-is

    }

    charCodes.push(b);
  }

  return String.fromCharCode.apply(null, charCodes);
}
/*
function blockView(data, cols, rows) {
    const area = cols * rows;
    return {
        x: function(i) {
            return i % cols;
        },
        y: function(i) {
            return Math.floor(i / cols) % rows;
        },
        z: function(i) {
            return Math.floor(i / area);
        },
        valueAt: function(x, y, z) {
            if (0 <= x && x < cols) {
                if (0 <= y && y < rows) {
                    const i = z * area + y * cols + x;
                    if (0 <= z && i < data.length) {
                        return data[i];
                    }
                }
            }
            return Number.NaN;
        }
    };
}
*/

function varpackDecode(values, bytes) {
  var i = 0,
      j = 0;

  while (i < bytes.length) {
    var b = bytes[i++];

    if (b < 128) {
      b = b << 25 >> 25;
    } else {
      switch (b >> 4) {
        case 0x8:
        case 0x9:
        case 0xa:
        case 0xb:
          b = b << 26 >> 18 | bytes[i++];
          break;

        case 0xc:
        case 0xd:
          b = b << 27 >> 11 | bytes[i++] << 8 | bytes[i++];
          break;

        case 0xe:
          b = b << 28 >> 4 | bytes[i++] << 16 | bytes[i++] << 8 | bytes[i++];
          break;

        case 0xf:
          if (b === 255) {
            for (var run = 1 + bytes[i++]; run > 0; run--) {
              values[j++] = NaN;
            }

            continue;
          } else {
            b = bytes[i++] << 24 | bytes[i++] << 16 | bytes[i++] << 8 | bytes[i++];
          }

          break;
      }
    }

    values[j++] = b;
  }

  return values;
}
function undeltaPlane(values, cols, rows, grids) {
  var x, y, z, i, j, k, p;

  for (z = 0; z < grids; z++) {
    k = z * cols * rows;

    for (x = 1; x < cols; x++) {
      i = k + x;
      p = values[i - 1];
      values[i] += p === p ? p : 0;
    }

    for (y = 1; y < rows; y++) {
      j = k + y * cols;
      p = values[j - cols];
      values[j] += p === p ? p : 0;

      for (x = 1; x < cols; x++) {
        i = j + x;
        var a = values[i - 1];
        var b = values[i - cols];
        var c = values[i - cols - 1];
        p = a + b - c;
        values[i] += p === p ? p : a === a ? a : b === b ? b : c === c ? c : 0;
      }
    }
  }

  return values;
}
function dequantize(values, scaleFactor) {
  var m = Math.pow(10, scaleFactor);

  for (var i = 0; i < values.length; i++) {
    var v = values[i];
    values[i] = v === v ? v / m : 7e37;
  }

  return values;
}
/**
 * Decodes a quantized delta-plane varpack array of floats.
 *
 * @param {Uint8Array} bytes the encoded values as an array of bytes
 * @param cols size of the x dimension
 * @param rows size of the y dimension
 * @param grids size of the z dimension
 * @param scaleFactor number of decimal digits after (+) or before (-) the decimal point to retain
 * @returns {Float32Array} the decoded values
 */

function decodePpak(bytes, cols, rows, grids, scaleFactor) {
  var values = new Float32Array(cols * rows * grids);
  varpackDecode(values, bytes);
  undeltaPlane(values, cols, rows, grids);
  dequantize(values, scaleFactor);
  return values;
}
/**
 * Decodes a ppak block from a buffer having the format:
 * <pre>
 *       int32   int32   int32      float32     byte[]
 *     [ cols ][ rows ][ grids ][ scaleFactor ][ data ]
 *      ----------------------------------------------
 *                        length
 * </pre>
 * All multi-byte values are BE. The number of resulting values is cols * rows * grids.
 *
 * @param {ArrayBuffer} buffer the buffer
 * @param offset buffer byte offset
 * @param length the byte length of the block
 * @returns {{metadata: *, values: Float32Array}} the decoded values
 */

function decodePpakBlock(buffer, offset, length) {
  var view = new DataView(buffer, offset, length);
  var bytes = new Uint8Array(buffer, offset + 16, length - 16);
  var cols = view.getInt32(0);
  var rows = view.getInt32(4);
  var grids = view.getInt32(8);
  var scaleFactor = view.getFloat32(12);
  return {
    metadata: {
      type: "ppak",
      cols: cols,
      rows: rows,
      grids: grids,
      scaleFactor: scaleFactor
    },
    values: decodePpak(bytes, cols, rows, grids, scaleFactor)
  };
}
/**
 * Earth-Pack (EPAK) format:
 * <pre>
 *     head  := "head" (BE alpha-4) length (BE int) json (UTF-8 JSON string)
 *     block :=  type  (BE alpha-4) length (BE int) data (byte[])
 *     tail  := "tail"
 *     file  :=  head [block]* tail
 *
 *     head                                  block                           tail
 *     ------------------------------------  ------------------------------  ------
 *    ["head"][0x00000003][0x10, 0x11, 0x12]["ppak"][0x00000002][0xff, 0xff]["tail"]
 *             ----------  ----------------  ------  ----------  ----------
 *               length          json         type     length       data
 * </pre>
 *
 * @param {ArrayBuffer} buffer the buffer to decode
 * @param {Object} [options] decoding options: {headerOnly: boolean}
 * @returns {{header: *, blocks: Array, metadata: Array}} the decoded values
 */

function decodeEpak(buffer, options) {
  var headerOnly = !!(options || {}).headerOnly;
  var i = 0;
  var view = new DataView(buffer);
  var head = decodeUTF8(new Uint8Array(buffer, i, 4));
  i += 4;

  if (head !== "head") {
    throw new Error("expected 'head' but found '" + head + "'");
  }

  var length = view.getInt32(i);
  i += 4;
  var header = JSON.parse(decodeUTF8(new Uint8Array(buffer, i, length)));
  i += length;
  var block;
  var blocks = [];
  var metadata = [];
  var type;

  while ((type = decodeUTF8(new Uint8Array(buffer, i, 4))) !== "tail" && !headerOnly) {
    i += 4;
    length = view.getInt32(i);
    i += 4;

    switch (type) {
      case "ppak":
        block = decodePpakBlock(buffer, i, length);
        break;

      default:
        throw new Error("unknown block type: " + type);
    }

    blocks.push(block.values);
    metadata.push(block.metadata);
    i += length;
  }

  return {
    header: header,
    blocks: blocks,
    metadata: metadata
  };
}
/**
 * Decode an array having "Packed Delta RLE" encoding. This has three steps:
 *
 *    1. Unroll runs:
 *        Replace every tuple element Si := [v, X] with the run of elements it represents: v0, .., v{X-1}
 *
 *    2. Convert running deltas into absolute values:
 *        [D0, .., D{N-1}]  =>  [T0, .., T{N-1}] where Ti := T{i-1} + Di
 *                                                     T0 := D0
 *                                                     Ti == Di when T{i-1} is null or NaN
 *
 *    3. Unpack each value:
 *        [T0, .., T{N-1}]  =>  [R0, .., R{N-1}] where Ri := Ti * scaleFactor + addOffset
 *
 * NaN and null are replaced with 7e37.
 *
 * Example:
 *     [1,[2,5],3,[null,2],4]  ->  [1,2,2,2,2,2,3,null,null,4]  ->  [1,3,5,7,9,11,14,7e37,7e37,4]
 *
 * @param {array} data the encoded array of data.
 * @param {number} scaleFactor the amount to multiply each data point by.
 * @param {number} addOffset the amount to add to each data point.
 * @param {number} length the expected length of the decoded data array.
 * @returns {Float32Array} the array of decoded data.
 */

function decodePackedDeltaRle(data, scaleFactor, addOffset, length) {
  var result = new Float32Array(length);
  var j = 0;

  for (var i = 0, prev = 0; i < data.length && j < length; i++) {
    var raw = data[i];
    var isRun = Array.isArray(raw);
    var val = isRun ? raw[0] : raw;
    var stop = isRun ? Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(+raw[1] + j, j, length) : j + 1; // guard against malicious run lengths

    var v = +val;

    if (val === null || v !== v) {
      if (!(j < stop)) {
        continue; // ignore zero or NaN length runs
      }

      while (j < stop) {
        result[j++] = 7e37;
      }

      prev = 0;
    } else {
      while (j < stop) {
        var x = (prev = prev + v) * scaleFactor + addOffset;
        result[j++] = x === x ? x : 7e37;
      }
    }
  } // Fill remaining space in the result array, if any.


  while (j < length) {
    result[j++] = 7e37;
  }

  return result;
}

/***/ }),

/***/ "./public/js/earth.js":
/*!****************************!*\
  !*** ./public/js/earth.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return earth; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts */ "./public/js/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ "./public/js/math.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./d3 */ "./public/js/d3.mjs");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/index.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./micro */ "./public/js/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utc */ "./public/js/utc.mjs");
/* harmony import */ var _globes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./globes */ "./public/js/globes.js");
/* harmony import */ var _products__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./products */ "./public/js/products.js");
/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./keyboard */ "./public/js/keyboard.js");
/* harmony import */ var _canvas_twod__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./canvas/twod */ "./public/js/canvas/twod.js");
/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lang */ "./public/js/lang.js");
/* harmony import */ var _gl_glCheck__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gl/glCheck */ "./public/js/gl/glCheck.js");
/* harmony import */ var _gl_fastoverlay__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./gl/fastoverlay */ "./public/js/gl/fastoverlay.js");
/**
 * earth - a project to visualize global weather data.
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
















function earth(app) {
  var log = app.log;
  var bridge = app.bridge;
  var products = Object(_products__WEBPACK_IMPORTED_MODULE_9__["default"])(app);
  log.debug("start...");
  var MAX_TASK_TIME = 150; // amount of time before a task yields control (millis)

  var MIN_SLEEP_TIME = 10; // amount of time a task waits before resuming (millis)

  var MIN_MOVE = 6; // slack before a drag operation beings (pixels)

  var MOVE_END_WAIT = 750; // time to wait for a move operation to be considered done (millis)

  var INTENSITY_SCALE_STEP = 10; // step size of particle intensity color scale

  var PARTICLE_LINE_WIDTH = 1; // line width of a drawn particle

  var PARTICLE_MULTIPLIER = 7; // particle count scalar (completely arbitrary--this values looks nice)

  var PARTICLE_REDUCTION = 0.75; // reduce particle count to this much of normal for mobile devices

  var FRAME_RATE = 40; // desired milliseconds per frame

  var REMAINING = "▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫▫"; // glyphs for remaining progress bar

  var COMPLETED = "▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪▪"; // glyphs for completed progress bar

  var NULL_WIND_VECTOR = [7e37, 7e37, 7e37]; // undefined location outside the vector field [u, v, m]

  var HOLE_VECTOR = [7e37, 7e37, 0]; // signifies a hole in the vector field

  var TRANSPARENT_BLACK = [0, 0, 0, 0]; // singleton 0 rgba

  var view = _micro__WEBPACK_IMPORTED_MODULE_6__["view"]();
  /**
   * An object to display various types of messages to the user.
   */

  var report = function () {
    // Route all messages to bridge if supported.
    var s = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#status"),
        p = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#progress"),
        total = REMAINING.length;

    var showMessage = _micro__WEBPACK_IMPORTED_MODULE_6__["bindup"](bridge, "showMessage") || function (msg
    /*, isError*/
    ) {
      s.text(msg);
    };

    var showProgress = _micro__WEBPACK_IMPORTED_MODULE_6__["bindup"](bridge, "showProgress") || function (amount) {
      // amount must be int
      if (0 <= amount && amount < 100) {
        var i = Math.ceil(amount / 100 * total);
        var bar = COMPLETED.substr(0, i) + REMAINING.substr(0, total - i);
        return p.classed("invisible", false).text(bar);
      }

      return p.classed("invisible", true).text(""); // progress complete
    };

    return {
      status: function status(msg) {
        return s.classed("bad") ? s : showMessage(msg, false); // errors are sticky until reset
      },
      error: function error(err, context) {
        var msg = err.status ? "".concat(err.status, " ").concat(err.message) : err.message || err;

        switch (err.status) {
          case -1:
            msg = "Server Down";
            break;

          case 404:
            msg = "No Data";
            break;
        }

        if (context) log.error("context", context + "");
        log.error("error", err);
        if (err.stack) log.error("stack", err.stack);
        s.classed("bad", true);
        showMessage(msg, true);
      },
      reset: function reset() {
        s.classed("bad", false);
        showMessage("", false);
      },
      progress: showProgress
    };
  }();

  function newAgent(name) {
    return _micro__WEBPACK_IMPORTED_MODULE_6__["newAgent"](name).on({
      "reject": report.error,
      "fail": report.error
    });
  } // Construct the page's main internal components:


  var configuration = _micro__WEBPACK_IMPORTED_MODULE_6__["buildConfiguration"](_globes__WEBPACK_IMPORTED_MODULE_8__, products.overlayTypes()); // holds the page's current configuration settings

  var inputController = buildInputController(); // interprets drag/zoom operations

  var meshAgent = newAgent("mesh"); // map data for the earth

  var globeAgent = newAgent("globe"); // the model of the globe

  var gridAgent = newAgent("grid"); // the grid of weather data

  var rendererAgent = newAgent("renderer"); // the globe SVG renderer
  // const argoAgent = newAgent("argo");             // SVG argo maker

  var fieldAgent = newAgent("field"); // the interpolated wind vector field

  var fastoverlayAgent = newAgent("fastoverlay"); // the interpolated wind vector field

  var animatorAgent = newAgent("animator"); // the wind animator

  var overlayAgent = newAgent("overlay"); // color overlay over the animation

  var overlayGridAgent = newAgent("overlayGrid"); // grid points drawn on the overlay

  var buttonStateNotifier = newAgent("button"); // notifies consumers of button state changes

  /**
   * The input controller is an object that translates move operations (drag and/or zoom) into mutations of the
   * current globe's projection, and emits events so other page components can react to these move operations.
   *
   * D3's built-in Zoom behavior is used to bind to the document's drag/zoom events, and the input controller
   * interprets D3's events as move operations on the globe. This method is complicated due to the complex
   * event behavior that occurs during drag and zoom.
   *
   * D3 move operations usually occur as "start" -> ("zoom")* -> "end" event chain. During "zoom" events
   * the scale and mouse may change, implying a zoom or drag operation accordingly. These operations are quite
   * noisy. What should otherwise be one smooth continuous zoom is usually comprised of several "start" ->
   * "zoom" -> "end" event chains. A debouncer is used to eliminate the noise by waiting a short period of
   * time to ensure the user has finished the move operation.
   *
   * The "zoom" events may not occur; a simple click operation occurs as either "start" -> "end" or "start" ->
   * "zoom" -> "end". There is additional logic for other corner cases, such as spurious drags which move the globe
   * just a few pixels (most likely unintentional), and the tendency for some touch devices to issue events out of
   * order: "zoom" -> "start" -> "end" (though this may no longer occur with D3 v4).
   *
   * This object emits clean "moveStart" -> ("move")* -> "moveEnd" events for move/zoom operations, and "click"
   * events for everything else.
   */

  function buildInputController() {
    var _globe,
        op = null,
        prevClick = {
      time: 0,
      mouse: [0, 0]
    };
    /**
     * @returns {Object} an object to represent the state for one move operation.
     */


    function newOp(startMouse, startScale) {
      return {
        type: "click",
        // initially assumed to be a click operation
        startMouse: startMouse,
        startScale: startScale,
        manipulator: _globe.manipulator(startMouse, startScale)
      };
    }

    function start() {
      op = op || newOp(_d3__WEBPACK_IMPORTED_MODULE_3__["mouse"](this), _globe.projection.scale()); // a new operation begins
    }

    function step() {
      var transform = _d3__WEBPACK_IMPORTED_MODULE_3__["event"].transform || {};
      var currentMouse = _d3__WEBPACK_IMPORTED_MODULE_3__["mouse"](this),
          currentScale = _micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](transform.k, _globe.projection.scale());
      op = op || newOp(currentMouse, 1); // Fix bug on some browsers where zoomstart fires out of order.

      if (op.type === "click") {
        var distanceMoved = Object(_math__WEBPACK_IMPORTED_MODULE_1__["distance"])(currentMouse, op.startMouse);

        if (currentScale === op.startScale && (distanceMoved < MIN_MOVE || isNaN(distanceMoved))) {
          // to reduce annoyance, ignore op if mouse has barely moved and no zoom is occurring
          return;
        }

        dispatch.trigger("moveStart");
        op.type = "drag";
      }

      if (currentScale !== op.startScale || isNaN(currentMouse[0])) {
        // Whenever a scale change is detected, or mouse is undefined (such as during double-click),
        // stickily switch to a zoom operation.
        op.type = "zoom";
      } // when zooming, ignore whatever the mouse is doing--really cleans up behavior on touch devices


      op.manipulator.move(op.type === "zoom" ? null : currentMouse, currentScale);
      dispatch.trigger("move");
    }

    function end() {
      if (op === null) return;
      op.manipulator.end();

      if (op.type === "click") {
        // Ignore clicks that occur soon after the previous click and in the same location. Reduces noise
        // on touch devices where taps trigger both touchstart and mousedown events (i.e., two clicks).
        // CONSIDER: is this still necessary after d3 v4 upgrade?
        if (Date.now() - prevClick.time > 500 || Object(_math__WEBPACK_IMPORTED_MODULE_1__["distance"])(prevClick.mouse, op.startMouse) >= MIN_MOVE) {
          dispatch.trigger("click", op.startMouse, _globe.projection.invert(op.startMouse) || []);
          prevClick = {
            time: Date.now(),
            mouse: op.startMouse
          };
        }
      } else {
        scheduleMoveEnd();
      }

      op = null; // the drag/zoom/click operation is over
    }

    var moveEnding = null;

    function scheduleMoveEnd() {
      if (moveEnding) {
        clearTimeout(moveEnding);
      }

      moveEnding = setTimeout(function () {
        moveEnding = null;

        if (!op || op.type !== "drag" && op.type !== "zoom") {
          configuration.save({
            orientation: _globe.orientation()
          }, {
            source: "moveEnd"
          });
          dispatch.trigger("moveEnd");
        }
      }, MOVE_END_WAIT); // wait for a bit to decide if user has stopped moving the globe
    }

    var zoom = _d3__WEBPACK_IMPORTED_MODULE_3__["zoom"]().on("start", start).on("zoom", step).on("end", end);
    var drag = _d3__WEBPACK_IMPORTED_MODULE_3__["drag"]().on("start", start).on("drag", step).on("end", end); // desktop: scroll -> zoom,   drag -> drag
    // mobile:   pinch -> zoom, scroll -> drag

    var display = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#display");

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isFixedMode"]()) {
      display.on("click", function () {
        start.call(this);
        end.call(this);
      }); // support just clicks
    } else if (_micro__WEBPACK_IMPORTED_MODULE_6__["isEmbeddedInIFrame"]() && !_micro__WEBPACK_IMPORTED_MODULE_6__["isKioskMode"]()) {
      display.call(drag);
    } else {
      display.call(zoom).on("wheel", function () {
        return _d3__WEBPACK_IMPORTED_MODULE_3__["event"].preventDefault();
      }); // prevent scrolling even when at scale extent
    }

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#show-location").on("click", function () {
      if (navigator.geolocation) {
        report.status("Finding current position...");
        navigator.geolocation.getCurrentPosition(function (pos) {
          report.status("");

          _locate(pos.coords.longitude, pos.coords.latitude);
        }, report.error);
      }
    });

    function reorient() {
      var options = arguments[2] || {};

      if (!_globe || options.source === "moveEnd") {
        // reorientation occurred because the user just finished a move operation, so globe is already
        // oriented correctly.
        return;
      }

      dispatch.trigger("moveStart");

      _globe.orientation(configuration.get("orientation"), view);

      zoom.transform(display, _d3__WEBPACK_IMPORTED_MODULE_3__["zoomIdentity"].scale(_globe.projection.scale()));
      dispatch.trigger("moveEnd");
    }

    function hotkey(operation, value) {
      if (operation === "zoom") {
        return zoom.scaleBy(display, value);
      }

      if (!moveEnding) {
        dispatch.trigger("moveStart");
      }

      var proj = _globe.projection,
          rotate = proj.rotate(),
          delta = value / 8;

      switch (operation) {
        case "left":
          proj.rotate([rotate[0] + delta, rotate[1]]);
          break;

        case "right":
          proj.rotate([rotate[0] - delta, rotate[1]]);
          break;

        case "up":
          proj.rotate([rotate[0], rotate[1] - delta]);
          break;

        case "down":
          proj.rotate([rotate[0], rotate[1] + delta]);
          break;
      }

      dispatch.trigger("move");
      scheduleMoveEnd();
    }

    var dispatch = underscore__WEBPACK_IMPORTED_MODULE_2__["extend"]({
      globe: function globe(_) {
        if (_) {
          _globe = _;
          zoom.scaleExtent(_globe.scaleExtent());
          reorient();
        }

        return _ ? this : _globe;
      },
      cancelMove: function cancelMove() {
        // Forcefully end the current move operation, if any.
        end();
      },
      hotkey: hotkey
    }, backbone__WEBPACK_IMPORTED_MODULE_5__["Events"]);

    return dispatch.listenTo(configuration, "change:orientation", reorient);
  }

  function orient(coord) {
    var globe = globeAgent.value();

    if (globe) {
      var rotate = globe.locate(coord);

      if (rotate) {
        globe.projection.rotate(rotate);
        configuration.save({
          orientation: globe.orientation()
        }); // triggers reorientation
      }
    }
  }

  function _locate(lon, lat) {
    var λ = +lon,
        φ = +lat,
        coord = [λ, φ];

    if (λ !== λ || φ !== φ) {
      removeLocation();
      return;
    }

    saveLocation(null, coord);
    orient(coord);
  }
  /**
   * @param resource the GeoJSON resource's URL
   * @returns {Object} a promise for GeoJSON topology features: {boundaryLo:, boundaryHi:}
   */


  function buildMesh(resource) {
    var cancel = this.cancel;
    report.status("Downloading...");
    var files = [];
    files.push(_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](resource));

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() === "tara") {
      files.push(_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](products.gaia("/data/tara/tara-plan-20170829.json")));
      files.push(_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](products.gaia("/data/tara/tara-track.json")));
    }

    return Promise.all(files).then(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 3),
          topo = _ref2[0],
          taraPlan = _ref2[1],
          taraTrack = _ref2[2];

      if (cancel.requested) return null;
      log.time("building meshes");
      var o = topo.objects;
      var coastLo = topojson_client__WEBPACK_IMPORTED_MODULE_4__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.coastline_tiny : o.coastline_110m);
      var coastHi = topojson_client__WEBPACK_IMPORTED_MODULE_4__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.coastline_110m : o.coastline_50m);
      var lakesLo = topojson_client__WEBPACK_IMPORTED_MODULE_4__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.lakes_tiny : o.lakes_110m);
      var lakesHi = topojson_client__WEBPACK_IMPORTED_MODULE_4__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.lakes_110m : o.lakes_50m);
      var riversLo = topojson_client__WEBPACK_IMPORTED_MODULE_4__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.rivers_tiny : o.rivers_110m);
      var riversHi = topojson_client__WEBPACK_IMPORTED_MODULE_4__["feature"](topo, _micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]() ? o.rivers_110m : o.rivers_50m);
      log.timeEnd("building meshes");
      return {
        coastLo: coastLo,
        coastHi: coastHi,
        lakesLo: lakesLo,
        lakesHi: lakesHi,
        riversLo: riversLo,
        riversHi: riversHi,
        tara: {
          plan: taraPlan,
          track: taraTrack
        }
      };
    });
  }
  /**
   * @param {String} projectionName the desired projection's name.
   * @returns {Object} a globe object.
   */


  function buildGlobe(projectionName) {
    var builder = _globes__WEBPACK_IMPORTED_MODULE_8__[projectionName];

    if (!builder) {
      return Promise.reject("Unknown projection: " + projectionName);
    }

    return builder(view);
  } // Some hacky stuff to ensure only one download can be in progress at a time.


  var downloadsInProgress = 0;

  function buildGrids(isNewPrimaryGrid) {
    report.status("Downloading...");
    log.time("build grids");
    var cancel = this.cancel;
    downloadsInProgress++;
    return Promise.all(products.productsFor(configuration.attributes)).then(function (products) {
      var loads = products.map(function (product) {
        return product.load(cancel);
      });
      return Promise.all(loads).then(function (products) {
        return {
          primaryGrid: products[0],
          overlayGrid: products[1] || products[0],
          isNewPrimaryGrid: !!isNewPrimaryGrid
        };
      }).catch(function (err) {
        report.error(err);
        return {
          primaryGrid: products[1] || products[0],
          overlayGrid: products[1] || products[0],
          isNewPrimaryGrid: !!isNewPrimaryGrid
        };
      });
    }).then( // should be finally, but not standard
    function (value) {
      downloadsInProgress--;
      log.timeEnd("build grids");
      return value;
    }, function (reason) {
      downloadsInProgress--;
      log.timeEnd("build grids");
      return Promise.reject(reason);
    });
  }
  /**
   * Modifies the configuration to navigate to the chronologically next or previous data layer.
   */


  function navigate(step) {
    if (downloadsInProgress > 0) {
      log.debug("Download in progress--ignoring nav request.");
      return;
    }

    var next = gridAgent.value().overlayGrid.navigate(step);

    if (next) {
      configuration.save(_micro__WEBPACK_IMPORTED_MODULE_6__["dateToConfig"](next));
    }
  }

  function constructTaraElements(svg, tara, orientation) {
    var g = svg.append("g");
    var plan = {
      type: "LineString",
      coordinates: tara.plan.coordinates.filter(function (e, i) {
        return i > 253;
      })
    }; //g.append("path").attr("class", "tara-route tara-plan-border").datum(plan);

    g.append("path").attr("class", "tara-route tara-plan").datum(plan);
    var points = tara.track.geometries;
    points = points.filter(function (e, i) {
      return i > points.length - 10 || i % 3 === 0;
    });
    var wholeTrack = {
      type: "LineString",
      coordinates: underscore__WEBPACK_IMPORTED_MODULE_2__["pluck"](points, "coordinates")
    };
    var firstHalf = {
      type: "LineString",
      coordinates: wholeTrack.coordinates.slice(0, 3400)
    };
    var secondHalf = {
      type: "LineString",
      coordinates: wholeTrack.coordinates.slice(3400)
    };
    g.append("path").attr("class", "tara-route tara-track-border").datum(wholeTrack);
    g.append("path").attr("class", "tara-route tara-track-old").datum(firstHalf);
    g.append("path").attr("class", "tara-route tara-track").datum(secondHalf);
    var taraLoc = {
      type: "Point",
      coordinates: underscore__WEBPACK_IMPORTED_MODULE_2__["last"](wholeTrack.coordinates),
      size: 4
    };

    if (orientation === "" || orientation.substr(0, 2) === ",,") {
      orient(taraLoc.coordinates);
    }

    g.append("path").attr("class", "tara-loc").datum(taraLoc);

    var last = underscore__WEBPACK_IMPORTED_MODULE_2__["last"](points);

    var data = {
      date: last["date"],
      heading: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["heading"], NaN),
      speed: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["speed"], NaN) * 3.6,
      air_temp: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["air_temp"], NaN),
      water_temp: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["water_temp"], NaN),
      pressure: +_micro__WEBPACK_IMPORTED_MODULE_6__["coalesce"](last["pressure"], NaN)
    };
    var fields = {
      date: _utc__WEBPACK_IMPORTED_MODULE_7__["print"](_utc__WEBPACK_IMPORTED_MODULE_7__["localParts"](data.date), "{yyyy}-{MM}-{dd} {hh}:{mm}"),
      heading: isNaN(data.heading) ? "N/A" : data.heading.toFixed(0),
      speed: isNaN(data.speed) ? "N/A" : data.speed.toFixed(1),
      air_temp: isNaN(data.air_temp) ? "N/A" : data.air_temp.toFixed(1),
      water_temp: isNaN(data.water_temp) ? "N/A" : data.water_temp.toFixed(1),
      pressure: isNaN(data.pressure) ? "N/A" : data.pressure.toFixed(0)
    };
    var div = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#tara-stats");
    div.selectAll("*").remove();
    div.append("p").text("Tara stats:");
    div.append("p").classed("stat", true).text(fields.heading + "° @ " + fields.speed + " km/h");
    div.append("p").classed("stat", true).text(fields.air_temp + " °C (air)");
    div.append("p").classed("stat", true).text(fields.water_temp + " °C (water)");
    div.append("p").classed("stat", true).text(fields.pressure + " hPa");
    div.append("p").text(fields.date);
    div.selectAll(".stat").attr("style", "padding-left: 1em");
    div.classed("invisible", false);
  }

  function buildRenderer(mesh, globe) {
    if (!mesh || !globe) return null;
    report.status("Rendering Flat Earth Map...");
    log.time("rendering map"); // UNDONE: better way to do the following?

    var dispatch = underscore__WEBPACK_IMPORTED_MODULE_2__["clone"](backbone__WEBPACK_IMPORTED_MODULE_5__["Events"]);

    if (rendererAgent._previous) {
      rendererAgent._previous.stopListening();
    }

    rendererAgent._previous = dispatch;
    var mapCtx = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#map").node().getContext("2d");
    var foregroundCtx = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#foreground").node().getContext("2d");
    var annotationSvg = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#annotation");
    var orientation = configuration.get("orientation"); // First clear annotation svg contents.

    _micro__WEBPACK_IMPORTED_MODULE_6__["removeChildren"](annotationSvg.node());
    globe.orientation(orientation, view); // This allows the path function to work.

    var path = _d3__WEBPACK_IMPORTED_MODULE_3__["geoPath"]().projection(globe.projection).pointRadius(function (d) {
      return d.size || 7;
    });

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() === "tara") {
      constructTaraElements(annotationSvg, mesh.tara, orientation);
    } // Draw the location mark if one is currently visible.


    updateLocation(); // Throttled draw method helps with slow devices that would get overwhelmed by too many redraw events.

    var REDRAW_WAIT = 5; // milliseconds

    var doDraw_throttled = underscore__WEBPACK_IMPORTED_MODULE_2__["throttle"](doDraw, REDRAW_WAIT, {
      leading: false
    });

    var LINE_WIDTH = 1.25;
    var background = globe.backgroundRenderer();
    var graticule = globe.graticuleRenderer();
    var coastLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.coastLo, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var lakesLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.lakesLo, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var riversLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.riversLo, {
      strokeStyle: "#808080",
      lineWidth: LINE_WIDTH
    });
    var coastHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.coastHi, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var lakesHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.lakesHi, {
      strokeStyle: "#ffffff",
      lineWidth: LINE_WIDTH
    });
    var riversHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeStrokeRenderer"](mesh.riversHi, {
      strokeStyle: "#808080",
      lineWidth: LINE_WIDTH
    });
    var mapRendererLo = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeLayerRenderer"]([background, graticule, coastLo, lakesLo, riversLo]);
    var mapRendererHi = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeLayerRenderer"]([background, graticule, coastHi, lakesHi, riversHi]);
    var foregroundRenderer = _canvas_twod__WEBPACK_IMPORTED_MODULE_11__["makeLayerRenderer"]([globe.foregroundRenderer()]);

    function canvasDraw(isHD) {
      var mapRenderer = isHD ? mapRendererHi : mapRendererLo;
      mapRenderer.renderTo(mapCtx, path);
      foregroundRenderer.renderTo(foregroundCtx, path);
      path.context(null);
    }

    function doDraw() {
      annotationSvg.selectAll("path").attr("d", path);
      canvasDraw(false);
      rendererAgent.trigger("redraw");
      doDraw_throttled = underscore__WEBPACK_IMPORTED_MODULE_2__["throttle"](doDraw, REDRAW_WAIT, {
        leading: false
      });
    } // Attach to map rendering events on input controller.


    dispatch.listenTo(inputController, {
      moveStart: function moveStart() {
        rendererAgent.trigger("start");
      },
      move: function move() {
        doDraw_throttled();
      },
      moveEnd: function moveEnd() {
        annotationSvg.selectAll("path").attr("d", path);
        canvasDraw(true);
        rendererAgent.trigger("render");
      }
    }); // Finally, inject the globe model into the input controller. Do it on the next event turn to ensure
    // renderer is fully set up before events start flowing.

    Promise.resolve().then(function () {
      inputController.globe(globe);
    }).catch(report.error);
    log.timeEnd("rendering map");
    return "ready";
  }

  function addArgo() {
    var globe = globeAgent.value();
    if (!globe) return null;
    var svg = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#annotation");
    var type = configuration.get("argoFloat");

    if (svg.selectAll(".argo-" + type).size() > 0) {
      return null;
    }

    var cancel = this.cancel;
    var files = [_micro__WEBPACK_IMPORTED_MODULE_6__["loadJson"](products.argoUrl("argo.floats.json"))];
    return Promise.all(files).then(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
          argo = _ref4[0];

      if (cancel.requested) return null;
      log.time("building argo");
      var svg = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#annotation");
      svg.selectAll(".argo").remove();
      var validTypes = ["recent", "operational", "planned", "dead"];

      if (underscore__WEBPACK_IMPORTED_MODULE_2__["indexOf"](validTypes, type) >= 0) {
        var path = _d3__WEBPACK_IMPORTED_MODULE_3__["geoPath"]().projection(globe.projection).pointRadius(3);
        svg.append("path").classed("argo argo-" + type, true).datum({
          type: "MultiPoint",
          coordinates: argo[type],
          size: 3
        }).attr("d", path);
      }

      log.timeEnd("building argo");
    });
  }

  function copyTypedArray(target, source) {
    // Some browsers do not support TypedArray.prototype.set, like Android.
    if (underscore__WEBPACK_IMPORTED_MODULE_2__["isFunction"](target.set)) {
      target.set(source);
    } else {
      for (var i = 0; i < source.length; i++) {
        target[i] = source[i];
      }
    }
  }

  function createMask(globe) {
    if (!globe) return null;
    log.time("render mask"); // Create a detached canvas, ask the model to define the mask polygon, then fill with an opaque color.

    var width = view.width,
        height = view.height;
    var canvas = _d3__WEBPACK_IMPORTED_MODULE_3__["select"](document.createElement("canvas")).attr("width", width).attr("height", height).node();
    var context = globe.defineMask(canvas.getContext("2d"));
    context.fillStyle = "rgba(255, 0, 0, 1)";
    context.fill(); // d3.select("#display").node().appendChild(canvas);  // make mask visible for debugging
    // Grab a _copy_ of the ImageData. Works around a Chrome bug where holding onto the result of getImageData
    // sometimes results in a blank screen, presumably because the associated detached canvas is garbage collected.

    var imageData = context.createImageData(width, height),
        data = imageData.data; // layout: [r, g, b, a, ...]

    copyTypedArray(data, context.getImageData(0, 0, width, height).data); //const imageData = context.getImageData(0, 0, width, height), data = imageData.data;  // layout: [r, g, b, a, ...]

    log.timeEnd("render mask");
    return {
      imageData: imageData,
      isVisible: function isVisible(x, y) {
        var i = (y * width + x) * 4;
        return data[i + 3] > 0; // non-zero alpha means pixel is visible
      },
      set: function set(x, y, rgba) {
        var i = (y * width + x) * 4;
        data[i] = rgba[0];
        data[i + 1] = rgba[1];
        data[i + 2] = rgba[2];
        data[i + 3] = rgba[3];
        return this;
      }
    };
  }

  function createField(rows, mask, bounds) {
    var xMin = bounds.x;
    var field = {};
    /**
     * Copies the array [x, y, dx, dy, m] into Array 'a' starting at index i. If x or y is out of bounds,
     * then sets the dx, dy, and m values to 7e37.
     *
     * @param x {Number}
     * @param y {Number}
     * @param a {Float32Array}
     * @param i {Number}
     */

    field.move = function (x, y, a, i) {
      var k = Math.round(y);

      if (0 <= k && k < rows.length) {
        var row = rows[k];
        var j = (Math.round(x) - xMin) * 3;

        if (row && 0 <= j && j < row.length) {
          a[i] = x;
          a[i + 1] = y;
          a[i + 2] = row[j]; // dx

          a[i + 3] = row[j + 1]; // dy

          a[i + 4] = row[j + 2]; // m

          return;
        }
      }

      a[i] = x;
      a[i + 1] = y;
      a[i + 2] = 7e37;
      a[i + 3] = 7e37;
      a[i + 4] = 7e37;
    };
    /**
     * @returns {boolean} true if the field is valid at the point (x, y)
     */


    field.isDefined = function (x, y) {
      var k = Math.round(y);

      if (0 <= k && k < rows.length) {
        var row = rows[k];
        var j = (Math.round(x) - xMin) * 3;

        if (row && 0 <= j && j < row.length) {
          return row[j] < 7e37;
        }
      }

      return false;
    };
    /**
     * @returns {boolean} true if the point (x, y) lies inside the outer boundary of the vector field, even if
     *          the vector field has a hole (is undefined) at that point, such as at an island in a field of
     *          ocean currents.
     */


    field.isInsideBoundary = function (x, y) {
      var a = new Float32Array(5); // [x, y, dx, dy, m]

      field.move(x, y, a, 0);
      return a[4] < 7e37; // true if magnitude is defined or is HOLE_VECTOR
    };

    field.overlay = mask.imageData;
    return field;
  }
  /**
   * Calculate distortion of the wind vector caused by the shape of the projection at point (x, y). The wind
   * vector is modified in place and returned by this function.
   */


  function distort(projection, λ, φ, x, y, velocityScale, wind) {
    var u = wind[0] * velocityScale;
    var v = wind[1] * velocityScale;
    var d = _micro__WEBPACK_IMPORTED_MODULE_6__["distortion"](projection, λ, φ, x, y); // Scale distortion vectors by u and v, then add.

    wind[0] = d[0] * u + d[2] * v;
    wind[1] = d[1] * u + d[3] * v;
    return wind;
  }

  function interpolateField(globe, grids) {
    if (!globe || !grids || !rendererAgent.value()) return null;
    var fastoverlay = fastoverlayAgent.value();
    var useFastOverlay = fastoverlay && fastoverlay.draw("interp");
    var mask = createMask(globe);
    var primaryGrid = grids.primaryGrid;
    var overlayGrid = grids.overlayGrid;
    var hasDistinctOverlay = primaryGrid !== overlayGrid; // nothing to do if products failed to load and have no data

    if (!primaryGrid.field || !overlayGrid.field) return null; // TIME-LAPSE
    // if (!primaryGrid.particles) {
    //     report.status("");
    //     return;
    // }

    var interpolationType = "bilinear";
    var primaryField = primaryGrid.field();
    var overlayField = overlayGrid.field();
    var interpolate = primaryField[interpolationType];
    var overlayInterpolate = overlayField[interpolationType];
    log.time("interpolating field");
    var cancel = this.cancel;
    var projection = globe.optimizedProjection();
    var invert = projection.invert.bind(projection);
    var bounds = globe.bounds(view); // How fast particles move on the screen (arbitrary value chosen for aesthetics).

    var velocityScale = primaryGrid.particles.velocityScale;
    var rows = [];
    var point = [];
    var y = bounds.y;
    var colorScale = overlayGrid.scale;
    var hd = configuration.get("hd"),
        step = hd ? 1 : 2;

    function interpolateRow(y) {
      var lastRow = y === bounds.yMax;
      var row = new Float32Array(bounds.width * 3); // [u0, v0, m0, u1, v1, m1, ...]

      for (var x = bounds.x, i = 0; x <= bounds.xMax; x += step, i += step * 3) {
        var lastColumn = x === bounds.xMax;
        var wind = NULL_WIND_VECTOR;

        if (mask.isVisible(x, y)) {
          point[0] = x, point[1] = y;
          var coord = invert(point);
          var color = TRANSPARENT_BLACK;

          if (coord) {
            var λ = coord[0],
                φ = coord[1];

            if (λ === λ) {
              wind = interpolate(coord);
              var scalar = wind[2];

              if (scalar < 7e37) {
                wind = distort(projection, λ, φ, x, y, velocityScale, wind);
                scalar = wind[2];
              } else {
                wind = HOLE_VECTOR;
              }

              if (!useFastOverlay) {
                if (hasDistinctOverlay || primaryField.type === "scalar") {
                  scalar = _micro__WEBPACK_IMPORTED_MODULE_6__["scalarize"](overlayInterpolate(coord));
                }

                if (scalar < 7e37) {
                  color = colorScale.rgba(scalar);
                  color[3] = overlayGrid.alpha.animated;
                }
              }
            }
          }

          mask.set(x, y, color);

          if (!hd) {
            if (!lastColumn) {
              mask.set(x + 1, y, color);

              if (!lastRow) {
                mask.set(x + 1, y + 1, color);
              }
            }

            if (!lastRow) {
              mask.set(x, y + 1, color);
            }
          }
        }

        row[i] = wind[0];
        row[i + 1] = wind[1];
        row[i + 2] = wind[2];

        if (!hd && !lastColumn) {
          row[i + 3] = wind[0];
          row[i + 4] = wind[1];
          row[i + 5] = wind[2];
        }
      }

      rows[y] = row;

      if (!hd) {
        rows[y + 1] = row;
      }
    }

    report.status("");
    report.progress(0); // signal that we are starting interpolation

    return new Promise(function (resolve, reject) {
      (function batchInterpolate() {
        try {
          if (!cancel.requested) {
            var _start = Date.now();

            while (y <= bounds.yMax) {
              interpolateRow(y);
              y += step;

              if (Date.now() - _start > MAX_TASK_TIME) {
                // Interpolation is taking too long. Schedule the next batch for later and yield.
                report.progress(Math.round((y - bounds.y) / (bounds.yMax - bounds.y) * 100));
                setTimeout(batchInterpolate, MIN_SLEEP_TIME);
                return;
              }
            }
          }

          resolve(createField(rows, mask, bounds));
        } catch (e) {
          reject(e);
        }

        report.progress(100); // 100% complete

        log.timeEnd("interpolating field");
      })();
    });
  }

  function animate(globe, grids) {
    if (!globe || !fieldAgent.value() || !grids || !configuration.get("animate")) return false;

    if (grids.isNewPrimaryGrid) {
      _micro__WEBPACK_IMPORTED_MODULE_6__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#animation").node()); // clear animation artifacts
    }

    var cancel = this.cancel;
    var bounds = globe.bounds(view); // maxIntensity is the velocity at which particle color intensity is maximum

    var colorStyles = _micro__WEBPACK_IMPORTED_MODULE_6__["windIntensityColorScale"](INTENSITY_SCALE_STEP, grids.primaryGrid.particles.maxIntensity);
    var particleCount = Math.round(bounds.width * PARTICLE_MULTIPLIER);

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isMobile"]()) {
      particleCount = Math.floor(particleCount * PARTICLE_REDUCTION);
    }

    log.debug("particle count: %s", particleCount);
    var particles = new Float32Array(particleCount * 5);
    var ages = new Int32Array(particleCount);
    var batches = colorStyles.map(function () {
      return new Float32Array(particleCount * 4);
    });
    var sizes = new Int32Array(batches.length);
    var xMin = bounds.x,
        yMin = bounds.y,
        width = bounds.width,
        height = bounds.height;
    var scale = globe.projection.scale();

    function randomize(i, field) {
      var x = xMin + Math.random() * width;
      var y = yMin + Math.random() * height;
      field.move(x, y, particles, i);
    }

    function randomizeWell(i, field) {
      // This function is hrm, but avoids "pulsing"
      for (var attempts = 0; attempts < 10; attempts++) {
        randomize(i, field);
        if (particles[i + 2] < 7e37) return;
      }
    }

    var maxAge, evolve;
    var g = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#animation").node().getContext("2d");

    if (grids.primaryGrid.particles.waves) {
      maxAge = 40;
      evolve = evolveWaves;
      g.fillStyle = "rgba(0, 0, 0, 0.90)";
    } else {
      maxAge = 100;
      evolve = evolveParticles;
      g.fillStyle = _micro__WEBPACK_IMPORTED_MODULE_6__["isFF"]() ? "rgba(0, 0, 0, 0.95)" : "rgba(0, 0, 0, 0.97)"; // FF Mac alpha behaves oddly
    }

    g.lineWidth = PARTICLE_LINE_WIDTH;

    for (var i = 0, j = 0; i < particleCount; i += 1, j += 5) {
      ages[i] = underscore__WEBPACK_IMPORTED_MODULE_2__["random"](0, maxAge);
      randomizeWell(j, fieldAgent.value());
    }

    var easeFactor = new Float32Array(maxAge);

    for (var k = 0; k < easeFactor.length; k++) {
      easeFactor[k] = Math.sin(-_consts__WEBPACK_IMPORTED_MODULE_0__["π"] / 2 + k / 7) / 2 + 1 / 2; // fade in/out line intensity
    }

    function evolveWaves() {
      var field = fieldAgent.value();
      var adj = 600 / scale * Math.pow(Math.log(scale) / Math.log(600), 2.5); // use shallower exponential speed scale

      for (var s = 0; s < sizes.length; s++) {
        sizes[s] = 0;
      }

      for (var _i2 = 0, _j = 0; _i2 < particleCount; _i2 += 1, _j += 5) {
        if (++ages[_i2] >= maxAge) {
          ages[_i2] = 0;
          randomize(_j, field);
        }

        var x0 = particles[_j];
        var y0 = particles[_j + 1];
        var dx = particles[_j + 2];
        var dy = particles[_j + 3];
        var x1 = x0 + dx * adj;
        var y1 = y0 + dy * adj;
        var m = particles[_j + 4];

        if (m !== m || !field.isDefined(x1, y1)) {
          ages[_i2] = maxAge; // particle has escaped the game grid
        } else {
          particles[_j] = x1;
          particles[_j + 1] = y1; // width of wave

          var mag = Math.sqrt(dx * dx + dy * dy) / 2.5; // CONSIDER: would be nice to retain unscaled m...

          dx /= mag;
          dy /= mag; // Path from (x,y) to (xt,yt) is visible, so add this particle to the appropriate draw bucket.

          var si = colorStyles.indexFor(m * easeFactor[ages[_i2]]);
          var sj = 4 * sizes[si]++;
          var batch = batches[si];
          batch[sj] = x0 - dy;
          batch[sj + 1] = y0 + dx;
          batch[sj + 2] = x0 + dy;
          batch[sj + 3] = y0 - dx;
        }
      }
    }

    function evolveParticles() {
      var field = fieldAgent.value();

      for (var s = 0; s < sizes.length; s++) {
        sizes[s] = 0;
      }

      for (var _i3 = 0, _j2 = 0; _i3 < particleCount; _i3 += 1, _j2 += 5) {
        if (++ages[_i3] >= maxAge) {
          ages[_i3] = 0;
          randomize(_j2, field);
        }

        var x0 = particles[_j2]; // x

        var y0 = particles[_j2 + 1]; // y

        var x1 = x0 + particles[_j2 + 2]; // dx

        var y1 = y0 + particles[_j2 + 3]; // dy

        var m = particles[_j2 + 4]; // m

        if (x1 < 7e37) {
          field.move(x1, y1, particles, _j2);
          var dx = particles[_j2 + 2];

          if (dx < 7e37) {
            // Path from (x0,y0) to (x1,y1) is visible, so add this particle to the appropriate draw bucket.
            var si = colorStyles.indexFor(m);
            var sj = 4 * sizes[si]++;
            var batch = batches[si];
            batch[sj] = x0;
            batch[sj + 1] = y0;
            batch[sj + 2] = x1;
            batch[sj + 3] = y1;
          } else {
            ages[_i3] = maxAge; // particle has escaped the game grid
          }
        } else {
          ages[_i3] = maxAge; // particle has escaped the game grid
        }
      }
    }

    function draw() {
      // Fade existing trails.
      g.globalCompositeOperation = "destination-in";
      g.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
      g.globalCompositeOperation = "source-over"; // Draw new trails.

      for (var _i4 = 0; _i4 < batches.length; _i4++) {
        var batch = batches[_i4];
        var size = 4 * sizes[_i4];

        if (size > 0) {
          g.beginPath();
          g.strokeStyle = colorStyles[_i4];

          for (var _j3 = 0; _j3 < size; _j3 += 4) {
            g.moveTo(batch[_j3], batch[_j3 + 1]);
            g.lineTo(batch[_j3 + 2], batch[_j3 + 3]);
          }

          g.stroke();
        }
      }
    }

    function frame() {
      if (cancel.requested) {
        return false;
      }

      evolve();
      draw();
      setTimeout(frame, FRAME_RATE);
      return true;
    }

    frame();
    return {
      frame: frame
    };
  }

  function drawGridPoints(ctx, layer, globe) {
    if (!layer || !globe || !configuration.get("showGridPoints")) return;
    ctx.fillStyle = "rgba(255, 255, 255, 0.75)";
    var width = view.width,
        height = view.height;
    var stream = globe.projection.stream({
      point: function point(x, y) {
        if (0 <= x && x < width && 0 <= y && y < height) {
          // fillRect is processed at the end of the event turn, but it alpha blends, as opposed to setting
          // the pixel directly.
          ctx.fillRect(Math.round(x), Math.round(y), 1, 1);
        }
      }
    });
    var cancel = this.cancel;
    var grid = layer.grid(),
        field = layer.field(),
        valueAt = field.valueAt;
    var i = 0; // Draw grid points in batches.

    (function work() {
      if (!cancel.requested) {
        var end = Date.now() + MAX_TASK_TIME / 4;
        i = grid.forEach(function (λ, φ, i) {
          var v = _micro__WEBPACK_IMPORTED_MODULE_6__["scalarize"](valueAt(i));

          if (v < 7e37) {
            λ = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(180 + λ, 360) - 180; // some projections don't clamp to [-180, 180)

            stream.point(λ, φ);
          }

          return Date.now() > end;
        }, i);

        if (i === i) {
          setTimeout(work, MIN_SLEEP_TIME);
        }
      }
    })();
  }

  function brighten(data, alpha) {
    for (var i = 3; i < data.length; i += 4) {
      if (data[i] !== 0) {
        data[i] = alpha;
      }
    }
  }

  function drawOverlay(field, overlayType, animate) {
    if (!field || !rendererAgent.value()) return;
    var ctx = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#overlay").node().getContext("2d"),
        grid = (gridAgent.value() || {}).overlayGrid;
    _micro__WEBPACK_IMPORTED_MODULE_6__["clearContext"](ctx);
    _micro__WEBPACK_IMPORTED_MODULE_6__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#scale").node());

    if (overlayType) {
      if (overlayType !== "off") {
        if (!animate) {
          // No animation, so brighten the overlay.
          brighten(field.overlay.data, grid.alpha.single);
        }

        ctx.putImageData(field.overlay, 0, 0);
      }

      overlayGridAgent.submit(drawGridPoints, ctx, grid, globeAgent.value());
    }

    if (grid) {
      var colorBar = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#scale"),
          c = colorBar.node(),
          g = c.getContext("2d"),
          barMax = c.width - 1;
      var colorScale = grid.scale,
          colors = colorScale.colors,
          colorMax = colors.length / 4 - 1;

      for (var i = 0; i < c.width; i++) {
        var j = Math.round(i / barMax * colorMax) * 4;
        g.fillStyle = "rgb(".concat(colors[j], ",").concat(colors[j + 1], ",").concat(colors[j + 2], ")");
        g.fillRect(i, 0, 1, c.height);
      } // Show tooltip on hover.


      colorBar.on("mousemove", function () {
        var x = Math.floor(_d3__WEBPACK_IMPORTED_MODULE_3__["mouse"](this)[0]);

        if (x < 0 || barMax < x) {
          return colorBar.attr("title", null);
        }

        var i = Math.round(x / barMax * colorMax);
        var value = colorScale.valueFor(i);
        var elementId = grid.type === "wind" ? "#location-wind-units" : "#location-value-units";
        var units = createUnitToggle(elementId, grid).value();
        colorBar.attr("title", _micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](value, units) + " " + (units.tooltip || units.label));
      });
    }
  }
  /**
   * Get the grid date.
   */


  function validityDate(grids) {
    if (grids) {
      return grids.overlayGrid.date(); // Use grid date if we have it.
    } // Otherwise use date as described by the configuration.


    var date = configuration.get("date");
    return date === "current" ? null : underscore__WEBPACK_IMPORTED_MODULE_2__["clone"](date);
  }
  /**
   * Display the grid's validity date in the menu. Allow toggling between local and UTC time.
   */


  function showDate(grids) {
    var date = validityDate(grids),
        isLocal = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#data-date").classed("local");
    var formatted = "";

    if (date) {
      formatted = _utc__WEBPACK_IMPORTED_MODULE_7__["print"]((isLocal ? _utc__WEBPACK_IMPORTED_MODULE_7__["localParts"] : _utc__WEBPACK_IMPORTED_MODULE_7__["parts"])(_utc__WEBPACK_IMPORTED_MODULE_7__["date"](date)), "{yyyy}-{MM}-{dd} {hh}:{mm}");
    }

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#data-date").text(formatted + " " + (isLocal ? "Local" : "UTC"));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#toggle-zone").text("⇄ " + (isLocal ? "UTC" : "Local")); // TIME-LAPSE
    // const div = d3.select("#tara-stats");
    // div.classed("invisible", false).selectAll("*").remove();
    // div.append("p").text(utc.print(date, "{yyyy}-{MM}-{dd} {hh}:{mm}Z"));

    return date;
  }
  /**
   * Display the grids' types in the menu.
   */


  function showGridDetails(grids) {
    var date = showDate(grids);
    var descriptionHTML = "",
        sourceHTML = "";

    if (grids) {
      var langCode = _micro__WEBPACK_IMPORTED_MODULE_6__["siteLangCode"]();
      var pd = grids.primaryGrid.descriptionHTML(langCode),
          od = grids.overlayGrid.descriptionHTML(langCode);
      descriptionHTML = od.name + od.qualifier;

      if (grids.primaryGrid !== grids.overlayGrid) {
        // Combine both grid descriptions together with a " + " if their qualifiers are the same.
        descriptionHTML = (pd.qualifier === od.qualifier ? pd.name : pd.name + pd.qualifier) + " + " + descriptionHTML;
      }

      sourceHTML = grids.overlayGrid.sourceHTML || "";
    }

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#data-layer").html(descriptionHTML);
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#data-center").html(sourceHTML);

    if (bridge.productChange) {
      bridge.productChange(_utc__WEBPACK_IMPORTED_MODULE_7__["date"](date).getTime(), descriptionHTML, sourceHTML);
    }
  }
  /**
   * Constructs a toggler for the specified product's units, storing the toggle state on the element having
   * the specified id. For example, given a product having units ["m/s", "mph"], the object returned by this
   * method sets the element's "data-index" attribute to 0 for m/s and 1 for mph. Calling value() returns the
   * currently active units object. Calling next() increments the index.
   */


  function createUnitToggle(id, product) {
    var units = product.units,
        type = product.type,
        size = units.length;

    function currentState() {
      return JSON.parse(_d3__WEBPACK_IMPORTED_MODULE_3__["select"](id).attr("data-index") || "{}");
    }

    function currentIndex(state) {
      return +state[type] || 0;
    }

    return {
      value: function value() {
        return units[currentIndex(currentState())];
      },
      next: function next() {
        var state = currentState();
        state[type] = (currentIndex(state) + 1) % size;
        _d3__WEBPACK_IMPORTED_MODULE_3__["select"](id).attr("data-index", JSON.stringify(state));
      }
    };
  }
  /**
   * Display the specified wind value. Allow toggling between the different types of wind units.
   */


  function showWindAtLocation(wind, product) {
    var unitToggle = createUnitToggle("#location-wind-units", product),
        units = unitToggle.value();
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-wind").text(_micro__WEBPACK_IMPORTED_MODULE_6__["formatVector"](wind, units));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-wind-units").html(units.label).on("click", function () {
      unitToggle.next();
      showWindAtLocation(wind, product);
    });
  }
  /**
   * Display the specified overlay value. Allow toggling between the different types of supported units.
   */


  function showOverlayValueAtLocation(value, product) {
    var unitToggle = createUnitToggle("#location-value-units", product),
        units = unitToggle.value();
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-value").text(_micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](value, units));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-value-units").html(units.label).on("click", function () {
      unitToggle.next();
      showOverlayValueAtLocation(value, product);
    });
  }
  /**
   * Display a local data callout at the coordinates specified by the hash fragment "loc=lon,lat". The location may
   * not be valid, in which case no callout is displayed. Display location data for both the primary grid and overlay
   * grid, performing interpolation when necessary.
   */


  function updateLocation() {
    _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".location").text("");
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-close").classed("invisible", true);
    var coord = configuration.get("loc") || [],
        λ = +coord[0],
        φ = +coord[1];

    if (λ !== λ || φ !== φ) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"](".location-mark").remove();

      if (bridge.showLocationDetails) {
        bridge.showLocationDetails("", "{}");
      }

      return;
    }

    var grids = gridAgent.value(),
        field = fieldAgent.value(),
        globe = globeAgent.value();
    if (!grids || !field || !globe) return;
    var primary = grids.primaryGrid,
        overlay = grids.overlayGrid,
        units = {};
    var coordString = _micro__WEBPACK_IMPORTED_MODULE_6__["formatCoordinates"](λ, φ); // Show coordinates.

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-coord").text(coordString);
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-close").classed("invisible", false);

    function showVector(vector, layer) {
      if (vector[0] < 7e37) {
        showWindAtLocation(vector, layer);
        units[layer.type] = underscore__WEBPACK_IMPORTED_MODULE_2__["object"](layer.units.map(function (unit) {
          return [unit.label, _micro__WEBPACK_IMPORTED_MODULE_6__["formatVector"](vector, unit)];
        }));
      }
    }

    function showScalar(scalar, layer) {
      if (scalar < 7e37) {
        showOverlayValueAtLocation(scalar, layer);
        units[layer.type] = underscore__WEBPACK_IMPORTED_MODULE_2__["object"](layer.units.map(function (unit) {
          return [unit.label, _micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](scalar, unit)];
        }));
      }
    } // Show primary grid value.


    var primaryValue = primary.interpolate([λ, φ]);

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isArrayLike"](primaryValue)) {
      showVector(primaryValue, primary);
    } else {
      showScalar(primaryValue, primary);
    } // Show overlay grid value.


    var overlayValue = overlay !== primary ? _micro__WEBPACK_IMPORTED_MODULE_6__["scalarize"](overlay.interpolate([λ, φ])) : 7e37;
    showScalar(overlayValue, overlay); // Draw location mark.

    var path = _d3__WEBPACK_IMPORTED_MODULE_3__["geoPath"]().projection(globe.projection).pointRadius(7);
    var mark = _d3__WEBPACK_IMPORTED_MODULE_3__["select"](".location-mark");

    if (!mark.node()) {
      mark = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#annotation").append("path").attr("class", "location-mark");
    }

    mark.datum({
      type: "Point",
      coordinates: [λ, φ]
    }).attr("d", path);

    if (bridge.showLocationDetails) {
      bridge.showLocationDetails(coordString, JSON.stringify(units));
    }
  }

  function saveLocation(point, coord) {
    var λ = +coord[0],
        φ = +coord[1],
        field = fieldAgent.value();

    if (point && field && !field.isInsideBoundary(point[0], point[1])) {
      return;
    }

    if (λ === λ && φ === φ) {
      configuration.save({
        loc: [λ, φ]
      });
    }
  }

  function removeLocation() {
    configuration.save({
      loc: null
    });
  }

  function stopCurrentAnimation(alsoClearCanvas) {
    if (animatorAgent.value()) {
      animatorAgent.submit(false);
    }

    if (alsoClearCanvas) {
      _micro__WEBPACK_IMPORTED_MODULE_6__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#animation").node());
    }
  }

  function highlightWhen(elementId, highlightAttrList) {
    // CONSIDER: the reasons requiring highlightAttrList need to be rethought...
    configuration.on("change", function (model) {
      var attr = model.attributes;
      var highlighted = false;
      highlightAttrList.forEach(function (expectedAttr) {
        highlighted |= underscore__WEBPACK_IMPORTED_MODULE_2__["isEqual"](underscore__WEBPACK_IMPORTED_MODULE_2__["pick"](attr, underscore__WEBPACK_IMPORTED_MODULE_2__["keys"](expectedAttr)), expectedAttr);
      });
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"](elementId).classed("highlighted", highlighted);
    });
  }
  /**
   * Registers a click event handler for the specified DOM element which modifies the configuration to have
   * the attributes represented by newAttr. An event listener is also registered for configuration change events,
   * so when a change occurs the button becomes highlighted (i.e., class ".highlighted" is assigned or removed) if
   * the configuration matches the attributes for this button. The set of attributes used for the matching is taken
   * from newAttr, unless a custom set of key+values is provided.
   */


  function bindButtonToConfiguration(elementId, newAttr, highlightAttrList) {
    highlightAttrList = highlightAttrList || [newAttr];
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"](elementId).on("click", function () {
      if (_d3__WEBPACK_IMPORTED_MODULE_3__["select"](elementId).classed("disabled")) return;
      configuration.save(newAttr);
    });
    highlightWhen(elementId, highlightAttrList);
  }

  function reportSponsorClick(type) {
    if (underscore__WEBPACK_IMPORTED_MODULE_2__["isFunction"](window.ga)) {
      window.ga("send", "event", "sponsor", type);
    }
  }

  function fillScreen() {
    var ratio = window["devicePixelRatio"] || 1;
    _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".fill-screen").attr("width", view.width).attr("height", view.height);
    _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".max-screen").style("width", "".concat(view.width, "px")).style("height", "".concat(view.height, "px")).attr("width", view.width * ratio).attr("height", view.height * ratio).each(function () {
      this.getContext("2d").scale(ratio, ratio);
    });
  }

  function shouldPlayAnimation(nextMode) {
    var currentMode = configuration.get("param");

    if (currentMode !== "space" && nextMode === "space") {
      return false;
    } else if (currentMode === "space" && nextMode !== "space") {
      return true;
    } else {
      return configuration.get("animate"); // current setting
    }
  }
  /**
   * Registers all event handlers to bind components and page elements together. There must be a cleaner
   * way to accomplish this...
   */


  function init() {
    report.status("Initializing...");
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#sponsor-link").attr("target", _micro__WEBPACK_IMPORTED_MODULE_6__["isEmbeddedInIFrame"]() && _micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() !== "tara" ? "_new" : null).on("click", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](reportSponsorClick, "click")).on("contextmenu", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](reportSponsorClick, "right-click"));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#sponsor-hide").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#sponsor").classed("invisible", true);
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#notice-hide").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#notice").classed("invisible", true);
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#settings-show").select(".text-button").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#settings-wrap").classed("invisible", false);

      if (!_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#menu").classed("invisible")) {
        // hide menu if open
        earth.click("show-menu");
      }
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#settings-hide").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#settings-wrap").classed("invisible", true);
    });
    !function () {
      // highlight active lang
      var lang = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("html").attr("lang");
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#settings").selectAll("a[lang='" + lang + "']").classed("highlighted", true); // show preferred lang

      var best = _lang__WEBPACK_IMPORTED_MODULE_12__["best"](window.navigator);

      if (best !== lang) {
        _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#settings-show").select("a[lang='" + best + "']").classed("invisible", false);
      } // const parsed = language.parse(language.preferred(window.navigator)[0]);
      // if (parsed.language === "ko") {
      //     d3.select("#notice").classed("invisible", false);
      // }

    }();
    fillScreen(); // Adjust size of the scale canvas to fill the width of the menu to the right of the label.

    var label = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#scale-label").node();
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#scale").attr("width", Math.round((_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#menu").node().offsetWidth - label.offsetWidth) * 0.95)).attr("height", Math.round(label.offsetHeight / 2));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#show-menu").on("click", function () {
      if (_micro__WEBPACK_IMPORTED_MODULE_6__["isEmbeddedInIFrame"]() && !_micro__WEBPACK_IMPORTED_MODULE_6__["isKioskMode"]() && _micro__WEBPACK_IMPORTED_MODULE_6__["siteInstance"]() !== "tara") {
        window.open("https://earth.nullschool.net/" + window.location.hash, "_blank");
      } else {
        var opening = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#menu").classed("invisible");
        _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#menu").classed("invisible", !opening);

        if (opening && underscore__WEBPACK_IMPORTED_MODULE_2__["isFunction"](window.ga)) {
          window.ga("send", "event", "menu", "open");
        }
      }
    }); // Tweak document to distinguish CSS styling between touch and non-touch environments. Hacky hack.

    if ("ontouchstart" in document.documentElement) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"](document).on("touchstart", function () {}); // this hack enables :active pseudoclass
    } else {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"](document.documentElement).classed("no-touch", true); // to filter styles problematic for touch
    }

    function updateLangLinks() {
      // Change all lang links to retain the current hash fragment so stuff stays the same when clicked.
      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"]("a[lang]").attr("href", function () {
        var e = _d3__WEBPACK_IMPORTED_MODULE_3__["select"](this),
            link = e.attr("data-link");
        return link ? link + window.location.hash : e.attr("href");
      });
    }

    updateLangLinks(); // Bind configuration to URL bar changes.

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"](window).on("hashchange", function () {
      log.debug("hashchange");
      updateLangLinks();
      configuration.fetch({
        trigger: "hashchange"
      });
    });
    configuration.on("change", function () {
      report.reset();
      buttonStateNotifier.submit(function () {
        // use agent to delay notification until button modification is done
        var highlighted = [],
            disabled = [];
        _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".highlighted").each(function () {
          highlighted.push(this.id);
        });
        _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".disabled").each(function () {
          disabled.push(this.id);
        });

        if (bridge.buttonStateChange) {
          bridge.buttonStateChange(JSON.stringify(highlighted), JSON.stringify(disabled));
        }
      });
    });
    var first = true;
    configuration.on("change", function (model) {
      if (!underscore__WEBPACK_IMPORTED_MODULE_2__["isFunction"](window.ga) || first) return first = false;

      var changed = model.changedAttributes(),
          attr = underscore__WEBPACK_IMPORTED_MODULE_2__["clone"](model.attributes);

      if (underscore__WEBPACK_IMPORTED_MODULE_2__["has"](changed, "projection")) {
        window.ga("send", "event", "projection", attr.projection);
      }

      if (underscore__WEBPACK_IMPORTED_MODULE_2__["has"](changed, "overlayType")) {
        window.ga("send", "event", "overlay", attr.overlayType);
      }

      if (underscore__WEBPACK_IMPORTED_MODULE_2__["has"](changed, "param") || underscore__WEBPACK_IMPORTED_MODULE_2__["has"](changed, "surface") || underscore__WEBPACK_IMPORTED_MODULE_2__["has"](changed, "level")) {
        window.ga("send", "event", "layer", [attr.param, attr.surface, attr.level].join("-"));
      }
    });
    meshAgent.listenTo(configuration, "change:topology", function (context, attr) {
      meshAgent.submit(buildMesh, attr);
    });
    globeAgent.listenTo(configuration, "change:projection", function (source, attr) {
      globeAgent.submit(buildGlobe, attr);
    });
    gridAgent.listenTo(configuration, "change", function () {
      var changed = underscore__WEBPACK_IMPORTED_MODULE_2__["keys"](configuration.changedAttributes());

      var rebuildRequired = false,
          isNewPrimaryGrid = false; // Build a new primary grid if any related attributes have changed.

      if (underscore__WEBPACK_IMPORTED_MODULE_2__["intersection"](changed, ["date", "param", "surface", "level", "hd"]).length > 0) {
        rebuildRequired = true;
        isNewPrimaryGrid = true;
      } // Build a new overlay grid if the new overlay type is different from the current one.


      var overlayType = configuration.get("overlayType") || "default";

      if (underscore__WEBPACK_IMPORTED_MODULE_2__["indexOf"](changed, "overlayType") >= 0 && overlayType !== "off") {
        var grids = gridAgent.value() || {},
            primary = grids.primaryGrid,
            overlay = grids.overlayGrid;

        if (!overlay) {
          // Do a rebuild if we have no overlay grid.
          rebuildRequired = true;
        } else if (overlay.type !== overlayType && !(overlayType === "default" && primary === overlay)) {
          // Do a rebuild if the types are different.
          rebuildRequired = true;
        }
      }

      if (rebuildRequired) {
        gridAgent.submit(buildGrids, isNewPrimaryGrid);
      }
    }); //        gridAgent.on("submit", function() {
    //            showGridDetails(null);
    //        });

    gridAgent.on("update", function (grids) {
      showGridDetails(grids);
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#toggle-zone").on("click", function () {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#data-date").classed("local", !_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#data-date").classed("local"));
      showDate(gridAgent.cancel.requested ? null : gridAgent.value());
    });

    function startRendering() {
      rendererAgent.submit(buildRenderer, meshAgent.value(), globeAgent.value());
    }

    rendererAgent.listenTo(meshAgent, "update", startRendering);
    rendererAgent.listenTo(globeAgent, "update", startRendering);

    function startInterpolation() {
      fieldAgent.submit(interpolateField, globeAgent.value(), gridAgent.value());
    }

    function cancelInterpolation() {
      fieldAgent.cancel();
      overlayGridAgent.cancel();
    }

    fieldAgent.listenTo(gridAgent, "update", startInterpolation);
    fieldAgent.listenTo(rendererAgent, "render", startInterpolation);
    fieldAgent.listenTo(rendererAgent, "start", cancelInterpolation);
    fieldAgent.listenTo(rendererAgent, "redraw", cancelInterpolation);
    /*
            argoAgent.listenTo(globeAgent, "update", function() {
               argoAgent.submit(addArgo);
            });
            argoAgent.listenTo(rendererAgent, "render", function() {
               argoAgent.submit(addArgo);
            });
            argoAgent.listenTo(configuration, "change:argoFloat", function() {
               argoAgent.submit(addArgo);
            });
    */

    animatorAgent.listenTo(fieldAgent, "update", function () {
      animatorAgent.submit(animate, globeAgent.value(), gridAgent.value());
    });
    animatorAgent.listenTo(rendererAgent, "start", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](stopCurrentAnimation, true));
    animatorAgent.listenTo(gridAgent, "submit", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](stopCurrentAnimation, false));
    animatorAgent.listenTo(fieldAgent, "submit", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](stopCurrentAnimation, false));
    overlayAgent.listenTo(fieldAgent, "update", function () {
      overlayAgent.submit(drawOverlay, fieldAgent.value(), configuration.get("overlayType"), configuration.get("animate"));
    });
    overlayAgent.listenTo(rendererAgent, "start", function () {
      // Immediately clear overlay. Chrome will wait until mouse pauses before agent is triggered. :(
      _micro__WEBPACK_IMPORTED_MODULE_6__["clearCanvas"](_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#overlay").node());
      overlayAgent.submit(drawOverlay, fieldAgent.value(), null, null);
    });
    overlayAgent.listenTo(configuration, "change", function () {
      var changed = underscore__WEBPACK_IMPORTED_MODULE_2__["keys"](configuration.changedAttributes()); // if only overlay relevant flags have changed...


      if (underscore__WEBPACK_IMPORTED_MODULE_2__["intersection"](changed, ["overlayType", "showGridPoints", "animate"]).length > 0) {
        overlayAgent.submit(drawOverlay, fieldAgent.value(), configuration.get("overlayType"), configuration.get("animate"));
      }
    });
    configuration.on("change:animate", function (context, enabled) {
      if (!enabled) {
        stopCurrentAnimation(true);
      } else {
        startInterpolation();
      }
    }); // Add event handlers for showing, updating, and removing location details.

    inputController.on("click", saveLocation);
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-close").on("click", removeLocation);
    fieldAgent.on("update", updateLocation);
    configuration.on("change:loc", updateLocation); // Modify menu depending on what mode we're in.

    configuration.on("change:param", function (context, mode) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".ocean-mode").classed("invisible", mode !== "ocean");
      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".wind-mode").classed("invisible", mode !== "wind").selectAll(".text-button").classed("disabled", mode !== "wind"); // hack: hot keys cannot change height

      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".chem-mode").classed("invisible", mode !== "chem");
      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".particulates-mode").classed("invisible", mode !== "particulates");
      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".space-mode").classed("invisible", mode !== "space"); // d3.selectAll(".argo-mode").classed("invisible", mode !== "argo");
      // d3.select("#notice").classed("invisible", true);

      switch (mode) {
        case "chem":
        case "particulates": //d3.select("#notice").classed("invisible", false);
        // fall through

        case "wind":
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-backward-more").attr("title", "-1 Day");
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-backward").attr("title", "-3 Hours");
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-forward").attr("title", "+3 Hours");
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-forward-more").attr("title", "+1 Day");
          break;

        case "ocean":
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-backward-more").attr("title", "-1 Month");
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-backward").attr("title", "-5 Days");
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-forward").attr("title", "+5 Days");
          _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-forward-more").attr("title", "+1 Month");
          break;
      }
    }); // Add handlers for mode buttons.

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#air-mode").on("click", function () {
      if (configuration.get("param") !== "wind") {
        configuration.save({
          param: "wind",
          surface: "surface",
          level: "level",
          overlayType: "default",
          animate: shouldPlayAnimation("wind")
        });
      }
    });
    configuration.on("change:param", function (x, param) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#air-mode").classed("highlighted", param === "wind");
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#ocean-mode").on("click", function () {
      if (configuration.get("param") !== "ocean") {
        // When switching between modes, there may be no associated data for the current date. So we need
        // find the closest available according to the catalog. This is not necessary if date is "current".
        // UNDONE: this code is annoying. should be easier to get date for closest ocean product.
        var ocean = {
          param: "ocean",
          surface: "primary",
          level: "waves",
          overlayType: "significant_wave_height",
          animate: shouldPlayAnimation("ocean")
        };

        var attr = underscore__WEBPACK_IMPORTED_MODULE_2__["clone"](configuration.attributes);

        if (attr.date === "current") {
          configuration.save(ocean);
        } else {
          Promise.all(products.productsFor(underscore__WEBPACK_IMPORTED_MODULE_2__["extend"](attr, ocean))).then(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 1),
                product = _ref6[0];

            if (product.date()) {
              configuration.save(underscore__WEBPACK_IMPORTED_MODULE_2__["extend"](ocean, _micro__WEBPACK_IMPORTED_MODULE_6__["dateToConfig"](product.date())));
            }
          }).catch(report.error);
        }
      }
    });
    configuration.on("change:param", function (x, param) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#ocean-mode").classed("highlighted", param === "ocean");
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#chem-mode").on("click", function () {
      if (configuration.get("param") !== "chem") {
        configuration.save({
          param: "chem",
          surface: "surface",
          level: "level",
          overlayType: "cosc",
          animate: shouldPlayAnimation("chem")
        });
      }
    });
    configuration.on("change:param", function (x, param) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#chem-mode").classed("highlighted", param === "chem");
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#particulates-mode").on("click", function () {
      if (configuration.get("param") !== "particulates") {
        configuration.save({
          param: "particulates",
          surface: "surface",
          level: "level",
          overlayType: "duexttau",
          animate: shouldPlayAnimation("particulates")
        });
      }
    });
    configuration.on("change:param", function (x, param) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#particulates-mode").classed("highlighted", param === "particulates");
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#space-mode").on("click", function () {
      if (configuration.get("param") !== "space") {
        configuration.save({
          param: "space",
          surface: "surface",
          level: "level",
          overlayType: "aurora",
          animate: shouldPlayAnimation("space")
        });
      }
    });
    configuration.on("change:param", function (x, param) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#space-mode").classed("highlighted", param === "space");
    });
    /*
            d3.select("#argo-mode").on("click", function() {
                if (configuration.get("param") !== "argo") {
                    configuration.save({
                        param: "argo",
                        surface: "pressure",
                        level: "2p5",
                        overlayType: "argo_mean_temp",
                        animate: shouldPlayAnimation("argo"),
                    });
                }
            });
            configuration.on("change:param", function(x, param) {
                d3.select("#argo-mode").classed("highlighted", param === "argo");
            });
    */
    // Add logic to disable buttons that are incompatible with each other.

    configuration.on("change:overlayType", function (x, ot) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".surface").classed("disabled", function () {
        if (configuration.get("param") !== "wind") {
          return true;
        }

        return this.getAttribute("id") === "surface-level" ? ot === "wind_power_density" : ot === "misery_index";
      });
    });
    configuration.on("change:surface", function (x, s) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#wind_power_density").classed("disabled", s === "surface");
    }); // Add event handlers for the time navigation buttons.

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-backward-more").on("click", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](navigate, -10));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-forward-more").on("click", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](navigate, +10));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-backward").on("click", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](navigate, -1));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-forward").on("click", underscore__WEBPACK_IMPORTED_MODULE_2__["partial"](navigate, +1));
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#nav-now").on("click", function () {
      configuration.save({
        date: "current"
      });
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#option-show-grid").on("click", function () {
      configuration.save({
        showGridPoints: !configuration.get("showGridPoints")
      });
    });
    configuration.on("change:showGridPoints", function (x, showGridPoints) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#option-show-grid").classed("highlighted", showGridPoints);
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#animate-start").on("click", function () {
      configuration.save({
        animate: !configuration.get("animate")
      });
    });
    configuration.on("change:animate", function (x, animate) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#animate-start").classed("highlighted", animate);
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#hd").on("click", function () {
      configuration.save({
        hd: !configuration.get("hd")
      });
    });
    configuration.on("change:hd", function (x, hd) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#hd").classed("highlighted", hd);
    }); // Add handlers for all wind level buttons.

    _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".surface").each(function () {
      var id = this.id,
          parts = id.split("-");
      bindButtonToConfiguration("#" + id, {
        param: "wind",
        surface: parts[0],
        level: parts[1]
      });
    }); // Add handlers for ocean animation types.

    bindButtonToConfiguration("#animate-currents", {
      param: "ocean",
      surface: "surface",
      level: "currents",
      animate: true,
      overlayType: "default"
    }, [{
      param: "ocean",
      surface: "surface",
      level: "currents"
    }]);
    bindButtonToConfiguration("#animate-waves", {
      param: "ocean",
      surface: "primary",
      level: "waves",
      animate: true,
      overlayType: "default"
    }, [{
      param: "ocean",
      surface: "primary",
      level: "waves"
    }]);
    /*
            // Add handlers for all argo depth buttons.
            d3.selectAll(".argo-surface").each(function() {
                const id = this.id, parts = id.split("-");
                bindButtonToConfiguration("#" + id, {param: "argo", surface: "pressure", level: parts[1]});
            });
    */
    // Add handlers for all overlay buttons.

    products.overlayTypes().each(function (type) {
      var newAttr = {
        overlayType: type
      },
          highlightAttrList = [newAttr];

      if (type === "misery_index") {
        underscore__WEBPACK_IMPORTED_MODULE_2__["extend"](newAttr, {
          surface: "surface",
          level: "level"
        });
      } else if (type === "currents") {
        highlightAttrList.push({
          param: "ocean",
          surface: "surface",
          level: "currents",
          overlayType: "default"
        });
      } else if (type === "primary_waves") {
        highlightAttrList.push({
          param: "ocean",
          surface: "primary",
          level: "waves",
          overlayType: "default"
        });
      }

      bindButtonToConfiguration("#".concat(type.replace(".", "")), newAttr, highlightAttrList);
    });
    bindButtonToConfiguration("#wind", {
      param: "wind",
      overlayType: "default"
    });
    bindButtonToConfiguration("#no-overlay", {
      overlayType: "off"
    });
    /*
            bindButtonToConfiguration("#argo-2p5", {surface: "pressure", level: "2p5dbar"});
            bindButtonToConfiguration("#argo-400", {surface: "pressure", level: "400dbar"});
            bindButtonToConfiguration("#argo_temp_mean", {overlayType: "argo_temp_mean"});
            bindButtonToConfiguration("#argo_temp_anom", {overlayType: "argo_temp_anom"});
            bindButtonToConfiguration("#argo_salinity_mean", {overlayType: "argo_salinity_mean"});
            bindButtonToConfiguration("#argo_salinity_anom", {overlayType: "argo_salinity_anom"});
            bindButtonToConfiguration("#argo-planned", {argoFloat: "planned"});
            bindButtonToConfiguration("#argo-recent", {argoFloat: "recent"});
            bindButtonToConfiguration("#argo-operational", {argoFloat: "operational"});
            bindButtonToConfiguration("#argo-dead", {argoFloat: "dead"});
            bindButtonToConfiguration("#argo-none", {argoFloat: null});
    */
    // Add handlers for all projection buttons.

    underscore__WEBPACK_IMPORTED_MODULE_2__["keys"](_globes__WEBPACK_IMPORTED_MODULE_8__).forEach(function (p) {
      bindButtonToConfiguration("#" + p, {
        projection: p,
        orientation: ""
      }, [{
        projection: p
      }]);
    }); // When touch device changes between portrait and landscape, rebuild globe using the new view size.


    _d3__WEBPACK_IMPORTED_MODULE_3__["select"](window).on("orientationchange", function () {
      window.scrollTo(0, 0);
      view = _micro__WEBPACK_IMPORTED_MODULE_6__["view"]();
      fillScreen();
      globeAgent.submit(buildGlobe, configuration.get("projection"));
      var fastoverlay = fastoverlayAgent.value();

      if (fastoverlay) {
        fastoverlay.changeDisplaySize(view);
      }
    });

    if (_micro__WEBPACK_IMPORTED_MODULE_6__["isKioskMode"]()) {
      _d3__WEBPACK_IMPORTED_MODULE_3__["selectAll"](".kiosk").classed("invisible", true);
    } else {
      setTimeout(function () {
        _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#menu-ham").transition().style("opacity", "0").remove();
      }, 15 * 1000);
    }

    function setupWebGL() {
      var msg = _gl_glCheck__WEBPACK_IMPORTED_MODULE_13__["default"].pass ? "ok" : JSON.stringify(_gl_glCheck__WEBPACK_IMPORTED_MODULE_13__["default"]);
      log.debug("check gl: ".concat(msg));

      if (underscore__WEBPACK_IMPORTED_MODULE_2__["isFunction"](window.ga)) {
        window.ga("send", "event", "gl", msg);
      }

      if (!_gl_glCheck__WEBPACK_IMPORTED_MODULE_13__["default"].pass) {
        return;
      }

      var canvas = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#fastoverlay").node();
      var fastoverlay = Object(_gl_fastoverlay__WEBPACK_IMPORTED_MODULE_14__["default"])(canvas, configuration, globeAgent, gridAgent, rendererAgent, animatorAgent);
      fastoverlayAgent.submit(fastoverlay);
    }

    setupWebGL();
    var pressure = ["surface-level", "isobaric-1000hPa", "isobaric-850hPa", "isobaric-700hPa", "isobaric-500hPa", "isobaric-250hPa", "isobaric-70hPa", "isobaric-10hPa"];

    function pressureLevel() {
      var attr = configuration.attributes,
          key = attr.surface + "-" + attr.level;
      return attr.param === "wind" ? underscore__WEBPACK_IMPORTED_MODULE_2__["indexOf"](pressure, key) : -1;
    }

    function clearDialog() {
      if (!_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#settings-wrap").classed("invisible")) {
        earth.click("settings-hide");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#location-close").classed("invisible")) {
        earth.click("location-close");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#menu").classed("invisible")) {
        earth.click("show-menu");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#notice").classed("invisible")) {
        earth.click("notice-hide");
        return true;
      }

      if (!_d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#sponsor").classed("invisible")) {
        earth.click("sponsor-hide");
        return true;
      }
    }

    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("body").on("keydown", function () {
      var e = _d3__WEBPACK_IMPORTED_MODULE_3__["event"],
          key = _keyboard__WEBPACK_IMPORTED_MODULE_10__["key"](e);

      if (e.defaultPrevented || e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) {
        return;
      }

      switch (key) {
        case "Escape":
          if (!clearDialog()) return;
          break;

        default:
          return;
        // Never bind to keys used for search in various browsers:  /.',
      }

      e.preventDefault(); // stops FF from showing search bar
    });
    _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("body").on("keypress", function () {
      var e = _d3__WEBPACK_IMPORTED_MODULE_3__["event"],
          key = _keyboard__WEBPACK_IMPORTED_MODULE_10__["key"](e);

      if (e.defaultPrevented || e.altKey || e.ctrlKey || e.metaKey) {
        return;
      }

      switch (key) {
        case "e":
          earth.click("show-menu");
          break;

        case "I":
          earth.click(pressure[pressure.length - 1]);
          break;

        case "i":
          earth.click(pressure[pressureLevel() + 1]);
          break;

        case "m":
          earth.click(pressure[pressureLevel() - 1]);
          break;

        case "M":
          earth.click(pressure[0]);
          break;

        case "J":
          earth.click("nav-backward-more");
          break;

        case "j":
          earth.click("nav-backward");
          break;

        case "k":
          earth.click("nav-forward");
          break;

        case "K":
          earth.click("nav-forward-more");
          break;

        case "n":
          earth.click("nav-now");
          break;

        case "p":
          earth.click("animate-start");
          break;

        case "g":
          earth.click("option-show-grid");
          break;

        case "H":
          earth.click("hd");
          break;

        case "d":
          inputController.hotkey("zoom", 1.003);
          break;

        case "x":
          inputController.hotkey("zoom", 0.997);
          break;

        case "D":
          inputController.hotkey("zoom", 1.05);
          break;

        case "X":
          inputController.hotkey("zoom", 0.95);
          break;

        case "w":
          inputController.hotkey("up", 1);
          break;

        case "W":
          inputController.hotkey("up", 8);
          break;

        case "z":
          inputController.hotkey("down", 1);
          break;

        case "Z":
          inputController.hotkey("down", 8);
          break;

        case "a":
          inputController.hotkey("left", 1);
          break;

        case "A":
          inputController.hotkey("left", 8);
          break;

        case "s":
          inputController.hotkey("right", 1);
          break;

        case "S":
          inputController.hotkey("right", 8);
          break;

        default:
          return;
        // Never bind to keys used for search in various browsers:  /.',
        // Never bind to cursor keys (used for scrolling during zoom), or to Alt|Cmd|Ctrl chords.
        // Never bind to these keys: http://stackoverflow.com/questions/9612458/hot-keys-to-avoid
      }

      e.preventDefault(); // stops FF from showing search bar
    });
  }

  function start() {
    // Everything is now set up, so load configuration from the hash fragment and kick off change events.
    configuration.fetch();
  }

  Promise.resolve().then(init).then(start).catch(report.error);

  function activeProduct() {
    return (gridAgent.value() || {}).overlayGrid;
  }

  underscore__WEBPACK_IMPORTED_MODULE_2__["extend"](earth, {
    url: function url() {
      return window.location.href.toString();
    },
    scale: {
      /**
       * @param {Number} pct percentage in the range [0, 100] (inclusive)
       * @returns {String} JSON encoded map of units to values, or "{}" if no product is active. For example:
       *     {
       *         "wind": {
       *             "m/s" : "100° @ 7.3",
       *             "kn"  : "100° @ 14",
       *             "mph" : "100° @ 16"
       *         }
       *     }
       */
      valueAt: function valueAt(pct) {
        var product = activeProduct(),
            result = {};

        if (product) {
          var group = {},
              value = Object(_math__WEBPACK_IMPORTED_MODULE_1__["spread"])(pct / 100, product.scale.bounds);
          product.units.forEach(function (unit) {
            group[unit.label] = _micro__WEBPACK_IMPORTED_MODULE_6__["formatScalar"](value, unit);
          });
          result[product.type] = group;
        }

        return JSON.stringify(result);
      },

      /**
       * @returns {String} a JSON encoded array of colors, "[r0, g0, b0, a0, ..., rn-1, gn-1, bn-1, an-1]",
       *          where n is the size of the palette. The result is empty "{}" if no product is active, otherwise
       *          the length will be size*4.
       *          {
       *              "wind": [30, 20, 92, 255, ..., 193, 245, 223, 255]
       *          }
       */
      palette: function palette() {
        var product = activeProduct();
        return JSON.stringify(product ? _defineProperty({}, product.type, _micro__WEBPACK_IMPORTED_MODULE_6__["toArray"](product.scale.colors)) : {});
      }
    },

    /**
     * Navigate current product to the specified date. Return the expected date of that product as milliseconds,
     * or 0 if there is no product, or the specified date is not valid.
     *
     * @param {*} date milliseconds from unix epoch or string in format "yyyy-MM-ddThh:mm:ssZ".
     * @returns {Number} date of the product best matching the specified date as milliseconds from epoch,
     *                   or 0 if no product can be found.
     */
    navToDate: function navToDate(date) {
      var product = activeProduct();
      var target = new Date(date);
      if (!product || underscore__WEBPACK_IMPORTED_MODULE_2__["isNaN"](target.getUTCFullYear())) return 0;
      target = product.navigateTo(_utc__WEBPACK_IMPORTED_MODULE_7__["parts"](target));
      if (!target) return 0;

      underscore__WEBPACK_IMPORTED_MODULE_2__["defer"](function () {
        configuration.save(_micro__WEBPACK_IMPORTED_MODULE_6__["dateToConfig"](target)); // defer all side effects
      });

      return _utc__WEBPACK_IMPORTED_MODULE_7__["date"](target).getTime();
    },

    /**
     * Triggers a click event on the specified button.
     *
     * @param {String} id the button id.
     */
    click: function click(id) {
      // side effects means we need to defer
      underscore__WEBPACK_IMPORTED_MODULE_2__["defer"](function () {
        var node = _d3__WEBPACK_IMPORTED_MODULE_3__["select"]("#" + id).node();
        return node !== null ? node.dispatchEvent(_micro__WEBPACK_IMPORTED_MODULE_6__["newClickEvent"]()) : undefined;
      });
    },

    /**
     * Shows location indicator at specified coordinates.
     *
     * @param {Number} lon
     * @param {Number} lat
     */
    locate: function locate(lon, lat) {
      // side effects means we need to defer
      underscore__WEBPACK_IMPORTED_MODULE_2__["defer"](_locate, lon, lat);
    },
    orient: function orient(coord) {
      // HACK for now. What's the best way to do this?
      underscore__WEBPACK_IMPORTED_MODULE_2__["defer"](function () {
        var globe = globeAgent.value();

        if (coord === undefined) {
          return globe.projection.rotate();
        }

        globe.projection.rotate(coord);
        configuration.save({
          orientation: globe.orientation()
        }); // triggers reorientation
      });
    },

    /**
     * Stop animation.
     */
    stop: function stop() {
      // side effects means we need to defer
      underscore__WEBPACK_IMPORTED_MODULE_2__["defer"](function () {
        configuration.save({
          animate: false
        });
      });
    },

    /**
     * Forcefully ends the current move operation, if any.
     */
    cancelMove: function cancelMove() {
      inputController.cancelMove();
    }
  });
}

/***/ }),

/***/ "./public/js/gl/fastoverlay.js":
/*!*************************************!*\
  !*** ./public/js/gl/fastoverlay.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../d3 */ "./public/js/d3.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _glu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./glu */ "./public/js/gl/glu.js");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");






var display = _micro__WEBPACK_IMPORTED_MODULE_3__["view"]();

var header = __webpack_require__(/*! ./header.frag */ "./public/js/gl/header.frag");

var main = __webpack_require__(/*! ./main.frag */ "./public/js/gl/main.frag");
/**
 * @param {HTMLCanvasElement} canvas
 * @param configuration
 * @param globeAgent
 * @param gridAgent
 * @param rendererAgent
 * @param animatorAgent
 * @returns {*}
 */


/* harmony default export */ __webpack_exports__["default"] = (function (canvas, configuration, globeAgent, gridAgent, rendererAgent, animatorAgent) {
  // Draw webgl offscreen then copy to 2d canvas. Reduces jank, especially on iOS, during compositing of different
  // layers at the expense of some performance. Better way?
  var useIntermediateBuffer = true;
  var container = useIntermediateBuffer ? _glu__WEBPACK_IMPORTED_MODULE_2__["default"].createCanvas() : canvas;
  var targetCtx = useIntermediateBuffer ? canvas.getContext("2d") : undefined;
  var canvases = _d3__WEBPACK_IMPORTED_MODULE_0__["selectAll"]([canvas, container]).style("width", "".concat(display.width, "px")).style("height", "".concat(display.height, "px"));
  var gl = _glu__WEBPACK_IMPORTED_MODULE_2__["default"].getWebGL(container);
  var glu = _glu__WEBPACK_IMPORTED_MODULE_2__["default"].attach(gl);
  gl.getExtension("OES_texture_float");
  gl.getExtension("OES_texture_float_linear");
  gl.disable(gl.DEPTH_TEST);
  gl.clearColor(0, 0, 0, 0);
  var vertexShader = glu.makeShader(gl.VERTEX_SHADER, _glu__WEBPACK_IMPORTED_MODULE_2__["default"].planeVertexShader());
  var textures = {}; // registry of textures used by webgl components, by name

  var units = underscore__WEBPACK_IMPORTED_MODULE_1__["range"](8).map(function () {
    return null;
  }); // a[i] -> texture, where i is unit index. webgl 1.0 guarantees 8 units


  var currentUnit = 1; // next available texture unit

  var currentSources = []; // sources of current program

  var currentProgram = null; // program to run

  var currentUniforms = null; // uniform assigner

  var currentWidth = -1; // viewport width

  var currentHeight = -1; // viewport height

  /**
   * Compiles new shaders and sets up unit plane.
   * @param {string[]} newSources
   */

  function buildProgram(newSources) {
    var fragmentShaderSource = header + newSources.join("") + main;
    var fragmentShader = glu.makeShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
    var newProgram = glu.makeProgram([vertexShader, fragmentShader]);
    glu.attribs(newProgram).set(_glu__WEBPACK_IMPORTED_MODULE_2__["default"].unitPlaneAttributes());
    currentSources = newSources;
    currentProgram = newProgram;
    currentUniforms = glu.uniforms(newProgram, textures);
    gl.useProgram(newProgram);
  }
  /**
   * Applies delta between existing texture settings and new settings.
   * @param def texture definition as specified in GLU
   * @param entry existing texture entry object: {def: {}, texture: WebGLTexture, unit: number}
   * @returns {Object} texture entry object, with reference to "data" removed to allow garbage collection.
   */


  function apply(def, entry) {
    if (entry) {
      // texture entry exists, so let's find what's different
      var existing = entry.def;

      if (def.hash === existing.hash) {
        // same data
        if (!glu.updateTexture2DParams(entry.texture, def, existing)) {
          return entry; // nothing to do because nothing is different
        }

        return {
          def: underscore__WEBPACK_IMPORTED_MODULE_1__["omit"](def, "data"),
          texture: entry.texture
        };
      } // pixels are different


      if (def.width === existing.width && def.height === existing.height && def.format === existing.format && def.type === existing.type) {
        // but data is the same shape, so can reuse this texture
        glu.updateTexture2D(entry.texture, def);
        return {
          def: underscore__WEBPACK_IMPORTED_MODULE_1__["omit"](def, "data"),
          texture: entry.texture
        };
      } // replace texture with a new one


      gl.deleteTexture(entry.texture);
    } // create new texture


    var texture = glu.makeTexture2D(def);
    return {
      def: underscore__WEBPACK_IMPORTED_MODULE_1__["omit"](def, "data"),
      texture: texture
    };
  }
  /**
   * @param {Object} defs creates or updates texture entries for each specified texture definition
   * @returns {string[]} names of the texture entries
   */


  function registerTextures(defs) {
    return Object.keys(defs).map(function (name) {
      return textures[name] = apply(defs[name], textures[name]);
    });
  }
  /**
   * Sequentially assigns and binds textures to texture units.
   * @param {Object[]} entries the texture entries to bind.
   */


  function bindTextures(entries) {
    entries.forEach(function (entry) {
      var texture = entry.texture; // check if already bound to the current unit

      if (units[currentUnit] !== texture) {
        units[currentUnit] = texture;
        gl.activeTexture(gl.TEXTURE0 + currentUnit);
        gl.bindTexture(gl.TEXTURE_2D, texture);
      }

      entry.unit = currentUnit++;
    });
  }
  /**
   * Get the webgl components that are currently renderable.
   * @returns {Object[]} an array of webgl components, or undefined if a component describes itself as non-renderable.
   */


  function collectComponents() {
    var globe = globeAgent.value();
    var product = (gridAgent.value() || {}).overlayGrid || {};
    var factories = [globe && globe.optimizedProjection(), product.grid && product.grid(), product.field && product.field()["bilinear"], product.scale];
    return factories.map(function () {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return e["webgl"] && e.webgl(glu); // does it have a webgl() function? if so, then supports webgl.
    });
  }
  /**
   * Adjust size of drawingbuffer (i.e., viewport) to match desired view and detail settings.
   * @param {number} detail ratio of drawing buffer to display size.
   */


  function adjustViewport(detail) {
    var newWidth = Math.round(display.width * detail);
    var newHeight = Math.round(display.height * detail);

    if (currentWidth !== newWidth || currentHeight !== newHeight) {
      canvases.attr("width", newWidth).attr("height", newHeight);
      gl.viewport(0, 0, newWidth, newHeight);
      currentWidth = newWidth;
      currentHeight = newHeight;
    }
  }

  function clear() {
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (targetCtx) {
      targetCtx.clearRect(0, 0, currentWidth, currentHeight);
    }
  }

  var controller = {
    /**
     * Render a frame.
     *
     * @returns {boolean} true if current components support webgl, otherwise false (to then be handled by 2d).
     */
    draw: function draw() {
      var detail = configuration.get("hd") ? 1.0 : 0.5;
      adjustViewport(detail);
      clear(); // if we're just downloading and interpolating a new grid, and animation is turned on, then we don't want to
      // adjust the alpha.

      var renderer = rendererAgent.value();
      var product = (gridAgent.value() || {}).overlayGrid;
      var overlayType = configuration.get("overlayType");
      var animate = configuration.get("animate"); // !!animatorAgent.value();

      var components = collectComponents();

      if (overlayType === "off" || !renderer || components.some(function (e) {
        return e === undefined;
      })) {
        // Either we aren't supposed to draw anything, or some of the components do not yet support webgl.
        return false;
      } // Check if we should change the program.


      var newSources = underscore__WEBPACK_IMPORTED_MODULE_1__["flatten"](components.map(function (c) {
        return c.shaderSource();
      }));

      if (!_micro__WEBPACK_IMPORTED_MODULE_3__["arraysEq"](currentSources, newSources)) {
        buildProgram(newSources);
      } // Bind textures needed for this frame to available units. Just sequentially assign from 1.


      currentUnit = 1;
      components.forEach(function (c) {
        return bindTextures(registerTextures(c.textures()));
      });

      while (currentUnit < units.length) {
        units[currentUnit++] = null; // clear out unused units to release their texture objects.
      } // Ask each component to assign uniforms.


      components.forEach(function (c) {
        return currentUniforms.set(c.uniforms());
      });
      currentUniforms.set({
        u_Detail: detail,
        // HACK: set alpha based on current state of animating particles.
        //       should this instead by handled by the palette component?
        u_Alpha: (animate ? product.alpha.animated : product.alpha.single) / 255
      });
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      if (useIntermediateBuffer) {
        targetCtx.drawImage(container, 0, 0);
      }

      return true;
    },

    /**
     * Apply new display size.
     * @param {{width: number, height: number}} newDisplay
     */
    changeDisplaySize: function changeDisplaySize(newDisplay) {
      canvases.style("width", "".concat(newDisplay.width, "px")).style("height", "".concat(newDisplay.height, "px"));
      display = newDisplay; // The viewport will be automatically adjusted during the next draw.
    }
  }; // All of these events trigger a new frame.

  configuration.on("change:overlayType", controller.draw);
  configuration.on("change:hd", controller.draw);
  globeAgent.on("update", controller.draw);
  gridAgent.on("update", controller.draw);
  rendererAgent.on("redraw", controller.draw);
  rendererAgent.on("render", controller.draw);
  animatorAgent.on("update", controller.draw);
  return controller;
});

/***/ }),

/***/ "./public/js/gl/glCheck.js":
/*!*********************************!*\
  !*** ./public/js/gl/glCheck.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/* harmony import */ var _glu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./glu */ "./public/js/gl/glu.js");
/*
 * glCheck: checks browser for proper WebGL support
 *
 * Copyright (c) 2018 Cameron Beccario
 */





function glCheck() {
  var res = {
    pass: false
  };
  var gl;
  var context = ""; // function checkExists(decls, expected) {
  //     return !Object.keys(expected).some(name => {
  //         const decl = decls[name] || {}, type = decl.type || "";
  //         return expected[name] !== type ? (res[name] = type, true) : false;
  //     });
  // }

  function check(tag) {
    var num = gl.getError();

    if (num) {
      throw new Error("".concat(num, ":").concat(tag));
    }
  }

  try {
    gl = _glu__WEBPACK_IMPORTED_MODULE_1__["default"].getWebGL(_glu__WEBPACK_IMPORTED_MODULE_1__["default"].createCanvas());

    if (!gl) {
      res.hasContext = false;
      return res; // Fatal: WebGL not supported.
    }

    var glu = _glu__WEBPACK_IMPORTED_MODULE_1__["default"].attach(gl);
    res.floatTex = !!gl.getExtension("OES_texture_float");
    res.floatTexLinear = !!gl.getExtension("OES_texture_float_linear");

    if (!res.floatTex) {
      return res; // Fatal: float textures not supported. (We can live without linear support.)
    }

    context = "program1";
    var vertexShader = glu.makePlaneVertexShader();
    var program1 = glu.makeProgram([vertexShader, glu.makeShader(gl.FRAGMENT_SHADER, __webpack_require__(/*! ./glCheck1.frag */ "./public/js/gl/glCheck1.frag"))]);
    context = "tex0";
    var width = 3,
        height = 1;
    var tex0 = glu.makeTexture2D({
      format: gl.LUMINANCE,
      type: gl.FLOAT,
      width: width,
      height: height,
      data: new Float32Array([0, 10, 20])
    });
    context = "tex1";
    var tex1 = glu.makeTexture2D({
      format: gl.LUMINANCE_ALPHA,
      type: gl.FLOAT,
      width: width,
      height: height,
      data: new Float32Array([0, 0, 10, -10, 20, -20]),
      TEXTURE_MIN_FILTER: res.floatTexLinear ? gl.LINEAR : gl.NEAREST,
      TEXTURE_MAG_FILTER: res.floatTexLinear ? gl.LINEAR : gl.NEAREST
    });
    context = "target";
    var target = glu.makeTexture2D({
      format: gl.RGBA,
      type: gl.UNSIGNED_BYTE,
      width: width,
      height: height,
      data: null
    });
    context = "run-program1";
    var textures = {
      a: {
        texture: tex0,
        unit: 0
      },
      b: {
        texture: tex1,
        unit: 1
      }
    };
    gl.activeTexture(gl.TEXTURE0 + textures.a.unit);
    check("activeTexture0");
    gl.bindTexture(gl.TEXTURE_2D, tex0);
    check("bindTexture0");
    gl.activeTexture(gl.TEXTURE0 + textures.b.unit);
    check("activeTexture1");
    gl.bindTexture(gl.TEXTURE_2D, tex1);
    check("bindTexture1");
    glu.makeFramebufferTexture2D(target);
    gl.viewport(0, 0, width, height);
    check("viewport");
    gl.useProgram(program1);
    check("useProgram");
    var attribs = glu.attribs(program1);
    attribs.set(_glu__WEBPACK_IMPORTED_MODULE_1__["default"].unitPlaneAttributes()); // if (!checkExists(attribs.decls(), {a_TexCoord: gl.FLOAT_VEC2, a_Position: gl.FLOAT_VEC2})) {
    //     return res;
    // }

    var uniforms = glu.uniforms(program1, textures);
    uniforms.set({
      u_Tex0: "a",
      u_Tex1: "b"
    }); // if (!checkExists(uniforms.decls(), {u_Tex0: gl.SAMPLER_2D, u_Tex1: gl.SAMPLER_2D})) {
    //     return res;
    // }

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    check("drawArrays");
    var out = new Uint8Array(width * height * 4);
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, out);
    check("readPixels");

    if (_micro__WEBPACK_IMPORTED_MODULE_0__["arraysEq"](out, [0, 0, 0, 0, 10, 7, 7, 0, 20, 17, 17, 0])) {
      res.floatTexLinear = true;
    } else if (_micro__WEBPACK_IMPORTED_MODULE_0__["arraysEq"](out, [0, 0, 0, 0, 10, 10, 10, 0, 20, 20, 20, 0])) {
      res.floatTexLinear = false; // float textures work, just not linear filtering.
    } else {
      res.floatTexLinear = res.floatTex = false;
      return res; // Fatal: float texture lookup completely failed.
    }

    context = "update-tex0";
    glu.updateTexture2D(tex0, {
      format: gl.LUMINANCE,
      type: gl.FLOAT,
      width: width,
      height: height,
      data: new Float32Array([7e37, 100, 200])
    });
    gl.activeTexture(gl.TEXTURE0 + textures.a.unit);
    check("activeTexture");
    gl.bindTexture(gl.TEXTURE_2D, tex0);
    check("bindTexture");
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    check("drawArrays");
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, out);
    check("readPixels");

    if (out[4] !== 100 || out[8] !== 200) {
      res.texSubImage2D = false;
      return res;
    }

    if (out[3] !== 1) {
      res.missingVal = false;
      return res;
    }

    context = "program2";
    var program2 = glu.makeProgram([vertexShader, glu.makeShader(gl.FRAGMENT_SHADER, __webpack_require__(/*! ./glCheck2.frag */ "./public/js/gl/glCheck2.frag"))]);
    gl.useProgram(program2);
    check("useProgram");
    glu.attribs(program2).set(glu.unitPlaneAttributes());
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    check("drawArrays");
    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, out);
    check("readPixels");

    if (out[0] !== 0) {
      res.asin = out[0];
      return res;
    }

    context = "end";
    res.maxTexSize = +gl.getParameter(gl.MAX_TEXTURE_SIZE) || -1;
    check("getParameter");
    var f = gl["getShaderPrecisionFormat"] ? gl["getShaderPrecisionFormat"](gl.FRAGMENT_SHADER, gl.HIGH_FLOAT) : {};
    check("getShaderPrecisionFormat");
    res.precision = +(f || {}).precision || -1;

    if (res.maxTexSize < 4096 || res.precision < 23) {
      return res; // Fatal: not enough.
    }

    res.err = gl.getError();
    res.pass = !res.err;
  } catch (e) {
    res.err = "".concat(context, ":").concat(e.toString());
  }

  return res;
}

/* harmony default export */ __webpack_exports__["default"] = (glCheck());

/***/ }),

/***/ "./public/js/gl/glCheck1.frag":
/*!************************************!*\
  !*** ./public/js/gl/glCheck1.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nprecision highp sampler2D;\n\nconst float WIDTH = 3.0;\n\n                           //     0.5          1.5            2.5         : x coord\n                           //     0.166        0.5            0.833       : normalized x coord\nuniform sampler2D u_Tex0;  // [(0,0,0,1), (10,10,10,  1), (20,20,20,  1)] : LUMINANCE, NEAREST\nuniform sampler2D u_Tex1;  // [(0,0,0,0), (10,10,10,-10), (20,20,20,-20)] : LUMINANCE_ALPHA, LINEAR\n\nvoid main() {\n    vec2 st = (floor(gl_FragCoord.xy) + 0.20) / WIDTH;  // x = 0.2, 1.2, 2.2  =>  x = 0.066, 0.4, 0.733\n    vec4 c0 = texture2D(u_Tex0, st);\n    vec4 c1 = texture2D(u_Tex1, st);\n    gl_FragColor = vec4(c0.r, c1.r, c1.a * -1.0, float(c0.r == 7e37)) / 255.0;\n}\n"

/***/ }),

/***/ "./public/js/gl/glCheck2.frag":
/*!************************************!*\
  !*** ./public/js/gl/glCheck2.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nvoid main() {\n    float asin_err = abs(asin(0.894) - 1.1061944) * 100.0;\n    gl_FragColor = vec4(asin_err);\n}\n"

/***/ }),

/***/ "./public/js/gl/glu.js":
/*!*****************************!*\
  !*** ./public/js/gl/glu.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLU; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../log */ "./public/js/log.js");
/*
 * glu: webgl helpers
 *
 * Copyright (c) 2018 Cameron Beccario
 */


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var log = Object(_log__WEBPACK_IMPORTED_MODULE_2__["default"])(); // see http://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
//     http://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html

function throwOnErr(msg) {
  throw new Error(msg);
}

var PLANE_VERTEX_SHADER = __webpack_require__(/*! ./plane.vert */ "./public/js/gl/plane.vert");

var GLU =
/*#__PURE__*/
function () {
  function GLU() {
    _classCallCheck(this, GLU);
  }

  _createClass(GLU, null, [{
    key: "createCanvas",

    /** @returns {HTMLCanvasElement} */
    value: function createCanvas() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var result =
      /** @type {HTMLCanvasElement} */
      document.createElement("canvas");
      result.width = width;
      result.height = height;
      return result;
    }
    /**
     * @param {HTMLCanvasElement} canvas DOM element
     * @param {Object} [attributes] WebGL context attributes
     * @returns {WebGLRenderingContext} the context or undefined if not supported.
     */

  }, {
    key: "getWebGL",
    value: function getWebGL(canvas, attributes) {
      var gl;

      try {
        gl = canvas.getContext("webgl", attributes);
      } catch (ignore) {}

      if (!gl) {
        try {
          gl = canvas.getContext("experimental-webgl", attributes);
        } catch (ignore) {}
      }

      return gl || undefined;
    }
    /** @returns {string} */

  }, {
    key: "planeVertexShader",
    value: function planeVertexShader() {
      return PLANE_VERTEX_SHADER;
    }
  }, {
    key: "unitPlaneAttributes",
    value: function unitPlaneAttributes() {
      return {
        a_Position: new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
        a_TexCoord: new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1])
      };
    }
    /**
     * @param {WebGLRenderingContext} gl
     * @param {Function} [ƒerr] ƒ(err) invoked when an error occurs (default is to throw).
     * @returns {GLUStick}
     */

  }, {
    key: "attach",
    value: function attach(gl) {
      var ƒerr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : throwOnErr;
      var defaultPixelStore = {
        PACK_ALIGNMENT: 1,
        UNPACK_ALIGNMENT: 1,
        UNPACK_FLIP_Y_WEBGL: false,
        UNPACK_PREMULTIPLY_ALPHA_WEBGL: false,
        UNPACK_COLORSPACE_CONVERSION_WEBGL: gl.BROWSER_DEFAULT_WEBGL
      };
      var defaultPixelStoreKeys = Object.keys(defaultPixelStore);
      var defaultTexParams = {
        TEXTURE_MIN_FILTER: gl.NEAREST,
        TEXTURE_MAG_FILTER: gl.NEAREST,
        TEXTURE_WRAP_S: gl.CLAMP_TO_EDGE,
        TEXTURE_WRAP_T: gl.CLAMP_TO_EDGE
      };
      var defaultTexParamKeys = Object.keys(defaultTexParams);

      function check(tag) {
        var num = gl.getError();

        if (num) {
          ƒerr("".concat(num, ":").concat(tag));
        }
      }

      return new (
      /*#__PURE__*/
      function () {
        function GLUStick() {
          _classCallCheck(this, GLUStick);
        }

        _createClass(GLUStick, [{
          key: "makePlaneVertexShader",

          /** @returns {WebGLShader} */
          value: function makePlaneVertexShader() {
            return this.makeShader(gl.VERTEX_SHADER, PLANE_VERTEX_SHADER);
          }
        }, {
          key: "unitPlaneAttributes",
          value: function unitPlaneAttributes() {
            return {
              a_Position: new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),
              a_TexCoord: new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1])
            };
          }
          /**
           * @param {number} type either VERTEX_SHADER or FRAGMENT_SHADER.
           * @param {string} source shader source code.
           * @returns {WebGLShader} the shader object, or null if the shader could not be compiled.
           */

        }, {
          key: "makeShader",
          value: function makeShader(type, source) {
            var shader = gl.createShader(type);
            check("createShader:".concat(type));
            gl.shaderSource(shader, source);
            check("shaderSource:".concat(type));
            gl.compileShader(shader);
            check("compileShader:".concat(type));
            var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            check("getShaderParameter:".concat(type));

            if (!status) {
              var message = gl.getShaderInfoLog(shader);
              check("getShaderInfoLog:".concat(type));
              gl.deleteShader(shader);
              check("deleteShader:".concat(type));
              ƒerr(message);
              return null;
            }

            return shader;
          }
          /**
           * @param {WebGLShader[]} shaders the compiled shaders.
           * @returns {WebGLProgram} the program, or null if the program could not be linked.
           */

        }, {
          key: "makeProgram",
          value: function makeProgram(shaders) {
            var program = gl.createProgram();
            check("createProgram");
            shaders.forEach(function (shader) {
              gl.attachShader(program, shader);
              check("attachShader");
            });
            gl.linkProgram(program);
            check("linkProgram");
            var status = gl.getProgramParameter(program, gl.LINK_STATUS);
            check("getProgramParameter");

            if (!status) {
              var message = gl.getProgramInfoLog(program);
              check("getProgramInfoLog");
              gl.deleteProgram(program);
              check("deleteProgram");
              ƒerr(message);
              return null;
            }

            return program;
          }
          /**
           * @param {WebGLTexture} texture 2d texture
           * @returns {WebGLFramebuffer} the framebuffer, or null if the framebuffer is not complete.
           */

        }, {
          key: "makeFramebufferTexture2D",
          value: function makeFramebufferTexture2D(texture) {
            var framebuffer = gl.createFramebuffer();
            check("createFramebuffer");
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            check("bindFramebuffer");
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            check("framebufferTexture2D");
            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            check("checkFramebufferStatus");

            if (status !== gl.FRAMEBUFFER_COMPLETE) {
              gl.deleteFramebuffer(framebuffer);
              check("deleteFramebuffer");
              callback("framebuffer: " + status);
              return null;
            }

            return framebuffer;
          }
          /**
           * @param {WebGLProgram} program
           * @param {Object} textures map from name to texture entry
           * @returns {GLUUniforms}
           */

        }, {
          key: "uniforms",
          value: function uniforms(program, textures) {
            var _decls = {};
            var count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
            check("getProgramParameter");

            underscore__WEBPACK_IMPORTED_MODULE_0__["range"](count).map(function (i) {
              var x = gl.getActiveUniform(program, i);
              check("getActiveUniform:".concat(i));
              return x;
            }).filter(function (e) {
              return !!e;
            }).forEach(function (e) {
              var location = gl.getUniformLocation(program, e.name);
              check("getUniformLocation:".concat(e.name));
              _decls[e.name] = {
                name: e.name,
                type: e.type,
                size: e.size,
                location: location
              };
            });

            function assign(name, v) {
              var decl = _decls[name] || {},
                  loc = decl.location; // log.debug(`uniform ${name}: ${v}`);

              switch (decl.type) {
                case gl.FLOAT:
                  return _micro__WEBPACK_IMPORTED_MODULE_1__["isArrayLike"](v) ? gl.uniform1fv(loc, v) : gl.uniform1f(loc, v);

                case gl.FLOAT_VEC2:
                  return gl.uniform2fv(loc, v);

                case gl.FLOAT_VEC3:
                  return gl.uniform3fv(loc, v);

                case gl.FLOAT_VEC4:
                  return gl.uniform4fv(loc, v);

                case gl.INT:
                  return _micro__WEBPACK_IMPORTED_MODULE_1__["isArrayLike"](v) ? gl.uniform1iv(loc, v) : gl.uniform1i(loc, v);

                case gl.INT_VEC2:
                  return gl.uniform2iv(loc, v);

                case gl.INT_VEC3:
                  return gl.uniform3iv(loc, v);

                case gl.INT_VEC4:
                  return gl.uniform4iv(loc, v);

                case gl.SAMPLER_2D:
                  {
                    var entry = textures[v];

                    if (!entry) {
                      log.warn("uniform '".concat(name, "' refers to unknown texture '").concat(v, "'"));
                      return;
                    }

                    gl.uniform1i(loc, entry.unit);
                    return;
                  }

                default:
                  log.warn("uniform '".concat(name, "' has unsupported type: ").concat(JSON.stringify(decl)));
              }
            }

            return new (
            /*#__PURE__*/
            function () {
              function GLUUniforms() {
                _classCallCheck(this, GLUUniforms);
              }

              _createClass(GLUUniforms, [{
                key: "decls",
                value: function decls() {
                  return _decls;
                }
                /**
                 * @param values an object {name: value, ...} where value is a number, array, or an object
                 *        {unit: i, texture: t} for binding a texture to a unit and sampler2D.
                 * @returns {GLUUniforms} this
                 */

              }, {
                key: "set",
                value: function set(values) {
                  Object.keys(values).forEach(function (name) {
                    assign(name, values[name]);
                    check("assign-uniform:".concat(name));
                  });
                  return this;
                }
              }]);

              return GLUUniforms;
            }())();
          }
          /**
           * @param {WebGLProgram} program
           * @returns {GLUAttribs}
           */

        }, {
          key: "attribs",
          value: function attribs(program) {
            var _decls2 = {};
            var count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
            check("getProgramParameter");

            underscore__WEBPACK_IMPORTED_MODULE_0__["range"](count).map(function (i) {
              var x = gl.getActiveAttrib(program, i);
              check("getActiveAttrib:".concat(i));
              return x;
            }).filter(function (e) {
              return !!e;
            }).forEach(function (e) {
              var location = gl.getAttribLocation(program, e.name);
              check("getAttribLocation:".concat(e.name));
              _decls2[e.name] = {
                name: e.name,
                type: e.type,
                size: e.size,
                location: location
              };
            });

            function assign(name, data) {
              var decl = _decls2[name] || {},
                  loc = decl.location;

              switch (decl.type) {
                case gl.FLOAT_VEC2:
                  var buffer = gl.createBuffer();
                  check("createBuffer:".concat(name));
                  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                  check("bindBuffer:".concat(name));
                  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                  check("bufferData:".concat(name));
                  gl.enableVertexAttribArray(loc);
                  check("enableVertexAttribArray:".concat(name));
                  return gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

                default:
                  log.warn("attribute '".concat(name, "' has unsupported type: ").concat(JSON.stringify(decl)));
              }
            }

            return new (
            /*#__PURE__*/
            function () {
              function GLUAttribs() {
                _classCallCheck(this, GLUAttribs);
              }

              _createClass(GLUAttribs, [{
                key: "decls",
                value: function decls() {
                  return _decls2;
                }
                /**
                 * @param values an object {name: value, ...} where value is an array.
                 * @returns {GLUAttribs} this
                 */

              }, {
                key: "set",
                value: function set(values) {
                  Object.keys(values).forEach(function (name) {
                    assign(name, values[name]);
                    check("assign-attrib:".concat(name));
                  });
                  return this;
                }
              }]);

              return GLUAttribs;
            }())();
          }
          /**
           * @param {Object} def texture definition
           * @returns {WebGLTexture}
           */

        }, {
          key: "makeTexture2D",
          value: function makeTexture2D(def) {
            var texture = gl.createTexture();
            check("createTexture");
            gl.activeTexture(gl.TEXTURE0);
            check("activeTexture");
            gl.bindTexture(gl.TEXTURE_2D, texture);
            check("bindTexture");

            var opt = underscore__WEBPACK_IMPORTED_MODULE_0__["extend"]({}, defaultPixelStore, defaultTexParams, def);

            var format = opt.format,
                type = opt.type,
                width = opt.width,
                height = opt.height,
                data = opt.data;
            defaultPixelStoreKeys.forEach(function (key) {
              gl.pixelStorei(gl[key], opt[key]);
              check("pixelStorei:".concat(key));
            });
            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, data);
            check("texImage2D");
            defaultTexParamKeys.forEach(function (key) {
              gl.texParameteri(gl.TEXTURE_2D, gl[key], opt[key]);
              check("texParameteri:".concat(key));
            });
            gl.bindTexture(gl.TEXTURE_2D, null);
            check("bindTexture");
            return texture;
          }
          /**
           * @param {WebGLTexture} texture
           * @param {Object} def texture definition
           */

        }, {
          key: "updateTexture2D",
          value: function updateTexture2D(texture, def) {
            gl.activeTexture(gl.TEXTURE0);
            check("activeTexture");
            gl.bindTexture(gl.TEXTURE_2D, texture);
            check("bindTexture");

            var opt = underscore__WEBPACK_IMPORTED_MODULE_0__["extend"]({}, defaultPixelStore, defaultTexParams, def);

            var format = opt.format,
                type = opt.type,
                width = opt.width,
                height = opt.height,
                data = opt.data;
            defaultPixelStoreKeys.forEach(function (key) {
              gl.pixelStorei(gl[key], opt[key]);
              check("pixelStorei:".concat(key));
            });
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, type, data);
            check("texSubImage2D");
            defaultTexParamKeys.forEach(function (key) {
              gl.texParameteri(gl.TEXTURE_2D, gl[key], opt[key]);
              check("texParameteri:".concat(key));
            });
            gl.bindTexture(gl.TEXTURE_2D, null);
            check("bindTexture");
            return texture;
          }
          /**
           * @param {WebGLTexture} texture
           * @param {Object} def texture definition
           * @param {Object} existing texture entry
           * @returns {boolean} true if a difference between def and existing was found and applied
           */

        }, {
          key: "updateTexture2DParams",
          value: function updateTexture2DParams(texture, def, existing) {
            var changed = false;

            for (var i = 0; i < defaultTexParamKeys.length; i++) {
              var key = defaultTexParamKeys[i];
              var defaultValue = defaultTexParams[key];
              var newValue = def[key] || defaultValue;
              var oldValue = existing[key] || defaultValue;

              if (newValue !== oldValue) {
                if (!changed) {
                  changed = true;
                  gl.activeTexture(gl.TEXTURE0);
                  check("activeTexture");
                  gl.bindTexture(gl.TEXTURE_2D, texture);
                  check("bindTexture");
                }

                gl.texParameteri(gl.TEXTURE_2D, gl[key], newValue);
                check("texParameteri:".concat(key));
              }
            }

            if (changed) {
              gl.bindTexture(gl.TEXTURE_2D, null);
              check("bindTexture");
            }

            return changed;
          }
        }, {
          key: "context",

          /** @returns {WebGLRenderingContext} */
          get: function get() {
            return gl;
          }
        }]);

        return GLUStick;
      }())();
    }
  }]);

  return GLU;
}();



/***/ }),

/***/ "./public/js/gl/header.frag":
/*!**********************************!*\
  !*** ./public/js/gl/header.frag ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nprecision highp sampler2D;\n\nconst float TAU = 6.283185307179586;\nconst float PI = 3.141592653589793;\n"

/***/ }),

/***/ "./public/js/gl/main.frag":
/*!********************************!*\
  !*** ./public/js/gl/main.frag ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform float u_Detail;\n\nvoid main() {\n    vec2 coord = invert(gl_FragCoord.xy / u_Detail);\n    vec2 st = grid(coord);\n    float v = lookup(st);\n    lowp vec4 color = colorize(v);\n    gl_FragColor = color;\n}\n"

/***/ }),

/***/ "./public/js/gl/plane.vert":
/*!*********************************!*\
  !*** ./public/js/gl/plane.vert ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nattribute vec2 a_Position;\nattribute vec2 a_TexCoord;\n\nvarying vec2 v_TexCoord;\n\nvoid main() {\n    gl_Position = vec4(a_Position, 0.0, 1.0);\n    v_TexCoord = a_TexCoord;\n}\n"

/***/ }),

/***/ "./public/js/globes.js":
/*!*****************************!*\
  !*** ./public/js/globes.js ***!
  \*****************************/
/*! exports provided: atlantis, conic_equidistant, equirectangular, orthographic, patterson, stereographic, waterman, winkel3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "azimuthal_equidistant", function() { return azimuthalEquidistant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atlantis", function() { return atlantis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conic_equidistant", function() { return conic_equidistant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equirectangular", function() { return equirectangular; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthographic", function() { return orthographic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "patterson", function() { return patterson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stereographic", function() { return stereographic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "waterman", function() { return waterman; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "winkel3", function() { return winkel3; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts */ "./public/js/consts.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./d3 */ "./public/js/d3.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math */ "./public/js/math.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./micro */ "./public/js/micro.mjs");
/* harmony import */ var _projection_orthographic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./projection/orthographic */ "./public/js/projection/orthographic.js");
/* harmony import */ var _canvas_twod__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./canvas/twod */ "./public/js/canvas/twod.js");
/**
 * globes - a set of models of the earth, each having their own kind of projection and onscreen behavior.
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }








/**
 * @returns {Array} rotation of globe to current position of the user. Aside from asking for geolocation,
 *          which user may reject, there is not much available except timezone. Better than nothing.
 */

function currentPosition() {
  var λ = Object(_math__WEBPACK_IMPORTED_MODULE_3__["floorMod"])(new Date().getTimezoneOffset() / 4, 360); // 24 hours * 60 min / 4 === 360 degrees

  return [λ, 0];
}

function ensureNumber(num, fallback) {
  return underscore__WEBPACK_IMPORTED_MODULE_1__["isFinite"](num) || num === Infinity || num === -Infinity ? num : fallback;
}
/**
 * @param bounds the projection bounds: [[x0, y0], [x1, y1]]
 * @param view the view bounds {width:, height:}
 * @returns {Object} the projection bounds clamped to the specified view.
 */


function clampedBounds(bounds, view) {
  var upperLeft = bounds[0];
  var lowerRight = bounds[1];
  var x = Math.max(Math.floor(ensureNumber(upperLeft[0], 0)), 0);
  var y = Math.max(Math.floor(ensureNumber(upperLeft[1], 0)), 0);
  var xMax = Math.min(Math.ceil(ensureNumber(lowerRight[0], view.width)), view.width - 1);
  var yMax = Math.min(Math.ceil(ensureNumber(lowerRight[1], view.height)), view.height - 1);
  return {
    x: x,
    y: y,
    xMax: xMax,
    yMax: yMax,
    width: xMax - x + 1,
    height: yMax - y + 1
  };
}

function fitProjection(proj, view) {
  var bounds = _d3__WEBPACK_IMPORTED_MODULE_2__["geoPath"]().projection(proj).bounds({
    type: "Sphere"
  });
  var hScale = (bounds[1][0] - bounds[0][0]) / proj.scale();
  var vScale = (bounds[1][1] - bounds[0][1]) / proj.scale();
  var fit = Math.min(view.width / hScale, view.height / vScale) * 0.9;
  var center = [view.width / 2, view.height / 2];
  return proj.scale(fit).translate(center);
}
/**
 * Returns a globe object with standard behavior. At least the newProjection method must be overridden to
 * be functional.
 */


function standardGlobe() {
  return {
    /**
     * This globe's current D3 projection.
     */
    projection: null,

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {Object} a new D3 projection of this globe appropriate for the specified view port.
     */
    newProjection: function newProjection(view) {
      throw new Error("method must be overridden");
    },

    /**
     * Hand-optimized projection if available, otherwise the normal d3 projection.
     */
    optimizedProjection: function optimizedProjection() {
      return this.projection;
    },

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {{x: Number, y: Number, xMax: Number, yMax: Number, width: Number, height: Number}}
     *          the bounds of the current projection clamped to the specified view.
     */
    bounds: function bounds(view) {
      return clampedBounds(_d3__WEBPACK_IMPORTED_MODULE_2__["geoPath"]().projection(this.projection).bounds({
        type: "Sphere"
      }), view);
    },

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {Number} the projection scale at which the entire globe fits within the specified view.
     */
    fit: function fit(view) {
      if (_micro__WEBPACK_IMPORTED_MODULE_4__["isEmbeddedInIFrame"]() && _micro__WEBPACK_IMPORTED_MODULE_4__["siteInstance"]() === "tara") {
        return 700; // HACK: to get things the right size in the iframe.
      }

      return this.newProjection(view).scale();
    },

    /**
     * @param view the size of the view as {width:, height:}.
     * @returns {Array} the projection transform at which the globe is centered within the specified view.
     */
    center: function center(view) {
      return [view.width / 2, view.height / 2];
    },

    /**
     * @returns {Array} the range at which this globe can be zoomed.
     */
    scaleExtent: function scaleExtent() {
      return [25, 3000];
    },

    /**
     * Returns the current orientation of this globe as a string. If the arguments are specified,
     * mutates this globe to match the specified orientation string, usually in the form "lat,lon,scale".
     *
     * @param [o] the orientation string
     * @param [view] the size of the view as {width:, height:}.
     */
    orientation: function orientation(o, view) {
      var projection = this.projection,
          rotate = projection.rotate();

      if (view) {
        var parts = underscore__WEBPACK_IMPORTED_MODULE_1__["isString"](o) ? o.split(",") : [];
        var λ = +parts[0],
            φ = +parts[1],
            scale = +parts[2];
        var extent = this.scaleExtent();
        projection.rotate(underscore__WEBPACK_IMPORTED_MODULE_1__["isFinite"](λ) && underscore__WEBPACK_IMPORTED_MODULE_1__["isFinite"](φ) ? [-λ, -φ, rotate[2]] : this.newProjection(view).rotate());
        projection.scale(underscore__WEBPACK_IMPORTED_MODULE_1__["isFinite"](scale) ? Object(_math__WEBPACK_IMPORTED_MODULE_3__["clamp"])(scale, extent[0], extent[1]) : this.fit(view));
        projection.translate(this.center(view));
        return this;
      }

      return [(-rotate[0]).toFixed(2), (-rotate[1]).toFixed(2), Math.round(projection.scale())].join(",");
    },

    /**
     * Returns an object that mutates this globe's current projection during a drag/zoom operation.
     * Each drag/zoom event invokes the move() method, and when the move is complete, the end() method
     * is invoked.
     *
     * @param startMouse starting mouse position.
     * @param startScale starting scale.
     */
    manipulator: function manipulator(startMouse, startScale) {
      var projection = this.projection;
      var sensitivity = 60 / startScale; // seems to provide a good drag scaling factor

      var rotation = [projection.rotate()[0] / sensitivity, -projection.rotate()[1] / sensitivity];
      var original = projection.precision();
      projection.precision(original * 10);
      return {
        move: function move(mouse, scale) {
          if (mouse) {
            var xd = mouse[0] - startMouse[0] + rotation[0];
            var yd = mouse[1] - startMouse[1] + rotation[1];
            projection.rotate([xd * sensitivity, -yd * sensitivity, projection.rotate()[2]]);
          }

          projection.scale(scale);
        },
        end: function end() {
          projection.precision(original);
        }
      };
    },

    /**
     * @returns {Array} the transform to apply, if any, to orient this globe to the specified coordinates.
     */
    locate: function locate(coord) {
      return null;
    },

    /**
     * Draws a polygon on the specified context of this globe's boundary.
     * @param context a Canvas element's 2d context.
     * @returns the context
     */
    defineMask: function defineMask(context) {
      _d3__WEBPACK_IMPORTED_MODULE_2__["geoPath"]().projection(this.projection).context(context)({
        type: "Sphere"
      });
      return context;
    },
    backgroundRenderer: function backgroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          context.fillStyle = "#303030";
          context.beginPath();
          path({
            type: "Sphere"
          });
          context.fill();
        }
      };
    },
    graticuleRenderer: function graticuleRenderer() {
      var graticuleMesh = _d3__WEBPACK_IMPORTED_MODULE_2__["geoGraticule"]()();
      var hemisphereMesh = _d3__WEBPACK_IMPORTED_MODULE_2__["geoGraticule"]().extentMinor([[0, 0], [0, 0]]).stepMajor([0, 90])();
      var graticule = _canvas_twod__WEBPACK_IMPORTED_MODULE_6__["makeStrokeRenderer"](graticuleMesh, {
        strokeStyle: "#505050",
        lineWidth: 1
      });
      var hemisphere = _canvas_twod__WEBPACK_IMPORTED_MODULE_6__["makeStrokeRenderer"](hemisphereMesh, {
        strokeStyle: "#808080",
        lineWidth: 1
      });
      return {
        renderTo: function renderTo(context, path) {
          graticule.renderTo(context, path);
          hemisphere.renderTo(context, path);
        }
      };
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          context.strokeStyle = "#000005";
          context.lineWidth = 4;
          context.beginPath();
          path({
            type: "Sphere"
          });
          context.stroke();
        }
      };
    }
  };
}

function newGlobe(source, view) {
  var result = underscore__WEBPACK_IMPORTED_MODULE_1__["extend"](standardGlobe(), source);

  result.projection = result.newProjection(view);
  return result;
} // ============================================================================================

// MAL
function azimuthalEquidistant(view) { return newGlobe({ newProjection: function() { return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoAzimuthalEquidistant"]().precision(0.1).rotate([0, -90]), view); 	} 	}); }

function atlantis(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoMollweide"]().rotate([30, -45, 90]).precision(0.1), view);
    }
  }, view);
}
function conic_equidistant(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoConicEquidistant"]().rotate(currentPosition()).precision(0.1), view);
    }
  }, view);
}
function equirectangular(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoEquirectangular"]().rotate(currentPosition()).precision(0.1), view);
    }
  }, view);
}
function orthographic(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoOrthographic"]().rotate(currentPosition()).precision(0.1).clipAngle(90), view);
    },
    optimizedProjection: function optimizedProjection() {
      return _projection_orthographic__WEBPACK_IMPORTED_MODULE_5__["default"].fromD3(this.projection);
    },
    backgroundRenderer: function backgroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          var proj = path.projection(),
              _proj$translate = proj.translate(),
              _proj$translate2 = _slicedToArray(_proj$translate, 2),
              x = _proj$translate2[0],
              y = _proj$translate2[1],
              scale = proj.scale();

          var gradient = context.createRadialGradient(x, y, 0, x, y, scale);
          gradient.addColorStop(0.69, "#303030");
          gradient.addColorStop(0.91, "#202020");
          gradient.addColorStop(0.96, "#000005");
          context.fillStyle = gradient;
          context.fillRect(x - scale, y - scale, scale * 2, scale * 2);
        }
      };
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          var proj = path.projection(),
              _proj$translate3 = proj.translate(),
              _proj$translate4 = _slicedToArray(_proj$translate3, 2),
              x = _proj$translate4[0],
              y = _proj$translate4[1],
              scale = proj.scale();

          context.fillStyle = "#000005";
          context.beginPath();
          context.arc(x, y, scale - 2, 0, _consts__WEBPACK_IMPORTED_MODULE_0__["τ"], true);
          context.arc(x, y, scale + 4, 0, _consts__WEBPACK_IMPORTED_MODULE_0__["τ"], true);
          context.fill("evenodd");
        }
      };
    },
    locate: function locate(coord) {
      return [-coord[0], -coord[1], this.projection.rotate()[2]];
    }
  }, view);
}
function patterson(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoPatterson"]().precision(0.1), view);
    }
  }, view);
}
function stereographic(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoStereographic"]().rotate([-43, -20]).precision(1.0).clipAngle(180 - 0.0001).clipExtent([[0, 0], [view.width, view.height]]), view);
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {// no foreground because always fullscreen
        }
      };
    }
  }, view);
}
function waterman(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoPolyhedralWaterman"]().rotate([20, 0]).precision(0.1), view);
    },
    foregroundRenderer: function foregroundRenderer() {
      return {
        renderTo: function renderTo(context, path) {
          var _context$canvas = context.canvas,
              width = _context$canvas.width,
              height = _context$canvas.height;
          context.fillStyle = context.strokeStyle = "#000005";
          context.lineWidth = 4;
          context.beginPath();
          path({
            type: "Sphere"
          });
          context.stroke();
          context.moveTo(0, 0);
          context.lineTo(width, 0);
          context.lineTo(width, height);
          context.lineTo(0, height);
          context.lineTo(0, 0);
          context.fill("evenodd");
        }
      };
    }
  }, view);
}
function winkel3(view) {
  return newGlobe({
    newProjection: function newProjection(view) {
      return fitProjection(_d3__WEBPACK_IMPORTED_MODULE_2__["geoWinkel3"]().precision(0.1), view);
    }
  }, view);
}

/***/ }),

/***/ "./public/js/grid/regular.frag":
/*!*************************************!*\
  !*** ./public/js/grid/regular.frag ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform vec2 u_Low;\nuniform vec2 u_Size;\n\nvec2 grid(in vec2 coord) {\n    vec2 tex = (coord - u_Low) / u_Size;\n    float s = tex.s;\n    float t = tex.t;\n\n    if (t < 0.0 || 1.0 < t) discard;  // lat out of bounds, so nothing to draw\n\n    return vec2(fract(s), t);  // UNDONE: fract used here only because lon is circular.\n}\n"

/***/ }),

/***/ "./public/js/grid/regular.js":
/*!***********************************!*\
  !*** ./public/js/grid/regular.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return regularGrid; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./public/js/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./public/js/math.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
 // https://en.wikipedia.org/wiki/Regular_grid




/**
 * Creates a regular geographic grid. Each axis defines the "start" value in degrees, "delta" degrees between
 * ticks, and the "size" (number of ticks from the origin, inclusive). Positive deltas move eastward/northward. This
 * example creates a full 1° x 1° grid covering the earth starting at the south pole:
 *
 *     λaxis: {start: 0, delta: 1, size: 360}    where λ in the range [0, 359]
 *     φaxis: {start: -90, delta: 1, size: 181}  where φ in the range [-90, 90]
 *
 * A grid maps from [λ, φ] coordinates to grid point indices.
 *
 * @param λaxis longitude axis
 * @param φaxis latitude axis
 * @returns {*}
 */

function regularGrid(λaxis, φaxis) {
  var nx = Math.floor(λaxis.size); // number of lon points

  var ny = Math.floor(φaxis.size); // number of lat points

  var np = nx * ny; // total number of points

  var Δλ = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](λaxis.delta); // distance between lon points

  var Δφ = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](φaxis.delta); // distance between lat points

  var λ0 = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](λaxis.start); // lon origin

  var φ0 = _micro__WEBPACK_IMPORTED_MODULE_2__["decimalize"](φaxis.start); // lat origin, expected to be on range [-90, 90]

  var λ1 = λ0 + Δλ * (nx - 1); // lon upper bound

  var φ1 = φ0 + Δφ * (ny - 1); // lat upper bound

  var λlow = (λ0 - Δλ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var λhigh = (λ1 + Δλ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var λsize = λhigh - λlow;
  var φlow = (φ0 - Δφ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var φhigh = (φ1 + Δφ / 2) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  var φsize = φhigh - φlow;
  var low = [λlow, φlow];
  var size = [λsize, φsize];
  var isCylinder = Math.floor(nx * Δλ) >= 360; // true if the grid forms a cylinder
  //function iterator() {
  //    const i = 0;
  //    return {
  //        next: function() {
  //            if (i >= np) {
  //                return {done: true};
  //            }
  //            const x = i % nx;
  //            const y = Math.floor(i / nx);
  //            const λ = λ0 + x * Δλ;
  //            const φ = φ0 + y * Δφ;
  //            return {value: [λ, φ, i++], done: false};
  //        },
  //    };
  //}

  /** @returns {{width: number, height: number}} dimensions of this grid */

  function dimensions() {
    return {
      width: nx,
      height: ny
    };
  }
  /** @returns {boolean} true if the grid fully wraps around longitudinal axis */


  function isCylindrical() {
    return isCylinder;
  }
  /**
   * @param {Function} cb the callback ƒ(λ, φ, i), where a truthy return value terminates the iteration.
   * @param {number?} start the starting grid index.
   * @returns {number} the grid index of the next iteration, or NaN if iteration is finished.
   */


  function forEach(cb, start) {
    for (var i = start || 0; i < np; i++) {
      var x = i % nx;
      var y = Math.floor(i / nx);
      var λ = λ0 + x * Δλ;
      var φ = φ0 + y * Δφ;

      if (cb(λ, φ, i)) {
        return i + 1; // Terminate iteration and return next grid index.
      }
    }

    return NaN; // Iteration is finished.
  }
  /**
   * @param {number[]} coord [λ, φ] in degrees
   * @returns {number} index of closest grid point or NaN if further than Δλ/2 or Δφ/2 from the grid boundary.
   */


  function closest(coord) {
    var λ = coord[0];
    var φ = coord[1];

    if (λ === λ && φ === φ) {
      var x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(λ - λ0, 360) / Δλ;
      var y = (φ - φ0) / Δφ;
      var rx = Math.round(x);
      var ry = Math.round(y);

      if (0 <= ry && ry < ny && 0 <= rx && (rx < nx || rx === nx && isCylinder)) {
        var i = ry * nx + rx;
        return rx === nx ? i - nx : i;
      }
    }

    return NaN;
  }
  /**
   * Identifies the four points surrounding the specified coordinates. The result is a six-element array:
   *
   *     0-3: the indices of the four points, in increasing order.
   *     4,5: the fraction that λ,φ is away from the first point, normalized to the range [0, 1].
   *
   * Example:
   * <pre>
   *          1      2           After converting λ and φ to positions on the x and y grid axes, we find the
   *         fx  x   cx          four points that enclose point [x, y]. These points are at the four
   *          | =1.4 |           corners specified by the floor and ceiling of x and y. For example, given
   *       --i00-|--i10-- fy 8   x = 1.4 and y = 8.3, the four surrounding grid points are [1, 8], [2, 8],
   *     y ___|_ .   |           [1, 9] and [2, 9]. These points have index i00, i10, i01, i11, respectively,
   *   =8.3   |      |           and result of this function is an array [i00, i10, i01, i11, 0.4, 0.3].
   *       --i01----i11-- cy 9
   *          |      |
   * </pre>
   *
   * @param {number[]} coord [λ, φ] in degrees
   * @returns {number[]} the indices of the four grid points surrounding the coordinate pair and the (x,y) fraction,
   *          or [NaN, NaN, NaN, NaN, NaN, NaN] if all points are not found.
   */


  function closest4(coord) {
    var λ = coord[0];
    var φ = coord[1];

    if (λ === λ && φ === φ) {
      var x = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(λ - λ0, 360) / Δλ;
      var y = (φ - φ0) / Δφ;
      var fx = Math.floor(x);
      var fy = Math.floor(y);
      var cx = fx + 1;
      var cy = fy + 1;
      var Δx = x - fx;
      var Δy = y - fy;

      if (0 <= fy && cy < ny && 0 <= fx && (cx < nx || cx === nx && isCylinder)) {
        var i00 = fy * nx + fx;
        var i10 = i00 + 1;
        var i01 = i00 + nx;
        var i11 = i01 + 1;

        if (cx === nx) {
          i10 -= nx;
          i11 -= nx;
        }

        return [i00, i10, i01, i11, Δx, Δy];
      }
    }

    return [NaN, NaN, NaN, NaN, NaN, NaN];
  }

  function webgl() {
    return {
      shaderSource: function shaderSource() {
        return __webpack_require__(/*! ./regular.frag */ "./public/js/grid/regular.frag");
      },
      textures: function textures() {
        return {};
      },
      uniforms: function uniforms() {
        return {
          u_Low: low,
          u_Size: size
        };
      }
    };
  }

  return {
    dimensions: dimensions,
    isCylindrical: isCylindrical,
    forEach: forEach,
    closest: closest,
    closest4: closest4,
    webgl: webgl
  };
}

/***/ }),

/***/ "./public/js/interpolate/bilinear.js":
/*!*******************************************!*\
  !*** ./public/js/interpolate/bilinear.js ***!
  \*******************************************/
/*! exports provided: scalar, vector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return scalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vector", function() { return vector; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lookup */ "./public/js/interpolate/lookup.js");
/* harmony import */ var _gl_glCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gl/glCheck */ "./public/js/gl/glCheck.js");
/*
 * bilinear: a bilinear interpolator for scalar and vector fields that also handles triangles (3 points).
 */





/**
 * @param grid a grid that supports the "closest4" function.
 * @param {Float32Array} data backing data, the same length as the grid.
 * @returns {Function} a bilinear interpolation function f([λ, φ]) -> v
 */

function scalar(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number} the bilinear interpolated value or 7e37 if none.
   */

  function bilinear(coord) {
    var indices = grid.closest4(coord);
    var i00 = indices[0];

    if (i00 === i00) {
      var i10 = indices[1];
      var i01 = indices[2];
      var i11 = indices[3];
      var x = indices[4];
      var y = indices[5];
      var rx = 1 - x;
      var ry = 1 - y;
      var v00 = data[i00];
      var v10 = data[i10];
      var v01 = data[i01];
      var v11 = data[i11];

      if (v00 < 7e37) {
        if (v10 < 7e37 && v01 < 7e37 && v11 < 7e37) {
          var a = rx * ry,
              b = x * ry,
              c = rx * y,
              d = x * y;
          return v00 * a + v10 * b + v01 * c + v11 * d; // 4 points found.
        } else if (v11 < 7e37 && v10 < 7e37 && x >= y) {
          return v10 + rx * (v00 - v10) + y * (v11 - v10); // 3 points found, triangle interpolate.
        } else if (v01 < 7e37 && v11 < 7e37 && x < y) {
          return v01 + x * (v11 - v01) + ry * (v00 - v01); // 3 points found, triangle interpolate.
        } else if (v01 < 7e37 && v10 < 7e37 && x <= ry) {
          return v00 + x * (v10 - v00) + y * (v01 - v00); // 3 points found, triangle interpolate.
        }
      } else if (v11 < 7e37 && v01 < 7e37 && v10 < 7e37 && x > ry) {
        return v11 + rx * (v01 - v11) + ry * (v10 - v11); // 3 points found, triangle interpolate.
      }
    }

    return 7e37;
  }
  /**
   * @param {GLUStick} glu
   */


  bilinear.webgl = function (glu) {
    var gl = glu.context;
    var useNative = _gl_glCheck__WEBPACK_IMPORTED_MODULE_2__["default"].floatTexLinear && !grid.isCylindrical();
    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());

    var _grid$dimensions = grid.dimensions(),
        width = _grid$dimensions.width,
        height = _grid$dimensions.height,
        textureSize = [width, height];

    return {
      shaderSource: function shaderSource() {
        return [look.scalarSource(), useNative ? look.shaderSourceTexture2D() : look.shaderSourceBilinearWrap()];
      },
      textures: function textures() {
        return {
          weather_data: look.scalarTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: useNative ? gl.LINEAR : gl.NEAREST,
            TEXTURE_MAG_FILTER: useNative ? gl.LINEAR : gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        var result = {
          u_Data: "weather_data"
        };

        if (!useNative) {
          result.u_TextureSize = textureSize;
        }

        return result;
      }
    };
  };

  return bilinear;
}
/**
 * @param grid a grid that supports the "closest4" function.
 * @param {Float32Array|number[]} data backing data in [u0, v0, u1, v1, ...] layout, double the grid size.
 * @returns {Function} a bilinear interpolation function f([λ, φ]) -> [u, v, m]
 */

function vector(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);

  function triangleInterpolateVector(x, y, u0, v0, u1, v1, u2, v2) {
    var u = u0 + x * (u2 - u0) + y * (u1 - u0);
    var v = v0 + x * (v2 - v0) + y * (v1 - v0);
    return [u, v, Math.sqrt(u * u + v * v)];
  }
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number[]} the bilinear interpolated value as a vector [u, v, m] or [7e37, 7e37, 7e37] if none.
   */


  function bilinear(coord) {
    var indices = grid.closest4(coord);
    var j00 = indices[0] * 2;

    if (j00 === j00) {
      var j10 = indices[1] * 2;
      var j01 = indices[2] * 2;
      var j11 = indices[3] * 2;
      var x = indices[4];
      var y = indices[5];
      var rx = 1 - x;
      var ry = 1 - y;
      var u00 = data[j00];
      var v00 = data[j00 + 1];
      var u10 = data[j10];
      var v10 = data[j10 + 1];
      var u01 = data[j01];
      var v01 = data[j01 + 1];
      var u11 = data[j11];
      var v11 = data[j11 + 1];

      if (v00 < 7e37) {
        if (v10 < 7e37 && v01 < 7e37 && v11 < 7e37) {
          var a = rx * ry,
              b = x * ry,
              c = rx * y,
              d = x * y;
          var u = u00 * a + u10 * b + u01 * c + u11 * d;
          var v = v00 * a + v10 * b + v01 * c + v11 * d;
          return [u, v, Math.sqrt(u * u + v * v)]; // 4 points found.
        } else if (v11 < 7e37 && v10 < 7e37 && x >= y) {
          return triangleInterpolateVector(rx, y, u10, v10, u11, v11, u00, v00);
        } else if (v01 < 7e37 && v11 < 7e37 && x < y) {
          return triangleInterpolateVector(x, ry, u01, v01, u00, v00, u11, v11);
        } else if (v01 < 7e37 && v10 < 7e37 && x <= ry) {
          return triangleInterpolateVector(x, y, u00, v00, u01, v01, u10, v10);
        }
      } else if (v11 < 7e37 && v01 < 7e37 && v10 < 7e37 && x > ry) {
        return triangleInterpolateVector(rx, ry, u11, v11, u10, v10, u01, v01);
      }
    }

    return [7e37, 7e37, 7e37];
  }
  /**
   * @param {GLUStick} glu
   */


  bilinear.webgl = function (glu) {
    var gl = glu.context;
    var useNative = _gl_glCheck__WEBPACK_IMPORTED_MODULE_2__["default"].floatTexLinear && !grid.isCylindrical();
    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());

    var _grid$dimensions2 = grid.dimensions(),
        width = _grid$dimensions2.width,
        height = _grid$dimensions2.height,
        textureSize = [width, height];

    return {
      shaderSource: function shaderSource() {
        return [look.vectorSource(), useNative ? look.shaderSourceTexture2D() : look.shaderSourceBilinearWrap()];
      },
      textures: function textures() {
        return {
          weather_data: look.vectorTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: useNative ? gl.LINEAR : gl.NEAREST,
            TEXTURE_MAG_FILTER: useNative ? gl.LINEAR : gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        var result = {
          u_Data: "weather_data"
        };

        if (!useNative) {
          result.u_TextureSize = textureSize;
        }

        return result;
      }
    };
  };

  return bilinear;
}

/***/ }),

/***/ "./public/js/interpolate/bilinearWrap.frag":
/*!*************************************************!*\
  !*** ./public/js/interpolate/bilinearWrap.frag ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D u_Data;\nuniform vec2 u_TextureSize;\n\nfloat lookup(in vec2 st) {\n    // adapted from http://www.iquilezles.org/www/articles/hwinterpolation/hwinterpolation.htm\n    vec2 uv = st * u_TextureSize - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec2 ruv = 1.0 - fuv;\n\n    // UNDONE: fract usable below only for cylindrical grids\n    vec4 a = texture2D(u_Data, fract((iuv + vec2(0.5, 0.5)) / u_TextureSize));  // LL\n    vec4 b = texture2D(u_Data, fract((iuv + vec2(1.5, 0.5)) / u_TextureSize));  // LR\n    vec4 c = texture2D(u_Data, fract((iuv + vec2(0.5, 1.5)) / u_TextureSize));  // UL\n    vec4 d = texture2D(u_Data, fract((iuv + vec2(1.5, 1.5)) / u_TextureSize));  // UR\n    vec4 h;\n\n    int tag = int(dot(step(7e37, vec4(a.x, b.x, c.x, d.x)), vec4(1.0, 2.0, 4.0, 8.0)));\n    if (tag == 0) {\n        // a b c d\n        h = mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n    } else if (tag == 1 && ruv.y < fuv.x) {\n        // d b c\n        h = d + ruv.x * (c - d) + ruv.y * (b - d);\n    } else if (tag == 2 && fuv.x < fuv.y) {\n        // c a d\n        h = c + fuv.x * (d - c) + ruv.y * (a - c);\n    } else if (tag == 4 && fuv.x >= fuv.y) {\n        // b a d\n        h = b + ruv.x * (a - b) + fuv.y * (d - b);\n    } else if (tag == 8 && fuv.x <= ruv.y) {\n        // a b c\n        h = a + fuv.x * (b - a) + fuv.y * (c - a);\n    } else {\n        // not enough points to interpolate\n        h = vec4(7e37);\n    }\n\n    return scalarize(h);\n}\n"

/***/ }),

/***/ "./public/js/interpolate/lookup.js":
/*!*****************************************!*\
  !*** ./public/js/interpolate/lookup.js ***!
  \*****************************************/
/*! exports provided: lookup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookup", function() { return lookup; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_0__);



/**
 *
 * @param {GLUStick} glu
 * @param dims
 * @returns {*}
 */

function lookup(glu, dims) {
  var gl = glu.context;
  var width = dims.width,
      height = dims.height;
  return {
    shaderSourceTexture2D: function shaderSourceTexture2D() {
      return __webpack_require__(/*! ./texture2D.frag */ "./public/js/interpolate/texture2D.frag");
    },
    shaderSourceBilinearWrap: function shaderSourceBilinearWrap() {
      return __webpack_require__(/*! ./bilinearWrap.frag */ "./public/js/interpolate/bilinearWrap.frag");
    },
    scalarSource: function scalarSource() {
      return __webpack_require__(/*! ./scalar.frag */ "./public/js/interpolate/scalar.frag");
    },
    vectorSource: function vectorSource() {
      return __webpack_require__(/*! ./vector.frag */ "./public/js/interpolate/vector.frag");
    },
    scalarTexture: function scalarTexture(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return underscore__WEBPACK_IMPORTED_MODULE_0__["extend"]({
        format: gl.LUMINANCE,
        type: gl.FLOAT,
        width: width,
        height: height,
        data: data
      }, options);
    },
    vectorTexture: function vectorTexture(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return underscore__WEBPACK_IMPORTED_MODULE_0__["extend"]({
        format: gl.LUMINANCE_ALPHA,
        type: gl.FLOAT,
        width: width,
        height: height,
        data: data
      }, options);
    }
  };
}
;

/***/ }),

/***/ "./public/js/interpolate/nearest.js":
/*!******************************************!*\
  !*** ./public/js/interpolate/nearest.js ***!
  \******************************************/
/*! exports provided: scalar, vector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalar", function() { return scalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vector", function() { return vector; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/* harmony import */ var _lookup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lookup */ "./public/js/interpolate/lookup.js");
/*
 * nearest: a nearest-neighbor interpolator for scalar and vector fields.
 */




/**
 * @param grid a grid that supports the "closest" function.
 * @param {Float32Array} data backing data, the same length as the grid.
 * @returns {Function} a nearest neighbor interpolation function f([λ, φ]) -> v
 */

function scalar(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number} the nearest neighbor value or 7e37 if none.
   */

  function nearest(coord) {
    var i = grid.closest(coord);
    return i === i ? data[i] : 7e37;
  }
  /**
   * @param {GLUStick} glu
   */


  nearest.webgl = function (glu) {
    var gl = glu.context;
    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());
    return {
      shaderSource: function shaderSource() {
        return [look.scalarSource(), look.shaderSourceTexture2D()];
      },
      textures: function textures() {
        return {
          weather_data: look.scalarTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: gl.NEAREST,
            TEXTURE_MAG_FILTER: gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        return {
          u_Data: "weather_data"
        };
      }
    };
  };

  return nearest;
}
/**
 * @param grid a grid that supports the "closest" function.
 * @param {Float32Array|number[]} data backing data in [u0, v0, u1, v1, ...] layout, double the grid size.
 * @returns {Function} a nearest neighbor interpolation function f([λ, φ]) -> [u, v, m]
 */

function vector(grid, data) {
  var hash = _micro__WEBPACK_IMPORTED_MODULE_0__["arrayHashCode"](data, 1000);
  /**
   * @param {number[]} coord [λ, φ] in degrees.
   * @returns {number[]} the nearest neighbor value as a vector [u, v, m] or [7e37, 7e37, 7e37] if none.
   */

  function nearest(coord) {
    var j = grid.closest(coord) * 2;

    if (j === j) {
      var u = data[j],
          v = data[j + 1];

      if (u < 7e37 && v < 7e37) {
        return [u, v, Math.sqrt(u * u + v * v)];
      }
    }

    return [7e37, 7e37, 7e37];
  }
  /**
   * @param {GLUStick} glu
   */


  nearest.webgl = function (glu) {
    var gl = glu.context;
    var look = Object(_lookup__WEBPACK_IMPORTED_MODULE_1__["lookup"])(glu, grid.dimensions());
    return {
      shaderSource: function shaderSource() {
        return [look.vectorSource(), look.shaderSourceTexture2D()];
      },
      textures: function textures() {
        return {
          weather_data: look.vectorTexture(data, {
            hash: hash,
            TEXTURE_MIN_FILTER: gl.NEAREST,
            TEXTURE_MAG_FILTER: gl.NEAREST
          })
        };
      },
      uniforms: function uniforms() {
        return {
          u_Data: "weather_data"
        };
      }
    };
  };

  return nearest;
}

/***/ }),

/***/ "./public/js/interpolate/scalar.frag":
/*!*******************************************!*\
  !*** ./public/js/interpolate/scalar.frag ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat scalarize(in vec4 h) {\n    return h.x;\n}\n"

/***/ }),

/***/ "./public/js/interpolate/texture2D.frag":
/*!**********************************************!*\
  !*** ./public/js/interpolate/texture2D.frag ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform sampler2D u_Data;\n\nfloat lookup(in vec2 st) {\n    vec4 h = texture2D(u_Data, st);\n    return scalarize(h);\n}\n"

/***/ }),

/***/ "./public/js/interpolate/vector.frag":
/*!*******************************************!*\
  !*** ./public/js/interpolate/vector.frag ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat scalarize(in vec4 h) {\n    return length(h.xw);  // UNDONE: sqrt(7e37^2) ok?\n}\n"

/***/ }),

/***/ "./public/js/keyboard.js":
/*!*******************************!*\
  !*** ./public/js/keyboard.js ***!
  \*******************************/
/*! exports provided: key */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "key", function() { return key; });

/**
 * @param {string} type event type
 * @param {string} key the key property
 * @param {number} which the browser-specific numeric key code
 * @param {string} str the string representation of the numeric key code
 * @returns {string} the normalized 'key' value.
 */

function normalize(type, key, which, str) {
  if (key) {
    switch (key) {
      case "Esc":
        return "Escape";
    }

    return key; // Use the key property if it exists.
  }

  switch (which) {
    case 27:
      return "Escape";
  }

  if (type === "keypress" && str) {
    return str; // The string representation is acceptable for keypress events. For keyup and keydown, it is not.
  }

  return "NYI";
}
/**
 * @param {KeyboardEvent} event the keyboard keyup, keypress, or keydown event.
 * @return {string} the 'key' property of the event (or equivalent if not yet supported by the browser), or "NYI"
 *         if I haven't bothered to investigate cross browser behavior for the specific key.
 */


function key(event) {
  var type = event.type,
      key = event.key,
      which = +event.which,
      str = String.fromCharCode(which); //console.log("type", type, "key", key, "which", which, "str", str, " => ", normalize(type, key, which, str));

  return normalize(type, key, which, str);
}

/***/ }),

/***/ "./public/js/lang.js":
/*!***************************!*\
  !*** ./public/js/lang.js ***!
  \***************************/
/*! exports provided: preferred, parse, match, best */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "preferred", function() { return preferred; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "match", function() { return match; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "best", function() { return best; });


function preferred(navigator) {
  return navigator.languages || [navigator.language || navigator.userLanguage || "en"];
}
/**
 * Parses an IETF language tag into pieces.
 *
 * {language: "zh", script: "Hans", region: "CN"}
 * {language: "en", script: "", region: "US"}
 * {language: "en", script: "", region: ""}
 * {language: "", script: "", region: ""}
 *
 * @param {string} tag
 */

function parse(tag) {
  var result = {
    language: "",
    script: "",
    region: ""
  },
      parts = (tag || "").toLowerCase().split("-");

  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];

    if (part.length === 1) {
      // stop parsing when we hit an extension
      break;
    }

    if (i === 0) {
      result.language = part;
    } else if (/^[a-z]{4}$/.test(part)) {
      result.script = part.substring(0, 1).toUpperCase() + part.substring(1);
    } else if (/^([a-z]{2}|\d{3})$/.test(part)) {
      result.region = part.toUpperCase();
    }
  }

  return result;
}
/**
 * Returns the most appropriate match for the specified language tag, or "" if none can be found.
 *
 * @param struct a parsed IETF language tag
 * @returns {string}
 */

function match(struct) {
  // $LANG$
  switch (struct.language) {
    case "en":
      return "en";

    case "cs":
      return "cs";

    case "fr":
      return "fr";

    case "ja":
      return "ja";

    case "pt":
      return "pt";

    case "ru":
      return "ru";

    case "zh":
      switch (struct.script) {
        case "Hant":
          return "zh-TW";

        case "Hans":
          return "zh-CN";
      }

      switch (struct.region) {
        case "HK":
        case "MO":
        case "TW":
          return "zh-TW";

        case "SG":
        case "CN":
          return "zh-CN";
      }

  }

  return "";
}
function best(navigator) {
  var preference = preferred(navigator);

  for (var i = 0; i < preference.length; i++) {
    var parsed = parse(preference[i]);
    var matched = match(parsed);
    if (matched) return matched;
  }

  return "";
}

/***/ }),

/***/ "./public/js/log.js":
/*!**************************!*\
  !*** ./public/js/log.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {
/**
 * @param {Object?} console the object to handle log operations [default: global console]
 * @returns {{debug: *, info: *, warn: *, error: *, time: *, timeEnd: *}} a log object
 */

/* harmony default export */ __webpack_exports__["default"] = (function (console) {
  function extract(ref, f) {
    return typeof f === "function" ? f.bind(ref) : function () {};
  }

  console = console || global.console || {};
  return {
    debug: extract(console, console.log),
    info: extract(console, console.info),
    warn: extract(console, console.warn),
    error: extract(console, console.error),
    time: extract(console, console.time),
    timeEnd: extract(console, console.timeEnd)
  };
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./public/js/main.js":
/*!***************************!*\
  !*** ./public/js/main.js ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _polyfills__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfills */ "./public/js/polyfills.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./d3 */ "./public/js/d3.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./micro */ "./public/js/micro.mjs");
/* harmony import */ var _blacklist__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./blacklist */ "./public/js/blacklist.js");
/* harmony import */ var _earth__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./earth */ "./public/js/earth.js");
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./log */ "./public/js/log.js");








 // import bridge from "./bridge";
// work-around for iOS 10 bug: https://github.com/metafizzy/flickity/issues/457

window.addEventListener("touchmove", function () {});
!function () {
  //require("./clock").calibration({server: "/"}); /*calibration({fixed: "2015-11-24T00:00Z"});*/
  global.earth = _earth__WEBPACK_IMPORTED_MODULE_5__["default"];

  global.main = function (bridge) {
    bridge = bridge || {};
    var log = Object(_log__WEBPACK_IMPORTED_MODULE_6__["default"])(bridge.console);
    var app = {
      log: log,
      bridge: bridge
    };

    if (_micro__WEBPACK_IMPORTED_MODULE_3__["isDevMode"]()) {
      log.debug("dev mode enabled");
    }

    underscore__WEBPACK_IMPORTED_MODULE_1__["defer"](_earth__WEBPACK_IMPORTED_MODULE_5__["default"], app); // defer all side effects

  };

  if (_micro__WEBPACK_IMPORTED_MODULE_3__["isEmbeddedInIFrame"]() && underscore__WEBPACK_IMPORTED_MODULE_1__["isFunction"](window.ga)) {
    window.ga("send", "event", "iframe", document.referrer.split("/")[2] || document.referrer);
  }

  if (_micro__WEBPACK_IMPORTED_MODULE_3__["isEmbeddedInIFrame"]() && _blacklist__WEBPACK_IMPORTED_MODULE_4__["contains"](document.referrer)) {
    return _blacklist__WEBPACK_IMPORTED_MODULE_4__["deny"]();
  } else if (_micro__WEBPACK_IMPORTED_MODULE_3__["isAppMode"]()) {
    _d3__WEBPACK_IMPORTED_MODULE_2__["select"]("#details").classed("invisible", true);
  } else {
    // global.main(bridge);
    global.main();
  }
}();
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./public/js/math.mjs":
/*!****************************!*\
  !*** ./public/js/math.mjs ***!
  \****************************/
/*! exports provided: clamp, floorMod, rint, distance, proportion, spread */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorMod", function() { return floorMod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rint", function() { return rint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proportion", function() { return proportion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "spread", function() { return spread; });
/**
 * @param {number} x
 * @param {number} low
 * @param {number} high
 * @returns {number} the value x clamped to the range [low, high].
 */
function clamp(x, low, high) {
  return Math.max(low, Math.min(x, high));
}
/**
 * @param {number} a
 * @param {number} n
 * @returns {number} remainder of floored division, i.e., floor(a / n). Useful for consistent modulo of negative
 *          numbers. See http://en.wikipedia.org/wiki/Modulo_operation.
 */

function floorMod(a, n) {
  var f = a - n * Math.floor(a / n); // hack: when a is within an ulp of n, f can be equal to n (because the subtraction has no effect). But the
  // result should be in the range [0, n), so check for this case. Example: floorMod(-1e-16, 10)

  return f === n ? 0 : f;
}
/**
 * Round to closest whole number using banker's rounding. From Java's Math.rint method.
 * @param {number} v
 * @returns {number} the value rounded half even
 */

function rint(v) {
  var x = Math.abs(v);

  if (x < TWOP52) {
    x += TWOP52;
    x -= TWOP52;
  }

  return Math.sign(v) * x;
}
var TWOP52 = Math.pow(2, 52);
/**
 * @param {number[]} a
 * @param {number[]} b
 * @returns {number} cartesian distance between two points [x, y]
 */

function distance(a, b) {
  var Δx = b[0] - a[0];
  var Δy = b[1] - a[1];
  return Math.sqrt(Δx * Δx + Δy * Δy);
}
/**
 * @param {number} x
 * @param {number[]} range the range [low, high]
 * @returns {number} the value x after rescaling to the unit scale
 */

function proportion(x, range) {
  var low = range[0];
  var high = range[1];
  return (x - low) / (high - low);
}
/**
 * @param {number} p a value on the unit scale
 * @param {number[]} range the range [low, high]
 * @returns {number} the unit scale value p rescaled to the range [low, high]
 */

function spread(p, range) {
  var low = range[0];
  var high = range[1];
  return p * (high - low) + low;
}

/***/ }),

/***/ "./public/js/micro.mjs":
/*!*****************************!*\
  !*** ./public/js/micro.mjs ***!
  \*****************************/
/*! exports provided: isDevMode, siteLangCode, siteInstance, isTruthy, isValue, coalesce, decimalize, scalarize, capitalize, isFF, isMobile, isEmbeddedInIFrame, bindup, view, removeChildren, newClickEvent, clearContext, clearCanvas, windIntensityColorScale, formatCoordinates, formatScalar, formatVector, loadJson, loadJsonOnce, loadEpak, distortion, newAgent, parse, buildConfiguration, parseQueryString, dateToConfig, isAppMode, isKioskMode, isFixedMode, arraysEq, merge, toArray, arrayHashCode, isArrayLike, omit, flatten */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDevMode", function() { return isDevMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteLangCode", function() { return siteLangCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "siteInstance", function() { return siteInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTruthy", function() { return isTruthy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValue", function() { return isValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "coalesce", function() { return coalesce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decimalize", function() { return decimalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalarize", function() { return scalarize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFF", function() { return isFF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmbeddedInIFrame", function() { return isEmbeddedInIFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindup", function() { return bindup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "view", function() { return view; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeChildren", function() { return removeChildren; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newClickEvent", function() { return newClickEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearContext", function() { return clearContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearCanvas", function() { return clearCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "windIntensityColorScale", function() { return windIntensityColorScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatCoordinates", function() { return formatCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatScalar", function() { return formatScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatVector", function() { return formatVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadJson", function() { return loadJson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadJsonOnce", function() { return loadJsonOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadEpak", function() { return loadEpak; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distortion", function() { return distortion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newAgent", function() { return newAgent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildConfiguration", function() { return buildConfiguration; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseQueryString", function() { return parseQueryString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dateToConfig", function() { return dateToConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAppMode", function() { return isAppMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isKioskMode", function() { return isKioskMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFixedMode", function() { return isFixedMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arraysEq", function() { return arraysEq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayHashCode", function() { return arrayHashCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayLike", function() { return isArrayLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "omit", function() { return omit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consts */ "./public/js/consts.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./d3 */ "./public/js/d3.mjs");
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! backbone */ "./node_modules/backbone/backbone.js");
/* harmony import */ var _decoder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./decoder */ "./public/js/decoder.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utc */ "./public/js/utc.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./math */ "./public/js/math.mjs");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * micro - a grab bag of somewhat useful utility functions and other stuff that requires unit testing
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */







var DEFAULT_CONFIG = "current/wind/surface/level/orthographic";

function topologyFile() {
  return isMobile() ? "/data/earth-topo-mobile.json?v3" : "/data/earth-topo.json?v3";
}

function isDevMode() {
  return +window.location.port === 8081;
}
function siteLangCode() {
  return _d3__WEBPACK_IMPORTED_MODULE_2__["select"]("html").attr("lang") || "en";
}
function siteInstance() {
  // UNDONE: this may no longer be needed because Cloudflare responds with "consty: Origin" CORS header set.
  var match = window.location.hostname.match(/(.*)\.nullschool\.net$/) || [],
      name = match[1] || "earth";
  return name === "earth" ? "" : name;
}
/**
 * @returns {boolean} true if the specified value is truthy.
 */

function isTruthy(x) {
  return !!x;
}
/**
 * @returns {boolean} true if the specified value is not null and not undefined.
 */

function isValue(x) {
  return x !== null && x !== undefined;
}
/**
 * @returns {Object} the first argument if not null and not undefined, otherwise the second argument.
 */

function coalesce(a, b) {
  return isValue(a) ? a : b;
}
/**
 * Converts the argument to a number, including special cases for fractions:
 *     0.25  -> 0.25
 *     "1/4" -> 0.25
 *     [1,4] -> 0.25
 *     ".25" -> 0.25
 *
 * @param x any object. When an array, then interpreted as the fraction: a[0] / a[1]. When a string containing
 *        a slash, the value is first converted to an array by splitting on "/".
 * @returns {number} the specified argument converted to a number.
 */

function decimalize(x) {
  if (underscore__WEBPACK_IMPORTED_MODULE_1__.isString(x) && x.indexOf("/") >= 0) {
    x = x.split("/");
  }

  return isArrayLike(x) && x.length === 2 ? x[0] / x[1] : +x;
}
/**
 * @param {Array|*} x the value to convert to a scalar.
 * @returns {*} the magnitude if x is a vector (i.e., x[2]), otherwise x itself.
 */

function scalarize(x) {
  return isArrayLike(x) ? x[2] : x;
}
/**
 * @returns {string} the specified string with the first letter capitalized.
 */

function capitalize(s) {
  return s.length === 0 ? s : s.charAt(0).toUpperCase() + s.substr(1);
}
/**
 * @returns {boolean} true if agent is probably firefox. Don't really care if this is accurate.
 */

function isFF() {
  return /firefox/i.test(navigator.userAgent);
}
/**
 * @returns {boolean} true if agent is probably a mobile device. Don't really care if this is accurate.
 */

function isMobile() {
  return /android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i.test(navigator.userAgent);
}
function isEmbeddedInIFrame() {
  return self != top;
}
/**
 * Finds the method having the specified name on the object thisArg, and returns it as a function bound
 * to thisArg. If no method can be found, or thisArg is not a value, then returns null.
 *
 * @param thisArg the object
 * @param methodName the method name to bind to the object
 * @returns {Function} the method bound to the object, if it exists.
 */

function bindup(thisArg, methodName) {
  return isValue(thisArg) && thisArg[methodName] ? thisArg[methodName].bind(thisArg) : null;
}
/**
 * @returns {{width: number, height: number}} an object that describes the size of the browser's current view.
 */

function view() {
  var w = window;
  var d = document && document.documentElement;
  var b = document && document.getElementsByTagName("body")[0];
  var x = w.innerWidth || d.clientWidth || b.clientWidth;
  var y = w.innerHeight || d.clientHeight || b.clientHeight;
  return {
    width: Math.ceil(x),
    height: Math.ceil(y)
  };
}
/**
 * Removes all children of the specified DOM element.
 */

function removeChildren(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
}
/**
 * @returns {*} a new mouse click event instance
 */

function newClickEvent() {
  try {
    return new MouseEvent("click", {
      view: window,
      bubbles: true,
      cancelable: true
    });
  } catch (e) {
    // Chrome mobile supports only the old fashioned, deprecated way of constructing events. :(
    var event = document.createEvent("MouseEvents");
    event.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
    return event;
  }
}
/** @param {CanvasRenderingContext2D} context clears the 2d context. */

function clearContext(context) {
  var canvas = context.canvas;
  context.clearRect(0, 0, canvas.width, canvas.height);
}
/** @param {HTMLCanvasElement} canvas clears the 2d context. */

function clearCanvas(canvas) {
  var context = canvas.getContext("2d");
  context.clearRect(0, 0, canvas.width, canvas.height);
}
/**
 * @returns {Array} of wind colors and a method, indexFor, that maps wind magnitude to an index on the color scale.
 */

function windIntensityColorScale(step, maxWind) {
  var result = [];

  for (var j = 85; j <= 255; j += step) {
    result.push("rgb(".concat(j, ",").concat(j, ",").concat(j, ")"));
  }

  result.indexFor = function (m) {
    // map wind speed to a style
    return Math.floor(Math.min(m, maxWind) / maxWind * (result.length - 1));
  };

  return result;
}
/**
 * Returns a human readable string for the provided coordinates.
 */

function formatCoordinates(λ, φ) {
  return Math.abs(φ).toFixed(2) + "° " + (φ >= 0 ? "N" : "S") + ", " + Math.abs(λ).toFixed(2) + "° " + (λ >= 0 ? "E" : "W");
}
/**
 * Returns a human readable string for the provided scalar in the given units.
 */

function formatScalar(value, units) {
  return units.conversion(value).toFixed(units.precision);
}
/**
 * Returns a human readable string for the provided rectangular wind vector in the given units.
 * See http://mst.nerc.ac.uk/wind_vect_convs.html.
 */

function formatVector(wind, units) {
  var d = Math.atan2(-wind[0], -wind[1]) / _consts__WEBPACK_IMPORTED_MODULE_0__["τ"] * 360; // calculate into-the-wind cardinal degrees

  var wd = Math.round((d + 360) % 360 / 5) * 5; // shift [-180, 180] to [0, 360], and round to nearest 5.

  return wd.toFixed(0) + "° @ " + formatScalar(wind[2], units);
}
/**
 * @param {string} resource
 * @param {Function} resolve
 * @param {Function} reject
 * @param {ProgressEvent} err
 * @param {*} result
 * @returns {*}
 */

function xhrResolver(resource, resolve, reject, err, result) {
  var _ref = err || {},
      target = _ref.target;

  return target ? target.status ? reject({
    status: target.status,
    message: target.statusText,
    resource: resource,
    error: err
  }) : reject({
    status: -1,
    message: "Cannot load ".concat(resource, ": ").concat(err),
    resource: resource,
    error: err
  }) : resolve(result);
}
/**
 * Returns a promise for a JSON resource (URL) fetched via XHR. If the load fails, the promise rejects with an
 * object describing the reason: {status: http-status-code, message: http-status-text, resource:}.
 * @returns {Promise}
 */


function loadJson(resource) {
  return new Promise(function (resolve, reject) {
    _d3__WEBPACK_IMPORTED_MODULE_2__["json"](resource, function (err, result) {
      return xhrResolver(resource, resolve, reject, err, result);
    });
  });
}
/**
 * Same as loadJson but returns a singleton promise for each URL.
 */

var loadJsonOnce = underscore__WEBPACK_IMPORTED_MODULE_1__.memoize(loadJson);
/**
 * Parses headers string into a map.
 *
 * "Content-Type: Foo\r\nContent-Length: 1234"  ->  {"content-type": ["foo"], "content-length": ["1234"]}
 *
 * @param {string} s unparsed headers string.
 * @returns {Object} map of header name to array of values (usually just one element, but possibly more).
 */

function parseHeaders(s) {
  var result = Object.create(null);
  (s || "").split("\n").forEach(function (line) {
    var i = line.indexOf(":");
    if (i < 0) return;
    var key = line.substr(0, i).trim().toLowerCase();
    var value = line.substr(i + 1).trim();
    result[key] = (result[key] || []).concat(value);
  });
  return result;
}
/**
 * @param {ProgressEvent} e
 * @returns {number}
 */


function computeProgress(e) {
  var total = e.total;

  if (!e.lengthComputable) {
    var headers = parseHeaders(e.target.getAllResponseHeaders());
    total = (headers["x-amz-meta-uncompressed-size"] || [])[0];
  }

  return total ? Object(_math__WEBPACK_IMPORTED_MODULE_6__["clamp"])(e.loaded / total, 0, 1) : NaN;
}
/**
 * Returns a promise for an EPAK resource (URL) fetched via XHR. If the load fails, the promise rejects
 * with an object describing the reason: {status: http-status-code, message: http-status-text, resource:}.
 * @returns {Promise}
 */


function loadEpak(resource) {
  return new Promise(function (resolve, reject) {
    _d3__WEBPACK_IMPORTED_MODULE_2__["request"](resource).responseType("arraybuffer").response(function (req) {
      return _decoder__WEBPACK_IMPORTED_MODULE_4__["decodeEpak"](req.response);
    }) // UNDONE: promise swallows decoding exceptions
    // .on("progress", /** @type {ProgressEvent} */ e => {
    //     const pct = computeProgress(e);
    //     if (pct) {
    //         console.log(resource, Math.round(pct * 100));
    //     } else {
    //         console.log(resource, e.loaded);
    //     }
    // })
    .get(function (err, res) {
      return xhrResolver(resource, resolve, reject, err, res);
    });
  });
}
/**
 * Returns the distortion introduced by the specified projection at the given point.
 *
 * This method uses finite difference estimates to calculate warping by adding a very small amount (h) to
 * both the longitude and latitude to create two lines. These lines are then projected to pixel space, where
 * they become diagonals of triangles that represent how much the projection warps longitude and latitude at
 * that location.
 *
 * <pre>
 *        (λ, φ+h)                  (xλ, yλ)
 *           .                         .
 *           |               ==>        \
 *           |                           \   __. (xφ, yφ)
 *    (λ, φ) .____. (λ+h, φ)       (x, y) .--
 * </pre>
 *
 * See:
 *     Map Projections: A Working Manual, Snyder, John P: pubs.er.usgs.gov/publication/pp1395
 *     gis.stackexchange.com/questions/5068/how-to-create-an-accurate-tissot-indicatrix
 *     www.jasondavies.com/maps/tissot
 *
 * @returns {Array} array of scaled derivatives [dx/dλ, dy/dλ, dx/dφ, dy/dφ]
 */

function distortion(projection, λ, φ, x, y) {
  var hλ = λ < 0 ? H : -H;
  var hφ = φ < 0 ? H : -H;
  var pλ = projection([λ + hλ, φ]);
  var pφ = projection([λ, φ + hφ]); // Meridian scale factor (see Snyder, equation 4-3), where R = 1. This handles issue where length of 1° λ
  // changes depending on φ. Without this, there is a pinching effect at the poles.

  var k = Math.cos(φ * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"]);
  var hλk = hλ * k;
  return [(pλ[0] - x) / hλk, // dx/dλ
  (pλ[1] - y) / hλk, // dy/dλ
  (pφ[0] - x) / hφ, // dx/dφ
  (pφ[1] - y) / hφ // dy/dφ
  ];
}
var H = 0.0000360; // 0.0000360°φ ~= 4m

/**
 * Returns a new agent. An agent executes tasks and stores the result of the most recently completed task.
 *
 * A task is a value or promise, or a function that returns a value or promise. After submitting a task to
 * an agent using the submit() method, the task is evaluated and its result becomes the agent's value,
 * replacing the previous value. If a task is submitted to an agent while an earlier task is still in
 * progress, the earlier task is cancelled and its result ignored. Evaluation of a task may even be skipped
 * entirely if cancellation occurs early enough.
 *
 * Agents are Backbone.js Event emitters. When a submitted task is accepted for invocation by an agent, a
 * "submit" event is emitted. This event has the agent as its sole argument. When a task finishes and
 * the agent's value changes, an "update" event is emitted, providing (value, agent) as arguments. If a task
 * fails by either throwing an exception or rejecting a promise, a "reject" event having arguments (err, agent)
 * is emitted. If an event handler throws an error, a "fail" event having arguments (err, agent) is emitted.
 *
 * The current task can be cancelled by invoking the agent.cancel() method, and the cancel status is available
 * as the Boolean agent.cancel.requested key. Within the task callback, the "this" context is set to the agent,
 * so a task can know to abort execution by checking the this.cancel.requested key. Similarly, a task can cancel
 * itself by invoking this.cancel().
 *
 * Example pseudocode:
 * <pre>
 *     const agent = newAgent();
 *     agent.on("update", function(value) {
 *         console.log("task completed: " + value);  // same as agent.value()
 *     });
 *
 *     function someLongAsynchronousProcess(x) {  // x === "abc"
 *         return new Promise(...);
 *     }
 *
 *     agent.submit(someLongAsynchronousProcess, "abc");
 * </pre>
 *
 * @param {string} [name]
 * @param {*} [initial] initial agent value
 * @returns {Object}
 */

function newAgent(name, initial) {
  /**
   * @returns {Function} a cancel function for a task.
   */
  function cancelFactory() {
    return function cancel() {
      cancel.requested = true;
      return agent;
    };
  }
  /**
   * Invokes the specified task.
   * @param cancel the task's cancel function.
   * @param taskAndArguments the [task-function-or-value, arg0, arg1, ...] array.
   */


  function runTask(cancel, taskAndArguments) {
    var task;

    function run(args) {
      return cancel.requested ? null : underscore__WEBPACK_IMPORTED_MODULE_1__.isFunction(task) ? task.apply(agent, args) : task;
    }

    function accept(result) {
      if (!cancel.requested) {
        _value = result;
        agent.trigger("update", result, agent);
      }
    }

    function reject(err) {
      if (!cancel.requested) {
        // ANNOYANCE: when cancelled, this task's error is silently suppressed
        agent.trigger("reject", err, agent);
      }
    }

    function fail(err) {
      agent.trigger("fail", err, agent);
    }

    try {
      // When all arguments are resolved, invoke the task then either accept or reject the result.
      task = taskAndArguments[0];
      Promise.all(underscore__WEBPACK_IMPORTED_MODULE_1__.rest(taskAndArguments)).then(run).then(accept, reject).catch(fail);
      agent.trigger("submit", agent);
    } catch (err) {
      fail(err);
    }
  }

  var _value = initial;

  var runTask_debounced = underscore__WEBPACK_IMPORTED_MODULE_1__.debounce(runTask, 0); // ignore multiple simultaneous submissions--reduces noise


  var agent = {
    /**
     * @returns {Object} this agent's current value.
     */
    value: function value() {
      return _value;
    },

    /**
     * Cancels this agent's most recently submitted task.
     */
    cancel: cancelFactory(),

    /**
     * Submit a new task and arguments to invoke the task with. The task may return a promise for
     * asynchronous tasks, and all arguments may be either values or promises. The previously submitted
     * task, if any, is immediately cancelled.
     * @returns {agent} the agent.
     */
    submit: function submit(task, arg0, arg1, and_so_on) {
      // immediately cancel the previous task
      this.cancel(); // schedule the new task and update the agent with its associated cancel function

      runTask_debounced(this.cancel = cancelFactory(), arguments);
      return this;
    },
    toString: function toString() {
      return name;
    }
  };
  return underscore__WEBPACK_IMPORTED_MODULE_1__.extend(agent, backbone__WEBPACK_IMPORTED_MODULE_3__.Events);
}
/**
 * Parses a URL hash fragment:
 *
 * example: "2013/11/14/0900Z/wind/isobaric/1000hPa/orthographic=26.50,-153.00,1430/overlay=off"
 * output: {date: "2013/11/14", hour: "0900", param: "wind", surface: "isobaric", level: "1000hPa",
 *          projection: "orthographic", orientation: "26.50,-153.00,1430", overlayType: "off"}
 *
 * grammar:
 *     hash   := ( "current" | yyyy / mm / dd / hhhh "Z" ) / param / surface / level [ / option [ / option ... ] ]
 *     option := type [ "=" number [ "," number [ ... ] ] ]
 *
 * @param hash the hash fragment.
 * @param projectionNames the set of allowed projections.
 * @param overlayTypes the set of allowed overlays.
 * @param oldAttr the old set of attributes that this parse will replace.
 * @returns {Object} the result of the parse.
 */

function parse(hash, projectionNames, overlayTypes, oldAttr) {
  var option,
      result = {}; //               1        2        3          4          5            6      7      8    9

  var tokens = /^(current|(\d{4})\/(\d{1,2})\/(\d{1,2})\/(\d{3,4})Z)\/(\w+)\/(\w+)\/(\w+)([\/].+)?/.exec(hash);

  if (tokens) {
    var date = tokens[1] === "current" ? "current" : {
      year: +tokens[2],
      month: +tokens[3],
      day: +tokens[4]
    };

    if (date !== "current") {
      var hour = (tokens[5].length === 3 ? "0" : "") + tokens[5];
      date.hour = +hour.substr(0, 2);
      date.minute = +hour.substr(2);
    }

    result = {
      date: date,
      // "current" or {year:, month:, day:, hour:, minute:}
      param: tokens[6],
      // non-empty alphanumeric _
      surface: tokens[7],
      // non-empty alphanumeric _
      level: tokens[8],
      // non-empty alphanumeric _
      projection: "orthographic",
      orientation: "",
      topology: "." + topologyFile(), // MAL add: "." +
      overlayType: "default",
      showGridPoints: false,
      animate: true,
      loc: null,
      // location mark coordinates [λ, φ]
      argoFloat: null,
      // These fields are part of the app state but not saved in the URL because they are transient state.
      // CONSIDER: separate state into three types of persistence: world, user, and session.
      //           corresponds to: URL, LocalStorage, document/javascript heap.
      hd: oldAttr.hd || false // high def mode. retain current setting because hd is not in the hash.

    };
    coalesce(tokens[9], "").split("/").forEach(function (segment) {
      if (option = /^(\w+)(=([\d\-.,]*))?$/.exec(segment)) {
        if (underscore__WEBPACK_IMPORTED_MODULE_1__.has(projectionNames, option[1])) {
          result.projection = option[1]; // non-empty alphanumeric _

          result.orientation = coalesce(option[3], ""); // comma delimited string of numbers, or ""
        } else if (option[1] === "loc") {
          var parts = underscore__WEBPACK_IMPORTED_MODULE_1__.isString(option[3]) ? option[3].split(",") : [];
          var λ = +parts[0],
              φ = +parts[1];

          if (λ === λ && φ === φ) {
            result.loc = [λ, φ];
          }
        }
      } else if (option = /^overlay=([\w.]+)$/.exec(segment)) {
        if (overlayTypes.has(option[1]) || option[1] === "default") {
          result.overlayType = option[1];
        }
      } else if (option = /^grid=(\w+)$/.exec(segment)) {
        if (option[1] === "on") {
          result.showGridPoints = true;
        }
      } else if (option = /^anim=(\w+)$/.exec(segment)) {
        if (option[1] === "off") {
          result.animate = false;
        }
      } else if (option = /^argo=(\w+)$/.exec(segment)) {
        switch (option[1]) {
          case "planned":
          case "recent":
          case "operational":
          case "dead":
            result.argoFloat = option[1];
        }
      }
    });
  }

  return result;
}
/**
 * A Backbone.js Model that persists its attributes as a human readable URL hash fragment. Loading from and
 * storing to the hash fragment is handled by the sync method.
 */

var Configuration = backbone__WEBPACK_IMPORTED_MODULE_3__.Model.extend({
  id: 0,
  _ignoreNextHashChangeEvent: false,
  _projectionNames: null,
  _overlayTypes: null,

  /**
   * @returns {String} this configuration converted to a hash fragment.
   */
  toHash: function toHash() {
    var attr = this.attributes;
    var dir = attr.date === "current" ? "current" : _utc__WEBPACK_IMPORTED_MODULE_5__["print"](attr.date, "{yyyy}/{MM}/{dd}/{hh}{mm}Z");
    var proj = [attr.projection, attr.orientation].filter(isTruthy).join("=");
    var loc = attr.loc ? "loc=" + attr.loc.map(function (e) {
      return e.toFixed(3);
    }).join(",") : "";
    var ol = !isValue(attr.overlayType) || attr.overlayType === "default" ? "" : "overlay=" + attr.overlayType;
    var grid = attr.showGridPoints ? "grid=on" : "";
    var anim = attr.animate ? "" : "anim=off";
    var argoFloat = attr.argoFloat ? "argo=" + attr.argoFloat : ""; // node: HD not serialized because we want to reduce traffic when sharing links.

    return [dir, attr.param, attr.surface, attr.level, anim, ol, grid, argoFloat, proj, loc].filter(isTruthy).join("/");
  },

  /**
   * Synchronizes between the configuration model and the hash fragment in the URL bar. Invocations
   * caused by "hashchange" events must have the {trigger: "hashchange"} option specified.
   */
  sync: function sync(method, model, options) {
    switch (method) {
      case "read":
        if (options.trigger === "hashchange" && model._ignoreNextHashChangeEvent) {
          model._ignoreNextHashChangeEvent = false;
          return;
        }

        model.set(parse(window.location.hash.substr(1) || DEFAULT_CONFIG, model._projectionNames, model._overlayTypes, model.attributes));
        break;

      case "update":
      case "create":
        var nextHash = "#" + model.toHash(); // Some state, like HD mode, is not persisted in the hash so the hash may not change.

        if (window.location.hash !== nextHash) {
          // Ugh. Setting the hash fires a hashchange event during the next event loop turn. Ignore it.
          model._ignoreNextHashChangeEvent = true;
          window.location.hash = nextHash;
        }

        break;
    }
  }
});
/**
 * A Backbone.js Model to hold the page's configuration as a set of attributes: date, layer, projection,
 * orientation, etc. Changes to the configuration fire events which the page's components react to. For
 * example, configuration.save({projection: "orthographic"}) fires an event which causes the globe to be
 * re-rendered with an orthographic projection.
 *
 * All configuration attributes are persisted in a human readable form to the page's hash fragment (and
 * vice versa). This allows deep linking and back-button navigation.
 *
 * @returns {Configuration} Model to represent the hash fragment, using the specified set of allowed projections.
 */

function buildConfiguration(projectionNames, overlayTypes) {
  var result = new Configuration();
  result._projectionNames = projectionNames;
  result._overlayTypes = overlayTypes;
  return result;
}
/**
 * @param query URL search query string, e.g., "?a=1&b=2&c=&d"
 * @returns {Object} an object of terms, e.g., {a: "1", b: "2", c: "", d: null}
 */

function parseQueryString(query) {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.object(query.split(/[?&]/).filter(isTruthy).map(function (term) {
    return term.split("=").map(decodeURIComponent).concat([null]); // use null for 2nd element when undefined
  }));
}
function dateToConfig(date) {
  return {
    date: _utc__WEBPACK_IMPORTED_MODULE_5__["normalize"](date)
  };
}
function isAppMode() {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.has(parseQueryString(window.location.search), "app");
}
function isKioskMode() {
  var host = document.referrer.split("/")[2] || "";
  var override = /dailymail/i.test(host);
  return underscore__WEBPACK_IMPORTED_MODULE_1__.has(parseQueryString(window.location.search), "kiosk") && !override;
}
/** @returns {boolean} true if globe rotation and zoom should be disabled. UNDONE: no one uses this. rip out? */

function isFixedMode() {
  return underscore__WEBPACK_IMPORTED_MODULE_1__.has(parseQueryString(window.location.search), "fixed");
}
/**
 * @param {Array|Uint8Array|Float32Array} a any array-like object
 * @param {Array|Uint8Array|Float32Array} b any array-like object
 * @returns {boolean} true if both arrays are strictly equal (using ===) while recursing down nested arrays.
 */

function arraysEq(a, b) {
  for (var i = 0; i < a.length; i++) {
    var s = a[i],
        t = b[i];

    if (s === t) {
      continue; // exactly equal
    }

    if (s !== s && t !== t) {
      continue; // both are NaN
    }

    if (isArrayLike(s) && arraysEq(s, t)) {
      continue; // nested arrays are equal
    }

    return false;
  }

  return a.length === b.length;
}
/**
 * @param {Float32Array} a [a0, a1, a2, ...]
 * @param {Float32Array} b [b0, b1, b2, ...]
 * @returns {Float32Array} [a0, b0, a1, b1, a2, b2, ...]
 */

function merge(a, b) {
  var result = new Float32Array(a.length * 2);

  for (var i = 0; i < a.length; i++) {
    var j = i * 2;
    result[j] = a[i];
    result[j + 1] = b[i];
  }

  return result;
}
/**
 * @param {*|Uint8Array} src any array-like object
 * @returns {Array} a new Array containing the same elements.
 */

function toArray(src) {
  return Array.prototype.slice.call(src); // Replace with Array.from() in the future.
}
/**
 * @param {Int8Array|Int16Array|Int32Array} array any TypedArray
 * @param {Number} samples the number of samples to compute the hash code
 * @returns {Number} the hash code
 */

function _arrayHashCode(array, samples) {
  var result = new Int32Array([array.byteLength]);
  var step = Math.max(array.length / samples, 1);

  for (var i = 0; i < array.length; i += step) {
    result[0] = 31 * result[0] + array[Math.floor(i)];
  }

  return result[0];
}
/**
 * Constructs a hash code from _some_ elements of an array. Trades collision avoidance for performance.
 * @param {Float32Array|Uint8Array} array any TypedArray
 * @param {Number} [samples] the number of samples to compute the hash code with. (default: all)
 * @returns {Number} the hash code
 */


function arrayHashCode(array) {
  var samples = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  var data;

  switch (array.byteLength % 4) {
    case 0:
      data = new Int32Array(array.buffer);
      break;

    case 2:
      data = new Int16Array(array.buffer);
      break;

    default:
      data = new Int8Array(array.buffer);
      break;
  }

  return _arrayHashCode(data, samples);
}
function isArrayLike(obj) {
  if (Array.isArray(obj)) return true;
  if (_typeof(obj) !== "object" || !obj) return false;
  var length = obj.length;
  return typeof length === "number" && length >= 0;
}
function omit(obj) {
  for (var _len = arguments.length, discard = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    discard[_key - 1] = arguments[_key];
  }

  var result = {};
  Object.keys(obj).forEach(function (key) {
    if (discard.indexOf(key) < 0) {
      result[key] = obj[key];
    }
  });
  return result;
}

function _flatten(array, target) {
  for (var i = 0; i < array.length; i++) {
    var e = array[i];

    if (isArrayLike(e)) {
      _flatten(e, target);
    } else {
      target.push(e);
    }
  }

  return target;
}

function flatten(array) {
  return isArrayLike(array) ? _flatten(array, []) : undefined;
}

/***/ }),

/***/ "./public/js/palette/aurora.js":
/*!*************************************!*\
  !*** ./public/js/palette/aurora.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);




/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 100];
  var stops = [{
    color: chroma_js__WEBPACK_IMPORTED_MODULE_1___default()([0, 0, 0]),
    mode: "lab",
    p: bounds[0]
  }, {
    color: chroma_js__WEBPACK_IMPORTED_MODULE_1___default()([4, 8, 34]),
    mode: "lab",
    p: 5
  }, {
    color: chroma_js__WEBPACK_IMPORTED_MODULE_1___default()([78, 255, 103]),
    mode: "lab",
    p: 40
  }, {
    color: chroma_js__WEBPACK_IMPORTED_MODULE_1___default()([252, 255, 57]),
    mode: "lab",
    p: 60
  }, {
    color: chroma_js__WEBPACK_IMPORTED_MODULE_1___default()([219, 75, 255]),
    mode: "lab",
    p: bounds[1]
  }];
  var scales = _palette__WEBPACK_IMPORTED_MODULE_0__["scalesFrom"](stops);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 1, [35, 45]);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 3, [55, 65]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromChromaScales"](bounds, scales, resolution);
});

/***/ }),

/***/ "./public/js/palette/cape.js":
/*!***********************************!*\
  !*** ./public/js/palette/cape.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 5000]; // units: J/kg

  var segments = [// Diverging 11-class RdBu, from colorbrewer2.org
  [0, [5, 48, 97]], // weak
  [500, [33, 102, 172]], // weak
  [1000, [67, 147, 195]], // weak
  [1500, [146, 197, 222]], // moderate
  [2000, [209, 229, 240]], // moderate
  [2500, [247, 247, 247]], // moderate
  [3000, [253, 219, 199]], // strong
  [3500, [244, 165, 130]], // strong
  [4000, [214, 96, 77]], // strong
  [4500, [178, 24, 43]], // extreme
  [5000, [103, 0, 31]] // extreme
  ];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./public/js/palette/co2.js":
/*!**********************************!*\
  !*** ./public/js/palette/co2.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0.0003578, 0.0003770]; // units: CO2 Bulk Mixing Ratio (Column Mass/ps) -- or CO2 column load??

  var stops = [{
    color: [0, 0, 0],
    mode: "lch",
    p: bounds[0]
  }, {
    color: [100, 0, 0],
    mode: "lch",
    p: 0.0003650
  }, {
    color: [164, 36, 0],
    mode: "lch",
    p: 0.0003675
  }, {
    color: [255, 220, 140],
    mode: "lch",
    p: 0.0003710
  }, {
    color: [255, 255, 255],
    mode: "lch",
    p: bounds[1]
  }];
  var scales = _palette__WEBPACK_IMPORTED_MODULE_0__["scalesFrom"](stops);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 2, [0.0003700, 0.0003720]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromChromaScales"](bounds, scales, resolution);
});

/***/ }),

/***/ "./public/js/palette/co2sc.js":
/*!************************************!*\
  !*** ./public/js/palette/co2sc.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function (Δ) {
  var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
  var bounds = [360 + Δ, 470 + Δ]; // units: CO2 Surface Concentration ppmv

  var stops = [{
    color: [0, 0, 0],
    mode: "lch",
    p: bounds[0]
  }, {
    color: [100, 0, 0],
    mode: "lch",
    p: 400 + Δ
  }, {
    color: [164, 36, 0],
    mode: "lch",
    p: 405 + Δ
  }, {
    color: [255, 220, 140],
    mode: "lch",
    p: 420 + Δ
  }, {
    color: [255, 255, 255],
    mode: "lch",
    p: 450 + Δ
  }, {
    color: [0, 210, 255],
    mode: "lch",
    p: bounds[1]
  }];
  var x = stops[3].p,
      y = stops[4].p,
      z = stops[1].p;
  var scales = _palette__WEBPACK_IMPORTED_MODULE_0__["scalesFrom"](stops);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 0, [z - 2, z + 2]);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 3, [x - 2, x + 2]);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 5, [y - 2, y + 2]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromChromaScales"](bounds, scales, resolution);
});

/***/ }),

/***/ "./public/js/palette/cosc.js":
/*!***********************************!*\
  !*** ./public/js/palette/cosc.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;
  var bounds = [40, 2500]; // units: ppb

  var stops = [{
    color: [0, 38, 40],
    mode: "lab",
    p: bounds[0]
  }, {
    color: [255, 255, 224],
    mode: "lch",
    p: 400
  }, // background is ~100 ppb https://en.wikipedia.org/wiki/MOPITT
  {
    color: [0, 0, 154],
    mode: "lab",
    p: 1800
  }, {
    color: [0, 0, 0],
    mode: "lab",
    p: bounds[1]
  }];
  var scales = _palette__WEBPACK_IMPORTED_MODULE_0__["scalesFrom"](stops);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 0, [360, 440]);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 2, [1700, 1900]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromChromaScales"](bounds, scales, resolution);
});

/***/ }),

/***/ "./public/js/palette/duexttau.js":
/*!***************************************!*\
  !*** ./public/js/palette/duexttau.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");
/* harmony import */ var _kindlmann__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./kindlmann */ "./public/js/palette/kindlmann.js");




/* harmony default export */ __webpack_exports__["default"] = (function () {
  var bounds = [0.0001, 3.0000]; // units: τ

  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, _kindlmann__WEBPACK_IMPORTED_MODULE_1__["default"], Math.log, Math.exp);
});

/***/ }),

/***/ "./public/js/palette/kindlmann.js":
/*!****************************************!*\
  !*** ./public/js/palette/kindlmann.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

/**
 * Kindlmann Linear Luminance palette
 *
 * Kindlmann, G. Reinhard, E. and Creem, S., 2002, Face-based Luminance Matching for Perceptual Colormap Generation,
 *     IEEE – Proceedings of the conference on Visualization ’02
 *
 * Prepared by Matteo Niccoli:
 *     https://mycarta.wordpress.com/2012/12/06/the-rainbow-is-deadlong-live-the-rainbow-part-5-cie-lab-linear-l-rainbow/
 */

function generate(data) {
  var result = new Uint8Array(data.length / 3 * 4);

  for (var i = 0, j = 0; i < data.length; i += 3, j += 4) {
    result[j] = data[i];
    result[j + 1] = data[i + 1];
    result[j + 2] = data[i + 2];
    result[j + 3] = 255;
  }

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (generate([4, 4, 4, 10, 3, 8, 13, 4, 11, 16, 5, 14, 18, 5, 16, 21, 6, 18, 22, 7, 19, 24, 8, 21, 26, 8, 22, 27, 9, 24, 28, 10, 25, 30, 11, 26, 31, 12, 27, 32, 12, 28, 33, 13, 29, 35, 14, 31, 36, 14, 32, 37, 15, 32, 38, 15, 33, 39, 16, 34, 40, 17, 35, 41, 17, 36, 42, 18, 38, 43, 19, 38, 44, 19, 39, 46, 20, 41, 46, 20, 45, 46, 21, 50, 45, 21, 55, 45, 21, 60, 45, 22, 64, 45, 23, 67, 45, 23, 71, 45, 24, 75, 45, 24, 77, 45, 25, 81, 45, 25, 84, 44, 26, 87, 44, 27, 90, 45, 27, 92, 45, 28, 95, 44, 29, 98, 44, 29, 100, 44, 30, 103, 44, 31, 106, 44, 31, 109, 44, 32, 110, 44, 33, 113, 44, 34, 116, 43, 34, 118, 42, 35, 121, 40, 38, 120, 38, 40, 119, 36, 42, 120, 34, 44, 120, 33, 46, 120, 32, 47, 120, 31, 49, 121, 30, 50, 122, 30, 51, 123, 29, 52, 123, 29, 53, 125, 28, 55, 125, 28, 56, 126, 27, 57, 127, 28, 58, 128, 28, 59, 129, 27, 60, 129, 27, 61, 131, 27, 62, 132, 27, 63, 133, 28, 64, 134, 27, 65, 135, 27, 66, 136, 27, 68, 137, 27, 69, 138, 25, 71, 136, 22, 73, 134, 21, 74, 133, 20, 76, 131, 17, 78, 129, 16, 79, 128, 15, 81, 126, 14, 82, 125, 10, 84, 123, 10, 85, 122, 9, 87, 120, 8, 88, 119, 7, 89, 118, 6, 91, 117, 4, 92, 115, 4, 94, 114, 4, 95, 114, 3, 96, 112, 1, 98, 111, 1, 99, 110, 0, 100, 109, 0, 101, 108, 0, 103, 107, 0, 104, 106, 0, 105, 105, 0, 107, 104, 0, 108, 101, 0, 110, 100, 0, 111, 99, 0, 112, 98, 0, 114, 96, 0, 115, 95, 0, 116, 93, 0, 118, 92, 0, 119, 90, 0, 120, 89, 0, 121, 88, 0, 123, 86, 0, 124, 85, 0, 125, 83, 0, 127, 82, 0, 128, 80, 0, 129, 79, 0, 131, 77, 0, 132, 75, 0, 133, 73, 0, 134, 72, 0, 136, 70, 0, 137, 68, 0, 138, 66, 0, 139, 65, 0, 141, 64, 0, 142, 63, 0, 143, 61, 0, 145, 60, 0, 146, 60, 0, 147, 58, 0, 149, 57, 0, 150, 56, 0, 151, 55, 0, 153, 53, 0, 154, 52, 0, 155, 51, 0, 157, 50, 0, 158, 48, 0, 159, 47, 0, 160, 45, 0, 162, 44, 0, 163, 42, 0, 164, 41, 0, 165, 39, 0, 167, 36, 0, 168, 34, 0, 169, 31, 0, 170, 23, 0, 169, 8, 9, 170, 0, 20, 171, 0, 29, 172, 0, 35, 173, 0, 40, 174, 0, 45, 175, 0, 48, 176, 0, 52, 177, 0, 55, 178, 0, 59, 179, 0, 61, 180, 0, 64, 181, 0, 66, 182, 0, 68, 183, 0, 71, 184, 0, 73, 185, 0, 76, 186, 0, 78, 187, 0, 79, 188, 0, 81, 189, 0, 83, 190, 0, 85, 191, 0, 87, 192, 0, 92, 193, 0, 99, 193, 0, 106, 193, 0, 114, 193, 0, 119, 194, 0, 125, 194, 0, 130, 194, 0, 135, 195, 0, 140, 195, 0, 145, 195, 0, 149, 196, 0, 153, 196, 0, 157, 197, 0, 161, 197, 0, 165, 197, 0, 169, 198, 0, 172, 198, 0, 176, 199, 0, 180, 199, 0, 184, 199, 0, 186, 200, 0, 190, 201, 0, 193, 201, 0, 197, 201, 0, 200, 202, 0, 201, 201, 24, 203, 202, 51, 206, 202, 65, 207, 203, 77, 209, 203, 87, 212, 203, 95, 213, 204, 103, 215, 205, 109, 218, 205, 116, 219, 206, 121, 221, 207, 127, 223, 207, 132, 226, 207, 138, 227, 208, 143, 229, 209, 147, 231, 209, 151, 232, 210, 155, 235, 211, 159, 237, 211, 164, 238, 212, 168, 240, 212, 172, 243, 213, 175, 243, 214, 179, 245, 214, 183, 248, 215, 186, 248, 216, 189, 248, 218, 193, 247, 219, 195, 247, 220, 198, 247, 222, 201, 248, 223, 204, 247, 224, 206, 247, 226, 209, 247, 227, 211, 247, 229, 214, 247, 230, 216, 247, 231, 218, 247, 232, 220, 248, 234, 224, 247, 235, 225, 247, 236, 229, 247, 238, 231, 247, 239, 232, 248, 240, 235, 248, 242, 237, 247, 243, 239, 248, 244, 241, 248, 246, 244, 248, 247, 246, 248, 248, 248, 249, 249, 249, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255, 255, 255]));

/***/ }),

/***/ "./public/js/palette/linear.frag":
/*!***************************************!*\
  !*** ./public/js/palette/linear.frag ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat fmap(in float v) {\n    return v;\n}\n"

/***/ }),

/***/ "./public/js/palette/log.frag":
/*!************************************!*\
  !*** ./public/js/palette/log.frag ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nfloat fmap(in float v) {\n    return log(v);\n}\n"

/***/ }),

/***/ "./public/js/palette/palette.frag":
/*!****************************************!*\
  !*** ./public/js/palette/palette.frag ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform vec2 u_Range;  // [min, size]\nuniform lowp sampler2D u_Palette;\nuniform lowp float u_Alpha;\n\nlowp vec4 colorize(in float v) {\n    vec2 st = vec2((fmap(v) - u_Range.x) / u_Range.y, 0.5);\n    lowp vec4 color = texture2D(u_Palette, st);\n    lowp float alpha = (1.0 - step(7e37, v)) * u_Alpha;\n    return vec4(color.rgb * alpha, alpha);  // premultiply alpha\n}\n"

/***/ }),

/***/ "./public/js/palette/palette.js":
/*!**************************************!*\
  !*** ./public/js/palette/palette.js ***!
  \**************************************/
/*! exports provided: sinebowColor, extendedSinebowColor, segmentedColorScale, scalesFrom, smooth, fillRange, quantize, buildScaleFromChromaScales, buildScaleFromSegments, buildScale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sinebowColor", function() { return sinebowColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendedSinebowColor", function() { return extendedSinebowColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "segmentedColorScale", function() { return segmentedColorScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalesFrom", function() { return scalesFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smooth", function() { return smooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillRange", function() { return fillRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return quantize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildScaleFromChromaScales", function() { return buildScaleFromChromaScales; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildScaleFromSegments", function() { return buildScaleFromSegments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildScale", function() { return buildScale; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./public/js/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./public/js/math.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_3__);


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function colorInterpolator(start, end) {
  var _start = _slicedToArray(start, 3),
      r = _start[0],
      g = _start[1],
      b = _start[2];

  var Δr = end[0] - r,
      Δg = end[1] - g,
      Δb = end[2] - b;
  return function (i, a) {
    return [Math.floor(r + i * Δr), Math.floor(g + i * Δg), Math.floor(b + i * Δb), a].map(function (e) {
      return Object(_math__WEBPACK_IMPORTED_MODULE_1__["clamp"])(e, 0, 255);
    });
  };
}
/**
 * Produces a color style in a rainbow-like trefoil color space. Not quite HSV, but produces a nice
 * spectrum. See http://krazydad.com/tutorials/makecolors.php.
 *
 * @param hue the hue rotation in the range [0, 1]
 * @param a the alpha value in the range [0, 255]
 * @returns {Array} [r, g, b, a]
 */


function sinebowColor(hue, a) {
  // Map hue [0, 1] to radians [0, 5/6τ]. Don't allow a full rotation because that keeps hue == 0 and
  // hue == 1 from mapping to the same color.
  var rad = hue * _consts__WEBPACK_IMPORTED_MODULE_0__["τ"] * 5 / 6;
  rad *= 0.75; // increase frequency to 2/3 cycle per rad

  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var r = Math.floor(Math.max(0, -c) * 255);
  var g = Math.floor(Math.max(s, 0) * 255);
  var b = Math.floor(Math.max(c, 0, -s) * 255);
  return [r, g, b, a];
}
var BOUNDARY = 0.45;
var fadeToWhite = colorInterpolator(sinebowColor(1.0, 0), [255, 255, 255]);
/**
 * Interpolates a sinebow color where 0 <= i <= j, then fades to white where j < i <= 1.
 *
 * @param i number in the range [0, 1]
 * @param a alpha value in range [0, 255]
 * @returns {Array} [r, g, b, a]
 */

function extendedSinebowColor(i, a) {
  return i <= BOUNDARY ? sinebowColor(i / BOUNDARY, a) : fadeToWhite((i - BOUNDARY) / (1 - BOUNDARY), a);
}
/**
 * Creates a color scale composed of the specified segments. Segments is an array of two-element arrays of the
 * form [value, color], where value is the point along the scale and color is the [r, g, b] color at that point.
 * For example, the following creates a scale that smoothly transitions from red to green to blue along the
 * points 0.5, 1.0, and 3.5:
 *
 *     [ [ 0.5, [255,   0,   0] ],
 *       [ 1.0, [  0, 255,   0] ],
 *       [ 3.5, [  0,   0, 255] ] ]
 *
 * @param segments array of color segments
 * @returns {Function} a function(point, alpha) that returns the color [r, g, b, alpha] for the given point.
 */

function segmentedColorScale(segments) {
  var points = [],
      interpolators = [],
      ranges = [];

  for (var i = 0; i < segments.length - 1; i++) {
    points.push(segments[i + 1][0]);
    interpolators.push(colorInterpolator(segments[i][1], segments[i + 1][1]));
    ranges.push([segments[i][0], segments[i + 1][0]]);
  }

  return function (point, alpha) {
    var i;

    for (i = 0; i < points.length - 1; i++) {
      if (point <= points[i]) {
        break;
      }
    }

    return interpolators[i](Object(_math__WEBPACK_IMPORTED_MODULE_1__["proportion"])(point, ranges[i]), alpha);
  };
}
/**
 * Converts an array of N color stops into N-1 chroma scales:
 *
 *    {color: "black", mode: "lch", p: 10},
 *    {color: "grey",  mode: "lab", p: 20},
 *    {color: "white",              p: 30}
 *
 * Result:
 *    scale 0 [black, grey] over domain [10, 20] in lch color space
 *    scale 1 [grey, white] over domain [20, 30] in lab color space
 *
 * @param {Array} stops an array of colors stops to convert into scales.
 * @returns {Array} an array of chroma.js scales.
 */

function scalesFrom(stops) {
  var scales = [];

  for (var i = 0; i < stops.length - 1; i++) {
    var lo = stops[i],
        hi = stops[i + 1];
    scales.push(chroma_js__WEBPACK_IMPORTED_MODULE_3___default.a.scale([chroma_js__WEBPACK_IMPORTED_MODULE_3___default()(lo.color), chroma_js__WEBPACK_IMPORTED_MODULE_3___default()(hi.color)]).domain([lo.p, hi.p]).mode(lo.mode));
  }

  return scales;
}
/**
 * Given a range [a, b] and two adjoining color scales L (i) and R (i+1) sharing domain point p, insert a new
 * bezier-interpolated scale M over the points [a, p, b].
 *
 * @param {Array} scales
 * @param {Number} i
 * @param {Array} range
 * @returns {Array}
 */

function smooth(scales, i, range) {
  //         p                  p
  //        / \              M _-_
  //       /   \      =>      /   \
  //      /     \            a     b
  //   L /       \ R      K /       \ S
  //    Lx       Ry        Lx       Ry
  var L = scales[i],
      R = scales[i + 1],
      lx = L.domain()[0],
      ry = R.domain()[1],
      p = L.domain()[1];
  var a = range[0],
      b = range[1];
  var K = chroma_js__WEBPACK_IMPORTED_MODULE_3___default.a.scale([L(lx), L(a)]).domain([lx, a]).mode(L.mode());
  var M = chroma_js__WEBPACK_IMPORTED_MODULE_3___default.a.scale(chroma_js__WEBPACK_IMPORTED_MODULE_3___default.a.bezier([L(a), L(p), R(b)])).domain([a, b]).mode(L.mode());
  var S = chroma_js__WEBPACK_IMPORTED_MODULE_3___default.a.scale([R(b), R(ry)]).domain([b, ry]).mode(R.mode());
  return [].concat(scales.slice(0, i), [K, M, S], scales.slice(i + 2));
}
/**
 * Use array A of length n to define a linear scale over domain [x, y] such that [x, y] is mapped onto indices
 * [0, n-1]. The range [a, b] is then mapped to indices [i, j] using this scale, and the elements A[i] to A[j] are
 * filled with the results of f(v) where v iterates over [a, b].
 *
 * @param {Uint8Array} array the destination array to fill as rgba quadlets: [r0, g0, b0, a0, ...]
 * @param {Number[]} domain the values [x, y], inclusive.
 * @param {Number[]} range the values [a, b], inclusive.
 * @param {Function} ƒcolor the value function f(v) that returns [r, g, b, a] for the specified value.
 */

function fillRange(array, domain, range, ƒcolor) {
  //    |-----------domain------------|
  //    |        |---range---|        |
  //    x        a           b        y
  //    0        i           j      len-1
  // A [0, ..., f(a), ..., f(b), ..., 0]
  var x = domain[0],
      y = domain[1],
      Δ = (y - x) / (array.length / 4 - 1);
  var a = range[0],
      b = range[1];
  var start = Math.round((a - x) / Δ),
      end = Math.round((b - x) / Δ);

  for (var i = start; i < end + 1; i++) {
    var c = ƒcolor(x + i * Δ);
    var j = i * 4;
    array[j] = c[0];
    array[j + 1] = c[1];
    array[j + 2] = c[2];
    array[j + 3] = _micro__WEBPACK_IMPORTED_MODULE_2__["coalesce"](c[3], 255); // default to alpha 1.0 if not specified.
  }
}
/**
 * Convert a set of chroma.js scales into an accessor function over a computed array of rgba colors.
 *
 * @param {Number[]} bounds the values [x, y], inclusive.
 * @param {Array} scales the set of scales.
 * @param {Number} resolution the number of elements of the computed color array.
 * @returns {Uint8Array} sequence of rgba quadlets: [r0, g0, b0, a0, r1, g1, b1, a1, ...]
 */

function quantize(bounds, scales, resolution) {
  var array = new Uint8Array(resolution * 4);
  scales.forEach(function (scale) {
    fillRange(array, bounds, scale.domain(), function (v) {
      return scale(v).rgba().map(Math.round);
    });
  });
  return array;
}
function buildScaleFromChromaScales(bounds, scales, resolution) {
  var colors = quantize(bounds, scales, resolution);
  return buildScale(bounds, colors);
}
function buildScaleFromSegments(bounds, segments, resolution) {
  var gradient = segmentedColorScale(segments);
  var array = new Uint8Array(resolution * 4);
  fillRange(array, bounds, bounds, gradient);
  return buildScale(bounds, array);
}
/**
 * @param {Number[]} bounds [low, high] values. Assumes bounds are _center_ aligned color stops.
 * @param {Uint8Array} colors sequence of rgba quadlets: [r0, g0, b0, a0, r1, g1, b1, a1, ...]
 * @param {Function} [ƒmap] the scale function, like Math.log (default is linear).
 * @param {Function} [ƒinv] the inverse scale function, like Math.exp (default is linear).
 * @returns {Scale}
 */

function buildScale(bounds, colors) {
  var ƒmap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (v) {
    return v;
  };
  var ƒinv = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (v) {
    return v;
  };

  /*
   Two types of scale representations:
   0        10        20        30        40        50   <= Split range [0, 50] (inclusive) over 5 buckets.
  |         |         |         |         |         |      Stops are aligned with _edges_ of buckets.
  +---------+---------+---------+---------+---------+
  | 0 black | 1 blue  | 2 green | 3  red  | 4 white |   array.length == n == 5
  +---------+---------+---------+---------+---------+
       |         |         |         |         |
       5        15        25        35        45        <= Color stops define _centers_, where distance between
                                                           stops is bucket size. Range here is [5, 45].
   These two scales are equivalent but use different formulas to map value -> index for array access, and
  value -> texcoord on range [0, 1].
   For edge aligned stops:
      texcoord s = (value - edgeLow) / (edgeHigh - edgeLow)
      index    i = s * n - 0.5
   For center aligned stops:
      index    i = (value - centerLow) / (centerHigh - centerLow) * (n - 1)
      texcoord s = (i + 0.5) / n
   To convert between the two different scale types, expand/contract the bounds based on bucket count:
      [centerLow, centerHigh] == [edgeLow + ε, edgeHigh - ε]  where ε = (edgeHigh - edgeLow) / 2n
      [edgeLow, edgeHigh] == [centerLow - ε, centerHigh + ε]  where ε = (centerHigh - centerLow) / 2(n-1)
    */
  var lo = ƒmap(bounds[0]),
      hi = ƒmap(bounds[1]);
  var iMax = colors.length / 4 - 1,
      scale = iMax / (hi - lo);
  var hash = _micro__WEBPACK_IMPORTED_MODULE_2__["arrayHashCode"](colors, 1000);
  var ε = (hi - lo) / (2 * iMax);
  var edgeLo = lo - ε,
      edgeHi = hi + ε,
      edgeRange = [edgeLo, edgeHi - edgeLo];
  return new (
  /*#__PURE__*/
  function () {
    function Scale() {
      _classCallCheck(this, Scale);
    }

    _createClass(Scale, [{
      key: "indexOf",

      /**
       * @param {Number} value the scale value
       * @returns {Number} the rgba quadlet index; multiply by 4 for the true index in the colors array.
       */
      value: function indexOf(value) {
        var i = Math.round((ƒmap(value) - lo) * scale);
        return Object(_math__WEBPACK_IMPORTED_MODULE_1__["clamp"])(i, 0, iMax);
      }
      /**
       * @param index the rgba quadlet index
       * @returns {Number} the associated scale value
       */

    }, {
      key: "valueFor",
      value: function valueFor(index) {
        return ƒinv(index / scale + lo);
      }
      /**
       * @param {Number} value the scale value
       * @returns {Number[]} rgba quadlet for the specified value
       */

    }, {
      key: "rgba",
      value: function rgba(value) {
        var j = this.indexOf(value) * 4;
        return [colors[j], colors[j + 1], colors[j + 2], colors[j + 3]];
      }
      /**
       * @param {GLUStick} glu
       */

    }, {
      key: "webgl",
      value: function webgl(glu) {
        var gl = glu.context;
        return {
          shaderSource: function shaderSource() {
            var mapper = ƒmap === Math.log ? __webpack_require__(/*! ./log.frag */ "./public/js/palette/log.frag") : __webpack_require__(/*! ./linear.frag */ "./public/js/palette/linear.frag");
            return [mapper, __webpack_require__(/*! ./palette.frag */ "./public/js/palette/palette.frag")];
          },
          textures: function textures() {
            return {
              color_scale: {
                format: gl.RGBA,
                type: gl.UNSIGNED_BYTE,
                width: colors.length / 4,
                height: 1,
                data: colors,
                hash: hash
              }
            };
          },
          uniforms: function uniforms() {
            return {
              u_Range: edgeRange,
              u_Palette: "color_scale",
              u_Alpha: 1.0
            };
          }
        };
      }
    }, {
      key: "colors",

      /**
       * @returns {Uint8Array} [r0, g0, b0, a0, r1, g1, b1, a1, ...]
       */
      get: function get() {
        return colors;
      }
      /**
       * @returns {Number[]} [low, high] bounds of this scale.
       */

    }, {
      key: "bounds",
      get: function get() {
        return bounds;
      }
    }]);

    return Scale;
  }())();
}

/***/ }),

/***/ "./public/js/palette/pmx.js":
/*!**********************************!*\
  !*** ./public/js/palette/pmx.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [1e-9, 1000e-9]; // units: µg/m3

  var logBounds = bounds.map(Math.log); // combination of colorbrewer YlGnBu and YlOrRd

  var stops = [{
    color: [8, 29, 88],
    mode: "lch",
    p: logBounds[0]
  }, {
    color: [37, 52, 148],
    mode: "lch",
    p: Math.log(4e-9)
  }, {
    color: [34, 94, 168],
    mode: "lch",
    p: Math.log(6e-9)
  }, {
    color: [29, 145, 192],
    mode: "lch",
    p: Math.log(8e-9)
  }, {
    color: [65, 182, 196],
    mode: "lch",
    p: Math.log(10e-9)
  }, {
    color: [127, 205, 187],
    mode: "lch",
    p: Math.log(16e-9)
  }, {
    color: [199, 233, 180],
    mode: "lch",
    p: Math.log(24e-9)
  }, {
    color: [237, 248, 177],
    mode: "lch",
    p: Math.log(28e-9)
  }, {
    color: [255, 255, 210],
    mode: "lch",
    p: Math.log(32e-9)
  }, {
    color: [255, 237, 160],
    mode: "lch",
    p: Math.log(42e-9)
  }, {
    color: [254, 217, 118],
    mode: "lch",
    p: Math.log(47e-9)
  }, {
    color: [254, 178, 76],
    mode: "lch",
    p: Math.log(57e-9)
  }, {
    color: [253, 141, 60],
    mode: "lch",
    p: Math.log(67e-9)
  }, {
    color: [252, 78, 42],
    mode: "lch",
    p: Math.log(110e-9)
  }, {
    color: [227, 26, 28],
    mode: "lch",
    p: Math.log(250e-9)
  }, {
    color: [189, 0, 38],
    mode: "lch",
    p: Math.log(500e-9)
  }, {
    color: [128, 0, 38],
    mode: "lch",
    p: logBounds[1]
  }];
  var scales = _palette__WEBPACK_IMPORTED_MODULE_0__["scalesFrom"](stops);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 7, [Math.log(30e-9), Math.log(35e-9)]);
  var colors = _palette__WEBPACK_IMPORTED_MODULE_0__["quantize"](logBounds, scales, resolution);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, colors, Math.log, Math.exp);
});

/***/ }),

/***/ "./public/js/palette/precip.js":
/*!*************************************!*\
  !*** ./public/js/palette/precip.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);




/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;
  var bounds = [0, 150]; // units: kg/m3 == mm

  var stops = [{
    color: chroma_js__WEBPACK_IMPORTED_MODULE_1___default()("#719aa9").darker(30),
    mode: "lch",
    p: bounds[0]
  }, {
    color: "aliceblue",
    mode: "lch",
    p: 2
  }, {
    color: chroma_js__WEBPACK_IMPORTED_MODULE_1___default()("navy").brighter(10),
    mode: "lch",
    p: 15
  }, {
    color: "gold",
    mode: "lch",
    p: 100
  }, {
    color: "white",
    mode: "lch",
    p: bounds[1]
  }];
  var scales = _palette__WEBPACK_IMPORTED_MODULE_0__["scalesFrom"](stops);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 0, [1, 3]);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 2, [13, 17]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromChromaScales"](bounds, scales, resolution);
});
/*
https://en.wikipedia.org/wiki/Rain#Intensity

Light rain — when the precipitation rate is < 2.5 mm (0.098 in) per hour
Moderate rain — when the precipitation rate is between 2.5 mm (0.098 in) - 7.6 mm (0.30 in) or 10 mm (0.39 in) per hour
Heavy rain — when the precipitation rate is > 7.6 mm (0.30 in) per hour, or between 10 mm (0.39 in) and 50 mm (2.0 in) per hour
Violent rain — when the precipitation rate is > 50 mm (2.0 in) per hour
*/

/***/ }),

/***/ "./public/js/palette/so2smass.js":
/*!***************************************!*\
  !*** ./public/js/palette/so2smass.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;
  //      v*1e-14
  //             1
  //         3,000  boat trail start
  //        20,000
  //       115,000  boat trail peak
  //       262,000     1 ppb
  //    19,650,000    75 ppb, EPA 1hr std limit
  //    65,500,000   250 ppb, Amer Conf of Gvt Indus Hygen short term exposure limit
  //   163,226,000   623 ppb, largest seen in 2 weeks of geos-driver
  //   484,962,000  1851 ppb, top of log scale
  // 1,310,000,000  5000 ppb, OSHA PEL
  var bounds = [10e-14, 88800000e-14]; // units: kg/m3

  var logBounds = bounds.map(Math.log);
  var stops = [{
    color: [134, 134, 107],
    mode: "lch",
    p: logBounds[0]
  }, {
    color: [144, 144, 117],
    mode: "lch",
    p: Math.log(100e-14)
  }, {
    color: [255, 255, 224],
    mode: "lch",
    p: Math.log(7000e-14)
  }, {
    color: [0, 0, 128],
    mode: "lab",
    p: Math.log(19000000e-14)
  }, {
    color: [23, 20, 18],
    mode: "lab",
    p: logBounds[1]
  }];
  var scales = _palette__WEBPACK_IMPORTED_MODULE_0__["scalesFrom"](stops);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 1, [Math.log(5000e-14), Math.log(9000e-14)]);
  scales = _palette__WEBPACK_IMPORTED_MODULE_0__["smooth"](scales, 3, [Math.log(10000000e-14), Math.log(30000000e-14)]);
  var colors = _palette__WEBPACK_IMPORTED_MODULE_0__["quantize"](logBounds, scales, resolution);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, colors, Math.log, Math.exp);
});

/***/ }),

/***/ "./public/js/palette/suexttau.js":
/*!***************************************!*\
  !*** ./public/js/palette/suexttau.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_1__);




/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
  var bounds = [0.002, 2.500]; // units: τ

  var logBounds = bounds.map(Math.log);
  var scale = chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.scale(chroma_js__WEBPACK_IMPORTED_MODULE_1___default.a.cubehelix()).domain(logBounds);
  var colors = _palette__WEBPACK_IMPORTED_MODULE_0__["quantize"](logBounds, [scale], resolution);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, colors, Math.log, Math.exp);
});

/***/ }),

/***/ "./public/js/palette/temp.js":
/*!***********************************!*\
  !*** ./public/js/palette/temp.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;
  var bounds = [193, 328]; // units: kelvins

  var segments = [[193, [37, 4, 42]], [206, [41, 10, 130]], [219, [81, 40, 40]], [233.15, [192, 37, 149]], // -40 C/F
  [255.372, [70, 215, 215]], // 0 F
  [273.15, [21, 84, 187]], // 0 C
  [275.15, [24, 132, 14]], // just above 0 C
  [291, [247, 251, 59]], [298, [235, 167, 21]], [311, [230, 71, 39]], [328, [88, 27, 67]]];
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScaleFromSegments"](bounds, segments, resolution);
});

/***/ }),

/***/ "./public/js/palette/wind.js":
/*!***********************************!*\
  !*** ./public/js/palette/wind.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./palette */ "./public/js/palette/palette.js");



/* harmony default export */ __webpack_exports__["default"] = (function () {
  var resolution = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;
  var bounds = [0, 100]; // units: m/s

  var array = new Uint8Array(resolution * 4);
  _palette__WEBPACK_IMPORTED_MODULE_0__["fillRange"](array, [0, 1], [0, 1], _palette__WEBPACK_IMPORTED_MODULE_0__["extendedSinebowColor"]);
  return _palette__WEBPACK_IMPORTED_MODULE_0__["buildScale"](bounds, array);
});

/***/ }),

/***/ "./public/js/polyfills.js":
/*!********************************!*\
  !*** ./public/js/polyfills.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var setimmediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
/* harmony import */ var setimmediate__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(setimmediate__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var promise_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! promise-polyfill */ "./node_modules/promise-polyfill/src/index.js");
/*
 * polyfills: polyfill global object with missing ES6+ features.
 */





if (!global.Promise) {
  global.Promise = promise_polyfill__WEBPACK_IMPORTED_MODULE_1__["default"];
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./public/js/product/flatProduct.js":
/*!******************************************!*\
  !*** ./public/js/product/flatProduct.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ "./public/js/math.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./public/js/utc.mjs");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../grid/regular */ "./public/js/grid/regular.js");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/nearest */ "./public/js/interpolate/nearest.js");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interpolate/bilinear */ "./public/js/interpolate/bilinear.js");
/* harmony import */ var _decoder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../decoder */ "./public/js/decoder.mjs");
/**
 * Processes a bundle using earth.nullschool.net/flat-1.0 conventions.
 */









/*
Example:

{
  "Conventions": "earth.nullschool.net/flat-1.0",
  "title": "Probability of Visible Aurora",
  "institution": "SWPC / NCEP / NWS / NOAA",
  "source": "OVATION Aurora Short Term Forecast",
  "references": "http://www.swpc.noaa.gov/products/aurora-30-minute-forecast",
  "units": "%",
  "date": "2018-01-29T14:10Z",
  "init": "2018-01-29T13:40Z",
  "lon": {
    "start": -180,
    "delta": 0.3515625,
    "size": 1024
  },
  "lat": {
    "start": -89.82421875,
    "delta": 0.3515625,
    "size": 512
  },
  "encoding": {"type": "packed_delta_rle"},
  "data": [
    [[0,1024]]
  ]
}

*/

/* harmony default export */ __webpack_exports__["default"] = (function (bundle) {
  var conventions = bundle.Conventions,
      title = bundle.title,
      institution = bundle.institution,
      source = bundle.source,
      references = bundle.references,
      units = bundle.units,
      _date = bundle.date,
      init = bundle.init,
      encoding = bundle.encoding;

  if (conventions !== "earth.nullschool.net/flat-1.0") {
    throw new Error("Unsupported data conventions: ".concat(underscore__WEBPACK_IMPORTED_MODULE_2__["escape"](conventions)));
  } // Protect against malicious values.


  var lon = {
    start: +bundle.lon.start,
    delta: +bundle.lon.delta,
    size: Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(+bundle.lon.size, 0, 8192)
  };
  var lat = {
    start: +bundle.lat.start,
    delta: +bundle.lat.delta,
    size: Object(_math__WEBPACK_IMPORTED_MODULE_0__["clamp"])(+bundle.lat.size, 0, 8192)
  };
  var rows = Array.isArray(bundle.data) ? bundle.data : [];

  var decodeRow = function decodeRow(row) {
    return row;
  };

  if (encoding) {
    switch (encoding.type) {
      case "packed_delta_rle":
        var _encoding$scale_facto = encoding.scale_factor,
            scale_factor = _encoding$scale_facto === void 0 ? 1 : _encoding$scale_facto,
            _encoding$add_offset = encoding.add_offset,
            add_offset = _encoding$add_offset === void 0 ? 0 : _encoding$add_offset;

        decodeRow = function decodeRow(row) {
          return _decoder__WEBPACK_IMPORTED_MODULE_6__["decodePackedDeltaRle"](row, +scale_factor, +add_offset, lon.size);
        };

        break;

      default:
        throw new Error("Unsupported encoding: ".concat(underscore__WEBPACK_IMPORTED_MODULE_2__["escape"](encoding.type)));
    }
  }

  var data = new Float32Array(lon.size * lat.size);
  var i = 0;
  rows.filter(Array.isArray).forEach(function (row) {
    var decoded = decodeRow(row);
    data.set(decoded, i);
    i += decoded.length;
  });

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_3__["default"])(lon, lat);

  var interpolators = {
    type: "scalar",
    valueAt: function valueAt(i) {
      return data[i];
    },
    nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__["scalar"](_grid, data),
    bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__["scalar"](_grid, data)
  };
  return {
    sourceHTML: underscore__WEBPACK_IMPORTED_MODULE_2__["escape"](source),
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](_date);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return interpolators;
    },
    interpolate: function interpolate(coord) {
      return interpolators.bilinear(coord);
    }
  };
});

/***/ }),

/***/ "./public/js/product/gfs-wind.js":
/*!***************************************!*\
  !*** ./public/js/product/gfs-wind.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./public/js/utc.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grid/regular */ "./public/js/grid/regular.js");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interpolate/nearest */ "./public/js/interpolate/nearest.js");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/bilinear */ "./public/js/interpolate/bilinear.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./public/js/product/util.js");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./strings */ "./public/js/product/strings.js");









/* harmony default export */ __webpack_exports__["default"] = (function (file) {
  if (Array.isArray(file)) {
    file = _util__WEBPACK_IMPORTED_MODULE_5__["munge"](file, ["u", "v"], ["time", "level", "lat", "lon"]);
  }

  var epak = file,
      header = epak.header,
      vars = header.variables;
  var u = vars["U"] || vars["u"] || vars["u-component_of_wind_isobaric"] || vars["u-component_of_wind_height_above_ground"];
  var v = vars["V"] || vars["v"] || vars["v-component_of_wind_isobaric"] || vars["v-component_of_wind_height_above_ground"]; // dims are: time,level,lat,lon

  var time = vars[u.dimensions[0]];
  var lat = vars[u.dimensions[2]];
  var lon = vars[u.dimensions[3]];
  var data = _micro__WEBPACK_IMPORTED_MODULE_0__["merge"](epak.blocks[u.data.block], epak.blocks[v.data.block]);

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_2__["default"])(lon.sequence, lat.sequence);

  var defaultInterpolator = _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data);
  return {
    sourceHTML: _strings__WEBPACK_IMPORTED_MODULE_6__["gfs"],
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return {
        type: "vector",
        valueAt: function valueAt(i) {
          var j = i * 2;
          var u = data[j];
          var v = data[j + 1];
          return [u, v, Math.sqrt(u * u + v * v)];
        },
        nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__["vector"](_grid, data),
        bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data)
      };
    },
    interpolate: function interpolate(coord) {
      return defaultInterpolator(coord);
    }
  };
});

/***/ }),

/***/ "./public/js/product/gfs-wpd.js":
/*!**************************************!*\
  !*** ./public/js/product/gfs-wpd.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _gfs_wind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gfs-wind */ "./public/js/product/gfs-wind.js");
/* harmony import */ var _scalarProduct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scalarProduct */ "./public/js/product/scalarProduct.js");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strings */ "./public/js/product/strings.js");






/* harmony default export */ __webpack_exports__["default"] = (function (windFile, airdensFile) {
  var windGrid = Object(_gfs_wind__WEBPACK_IMPORTED_MODULE_1__["default"])(windFile);
  var airdensGrid = Object(_scalarProduct__WEBPACK_IMPORTED_MODULE_2__["default"])(airdensFile, /air_density/, _strings__WEBPACK_IMPORTED_MODULE_3__["gfs"], ["air_density"]);
  var windValueAt = windGrid.field().valueAt;
  var windNearest = windGrid.field().nearest;
  var windBilinear = windGrid.field().bilinear;
  var airdensValueAt = airdensGrid.field().valueAt;
  var airdensNearest = airdensGrid.field().nearest;
  var airdensBilinear = airdensGrid.field().bilinear;

  function wpd(wind, ρ) {
    var m = wind[2];
    return 0.5 * ρ * m * m * m;
  }

  function valueAt(i) {
    return wpd(windValueAt(i), airdensValueAt(i));
  }

  function nearest(coord) {
    return wpd(windNearest(coord), airdensNearest(coord));
  }

  function bilinear(coord) {
    return wpd(windBilinear(coord), airdensBilinear(coord));
  }

  return underscore__WEBPACK_IMPORTED_MODULE_0__["extend"](airdensGrid, {
    field: function field() {
      return {
        type: "scalar",
        valueAt: valueAt,
        nearest: nearest,
        bilinear: bilinear
      };
    },
    interpolate: function interpolate(coord) {
      return bilinear(coord);
    }
  });
});

/***/ }),

/***/ "./public/js/product/oscar.js":
/*!************************************!*\
  !*** ./public/js/product/oscar.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./public/js/utc.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grid/regular */ "./public/js/grid/regular.js");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interpolate/nearest */ "./public/js/interpolate/nearest.js");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/bilinear */ "./public/js/interpolate/bilinear.js");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./strings */ "./public/js/product/strings.js");








/* harmony default export */ __webpack_exports__["default"] = (function (file) {
  var epak = file,
      header = epak.header,
      vars = header.variables;
  var u = vars["u"];
  var v = vars["v"]; // dims are: time,depth,lat,lon

  var time = vars[u.dimensions[0]];
  var lat = vars[u.dimensions[2]];
  var lon = vars[u.dimensions[3]];
  var data = _micro__WEBPACK_IMPORTED_MODULE_0__["merge"](epak.blocks[u.data.block], epak.blocks[v.data.block]);

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_2__["default"])(lon.sequence, lat.sequence);

  var defaultInterpolator = _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data);
  return {
    sourceHTML: _strings__WEBPACK_IMPORTED_MODULE_5__["oscar"],
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return {
        type: "vector",
        valueAt: function valueAt(i) {
          var j = i * 2;
          var u = data[j];
          var v = data[j + 1];
          return [u, v, Math.sqrt(u * u + v * v)];
        },
        nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__["vector"](_grid, data),
        bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data)
      };
    },
    interpolate: function interpolate(coord) {
      return defaultInterpolator(coord);
    }
  };
});

/***/ }),

/***/ "./public/js/product/scalarProduct.js":
/*!********************************************!*\
  !*** ./public/js/product/scalarProduct.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./public/js/utc.mjs");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./public/js/product/util.js");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../grid/regular */ "./public/js/grid/regular.js");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/nearest */ "./public/js/interpolate/nearest.js");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../interpolate/bilinear */ "./public/js/interpolate/bilinear.js");








/* harmony default export */ __webpack_exports__["default"] = (function (bundle, selector, centerName, keys, transform) {
  // Assumes dimension structure of: [time, ..., lat, lon]
  if (Array.isArray(bundle)) {
    bundle = _util__WEBPACK_IMPORTED_MODULE_2__["munge"](bundle, keys);
  }

  if (!bundle.blocks) {
    bundle = _util__WEBPACK_IMPORTED_MODULE_2__["blockify"](bundle, selector);
  }

  var epak = bundle,
      header = epak.header,
      vars = header.variables;

  var x = underscore__WEBPACK_IMPORTED_MODULE_0__["find"](underscore__WEBPACK_IMPORTED_MODULE_0__["keys"](vars), function (e) {
    return selector.test(e);
  });

  var target = vars[x];
  var dims = target.dimensions;
  var time = vars[dims[0]];

  var lat = vars[underscore__WEBPACK_IMPORTED_MODULE_0__["last"](dims, 2)[0]];

  var lon = vars[underscore__WEBPACK_IMPORTED_MODULE_0__["last"](dims, 2)[1]];

  var data = epak.blocks[target.data.block];

  if (underscore__WEBPACK_IMPORTED_MODULE_0__["isFunction"](transform)) {
    transform(data);
  }

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_3__["default"])(lon.sequence, lat.sequence);

  var interpolators = {
    type: "scalar",
    valueAt: function valueAt(i) {
      return data[i];
    },
    nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_4__["scalar"](_grid, data),
    bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_5__["scalar"](_grid, data)
  };
  return {
    sourceHTML: centerName,
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return interpolators;
    },
    interpolate: function interpolate(coord) {
      return interpolators.bilinear(coord);
    }
  };
});

/***/ }),

/***/ "./public/js/product/strings.js":
/*!**************************************!*\
  !*** ./public/js/product/strings.js ***!
  \**************************************/
/*! exports provided: argo, cams, geos, geosAdjustedCO2, gfs, hrrr, oscar, ovation, rtgsst, ww3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argo", function() { return argo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cams", function() { return cams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geos", function() { return geos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geosAdjustedCO2", function() { return geosAdjustedCO2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gfs", function() { return gfs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hrrr", function() { return hrrr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oscar", function() { return oscar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ovation", function() { return ovation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rtgsst", function() { return rtgsst; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ww3", function() { return ww3; });
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../micro */ "./public/js/micro.mjs");



var co2Link = _micro__WEBPACK_IMPORTED_MODULE_0__["isKioskMode"]() ? "" : " [<a href='about.html#co2' class='internal-link'>important note</a>]";
var argo = "Argo";
var cams = "CAMS / Copernicus / EC + ECMWF";
var geos = "GEOS-5 / GMAO / NASA";
var geosAdjustedCO2 = "GEOS-5 / GMAO / NASA" + co2Link;
var gfs = "GFS / NCEP / US National Weather Service";
var hrrr = "HRRR / NCEP / US National Weather Service";
var oscar = "OSCAR / Earth & Space Research";
var ovation = "OVATION / SWPC / NCEP / NWS / NOAA";
var rtgsst = "RTG-SST / NCEP / US National Weather Service";
var ww3 = "WAVEWATCH III / NCEP / NWS";

/***/ }),

/***/ "./public/js/product/util.js":
/*!***********************************!*\
  !*** ./public/js/product/util.js ***!
  \***********************************/
/*! exports provided: munge, blockify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "munge", function() { return munge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blockify", function() { return blockify; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./public/js/utc.mjs");




/**
 * Makes an old-style grib2json file look like an epak file
 *
 * @param {Array} records the grib2json payload.
 * @param {string[]} varNames the variable names associated with the grib2json records.
 * @param {string[]?} dimensions the dimensions to inject the header, or ["time", "lat", "lon"] by default.
 * @returns {Object} an epak-like structure.
 */

function munge(records, varNames, dimensions) {
  var header = records[0].header;
  var validTime = _utc__WEBPACK_IMPORTED_MODULE_1__["add"](_utc__WEBPACK_IMPORTED_MODULE_1__["parts"](header.refTime), {
    hour: header.forecastTime
  });
  var variables = {
    time: {
      data: [_utc__WEBPACK_IMPORTED_MODULE_1__["printISO"](validTime)]
    },
    lat: {
      sequence: {
        start: header.la1,
        delta: -header.dy,
        size: header.ny
      }
    },
    lon: {
      sequence: {
        start: header.lo1,
        delta: header.dx,
        size: header.nx
      }
    }
  };
  var blocks = [];
  varNames.forEach(function (key, i) {
    variables[key] = {
      dimensions: dimensions || ["time", "lat", "lon"],
      data: {
        block: i
      }
    };
    blocks[i] = new Float32Array(records[i].data);
  });
  return {
    header: {
      variables: variables
    },
    blocks: blocks
  };
}
/**
 * Some early epaks did not use binary blocks, so convert them into the expected form.
 */

function blockify(epak, selector) {
  var variables = epak.variables;
  var blocks = [];

  underscore__WEBPACK_IMPORTED_MODULE_0__["keys"](variables).forEach(function (key) {
    if (selector.test(key)) {
      var v = variables[key];
      blocks.push(new Float32Array(v.data));
      v.data = {
        block: blocks.length - 1
      };
    }
  });

  return {
    header: epak,
    blocks: blocks
  };
}

/***/ }),

/***/ "./public/js/product/ww3-primary.js":
/*!******************************************!*\
  !*** ./public/js/product/ww3-primary.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./public/js/consts.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utc */ "./public/js/utc.mjs");
/* harmony import */ var _grid_regular__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../grid/regular */ "./public/js/grid/regular.js");
/* harmony import */ var _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interpolate/nearest */ "./public/js/interpolate/nearest.js");
/* harmony import */ var _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interpolate/bilinear */ "./public/js/interpolate/bilinear.js");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./strings */ "./public/js/product/strings.js");








/* harmony default export */ __webpack_exports__["default"] = (function (file) {
  var epak = file,
      header = epak.header,
      vars = header.variables;
  var direction = vars["Primary_wave_direction_surface"];
  var period = vars["Primary_wave_mean_period_surface"]; // dims are: time,lat,lon

  var time = vars[direction.dimensions[0]];
  var lat = vars[direction.dimensions[1]];
  var lon = vars[direction.dimensions[2]];
  var dirData = epak.blocks[direction.data.block];
  var perData = epak.blocks[period.data.block];
  var data = new Float32Array(dirData.length * 2);

  for (var i = 0; i < dirData.length; i++) {
    var j = i * 2;
    var φ = dirData[i] * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"]; // wave direction in radians

    var m = perData[i]; // wave period (treated as velocity)

    if (φ < 7e37 && m < 7e37) {
      data[j] = -m * Math.sin(φ);
      data[j + 1] = -m * Math.cos(φ);
    } else {
      data[j] = data[j + 1] = 7e37;
    }
  }

  var _grid = Object(_grid_regular__WEBPACK_IMPORTED_MODULE_2__["default"])(lon.sequence, lat.sequence);

  var defaultInterpolator = _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data);
  return {
    sourceHTML: _strings__WEBPACK_IMPORTED_MODULE_5__["ww3"],
    date: function date() {
      return _utc__WEBPACK_IMPORTED_MODULE_1__["parts"](time.data[0]);
    },
    grid: function grid() {
      return _grid;
    },
    field: function field() {
      return {
        type: "vector",
        valueAt: function valueAt(i) {
          var j = i * 2;
          var u = data[j];
          var v = data[j + 1];
          return [u, v, Math.sqrt(u * u + v * v)];
        },
        nearest: _interpolate_nearest__WEBPACK_IMPORTED_MODULE_3__["vector"](_grid, data),
        bilinear: _interpolate_bilinear__WEBPACK_IMPORTED_MODULE_4__["vector"](_grid, data)
      };
    },
    interpolate: function interpolate(coord) {
      return defaultInterpolator(coord);
    }
  };
});

/***/ }),

/***/ "./public/js/products.js":
/*!*******************************!*\
  !*** ./public/js/products.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(underscore__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _d3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./d3 */ "./public/js/d3.mjs");
/* harmony import */ var _micro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./micro */ "./public/js/micro.mjs");
/* harmony import */ var _utc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utc */ "./public/js/utc.mjs");
/* harmony import */ var _clock__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clock */ "./public/js/clock.js");
/* harmony import */ var _product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./product/scalarProduct */ "./public/js/product/scalarProduct.js");
/* harmony import */ var _product_flatProduct__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./product/flatProduct */ "./public/js/product/flatProduct.js");
/* harmony import */ var _product_strings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./product/strings */ "./public/js/product/strings.js");
/* harmony import */ var _palette_palette__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./palette/palette */ "./public/js/palette/palette.js");
/* harmony import */ var _product_oscar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./product/oscar */ "./public/js/product/oscar.js");
/* harmony import */ var _product_ww3_primary__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./product/ww3-primary */ "./public/js/product/ww3-primary.js");
/* harmony import */ var _product_gfs_wind__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./product/gfs-wind */ "./public/js/product/gfs-wind.js");
/* harmony import */ var _product_gfs_wpd__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./product/gfs-wpd */ "./public/js/product/gfs-wpd.js");
/* harmony import */ var _palette_aurora__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./palette/aurora */ "./public/js/palette/aurora.js");
/* harmony import */ var _palette_cape__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./palette/cape */ "./public/js/palette/cape.js");
/* harmony import */ var _palette_co2__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./palette/co2 */ "./public/js/palette/co2.js");
/* harmony import */ var _palette_co2sc__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./palette/co2sc */ "./public/js/palette/co2sc.js");
/* harmony import */ var _palette_cosc__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./palette/cosc */ "./public/js/palette/cosc.js");
/* harmony import */ var _palette_duexttau__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./palette/duexttau */ "./public/js/palette/duexttau.js");
/* harmony import */ var _palette_pmx__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./palette/pmx */ "./public/js/palette/pmx.js");
/* harmony import */ var _palette_precip__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./palette/precip */ "./public/js/palette/precip.js");
/* harmony import */ var _palette_so2smass__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./palette/so2smass */ "./public/js/palette/so2smass.js");
/* harmony import */ var _palette_suexttau__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./palette/suexttau */ "./public/js/palette/suexttau.js");
/* harmony import */ var _palette_temp__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./palette/temp */ "./public/js/palette/temp.js");
/* harmony import */ var _palette_wind__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./palette/wind */ "./public/js/palette/wind.js");
/**
 * products - defines the behavior of weather data grids, including grid construction, interpolation, and color scales.
 *
 * Copyright (c) 2018 Cameron Beccario
 *
 * For a free version of this project, see https://github.com/cambecc/earth
 */



























/* harmony default export */ __webpack_exports__["default"] = (function (app) {
  var products = {};
  var CUTOFF = new Date("2016-02-20");

  function gaia(path) {
	return "." + path; //MAL added: return "." + path;
    var host = _micro__WEBPACK_IMPORTED_MODULE_2__["isDevMode"]() ? "" : "https://earth-ae.github.io",
        url = host + path,
        instance = _micro__WEBPACK_IMPORTED_MODULE_2__["siteInstance"]();
    return instance ? url + "?" + instance : url;
  }

  function old(path) {
    return "https://earth-ae.github.io" + path;
  }

  products.gaia = gaia;

  function geosUrl(path, date) {
    return date < CUTOFF ? old("/data/geos/" + path) : gaia("/data/geos/" + path);
  }

  function gfsUrl(path, date) {
    return date < CUTOFF ? old("/data/weather/" + path) : gaia("/data/gfs/" + path);
  }

  function oscarUrl(path) {
    return gaia("/data/oscar/" + path);
  }

  function rtgsstUrl(path, date) {
    return date < CUTOFF ? old("/data/ocean/" + path) : gaia("/data/rtgsst/" + path);
  }

  function ww3Url(path, date) {
    return date < CUTOFF ? old("/data/ocean/" + path) : gaia("/data/ww3/" + path);
  }

  function argoUrl(path) {
    return gaia("/data/argo/" + path);
  }

  var aotLink = _micro__WEBPACK_IMPORTED_MODULE_2__["isKioskMode"]() ? "" : "(<a href='about.html#aot' class='internal-link'>AOT</a>)";

  function buildProduct(overrides) {
    return underscore__WEBPACK_IMPORTED_MODULE_0__["extend"]({
      descriptionHTML: "",
      paths: [],

      /** @returns {Object} the product's date parts. */
      date: function date() {
        return null;
      },

      /**
       * @param {number} step the number of steps away: ±1 or ±10
       * @returns {Object} the date parts for the specified number of steps away from this product's date.
       */
      navigate: function navigate(step) {
        return gfsStep(this.date(), step);
      },

      /**
       * @param {Object} date the desired date parts or the string "current".
       * @returns {Object} the actual date parts.
       */
      navigateTo: function navigateTo(date) {
        return gfsDate(date);
      },
      loader: function loader(path) {
        return /\.epak([/?#]|$)/.test(path) ? _micro__WEBPACK_IMPORTED_MODULE_2__["loadEpak"](path) : _micro__WEBPACK_IMPORTED_MODULE_2__["loadJson"](path);
      },
      load: function load(cancel) {
        var me = this;
        return Promise.all(this.paths.map(this.loader)).then(function (files) {
          return cancel.requested ? null : underscore__WEBPACK_IMPORTED_MODULE_0__["extend"](me, me.builder.apply(me, files));
        });
      },
      alpha: {
        single: 160,
        animated: 112
      }
    }, overrides);
  }
  /**
   * @param {Object} date either the date parts or the string "current"
   * @param {Object?} offset the time offset from the normal GFS time (e.g., {minute: 90} for 3hr time avg)
   * @returns {Object} the best matching date parts.
   */


  function gfsDate(date, offset) {
    var parts = date === "current" ? underscore__WEBPACK_IMPORTED_MODULE_0__["pick"](_utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()), "year", "month", "day", "hour") : // use current time
    underscore__WEBPACK_IMPORTED_MODULE_0__["clone"](date); // round down to the nearest three-hour block

    parts.hour = Math.floor(parts.hour / 3) * 3;
    parts.minute = 0;

    if (offset) {
      parts = _utc__WEBPACK_IMPORTED_MODULE_3__["normalize"](_utc__WEBPACK_IMPORTED_MODULE_3__["add"](parts, offset));
    }

    return parts;
  }
  /**
   * Returns date parts for the chronologically next or previous GFS data layer. How far forward or backward in time
   * to jump is determined by the step. Steps of ±1 move in 3-hour jumps, and steps of ±10 move in 24-hour jumps.
   *
   * @param {Object} date the starting date parts.
   * @param {number} step the number of steps.
   * @returns {Object} the resulting date parts.
   */


  function gfsStep(date, step) {
    var offset = (step > 1 ? 8 : step < -1 ? -8 : step) * 3;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      hour: offset
    });
  }

  function gfsPathParts(attr, offset) {
    if (attr.date === "current") {
      return {
        dir: "current",
        stamp: "current",
        date: gfsDate(attr.date, offset)
      };
    }

    var date = gfsDate(attr.date, offset);
    return {
      dir: _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}/{MM}/{dd}"),
      stamp: _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{hh}{mm}"),
      date: date
    };
  }
  /**
   * @param attr
   * @param {String} type
   * @param {String?} surface
   * @param {String?} level
   * @returns {String}
   */


  function gfsPath(attr, type, surface, level) {
    var parts = gfsPathParts(attr),
        date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](parts.date);
    var format = date >= new Date("2014/11/24") ? ".epak" : ".json";
    var res = "0.5";

    if (date < new Date("2015/03/11") || _micro__WEBPACK_IMPORTED_MODULE_2__["isEmbeddedInIFrame"]() && !_micro__WEBPACK_IMPORTED_MODULE_2__["isKioskMode"]()) {
      res = "1.0";
    } else if (date > new Date("2016/06/22") && attr.hd) {
      res = "0.25";
    }

    var file = [parts.stamp, type, surface, level, "gfs", res].filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isValue"]).join("-") + format;
    return gfsUrl(parts.dir + "/" + file, date);
  }
  /*
      function hrrrDate(date, offset) {
          const parts = date === "current" ?
              _.pick(utc.parts(clock.now()), "year", "month", "day", "hour") :  // use current time
              _.clone(date);
          // round down to the nearest 15-minute block
          parts.hour = Math.floor(parts.hour);
          parts.minute = Math.floor((parts.minute | 0) / 15) * 15;
          console.log("hrrrDate", parts);
          if (offset) {
              parts = utc.normalize(utc.add(parts, offset));
          }
          return parts;
      }

      function hrrrStep(date, step) {
          const offset = (step > 1 ? 8 : step < -1 ? -8 : step) * 15;
          console.log(date, offset, utc.add(date, {minute: offset}));

          return utc.add(date, {minute: offset});
      }

      function hrrrPath(attr, type, surface, level) {
          const date = hrrrDate(attr.date), isCurrent = attr.date === "current";
          const dir = isCurrent ? "current" : utc.print(date, "{yyyy}/{MM}/{dd}");
          const stamp = isCurrent ? "current" : utc.print(date, "{hh}{mm}");
          const file = [stamp, type, surface, level, "hrrr"].filter(e=>e).join("-");
          return gaia(`/data/hrrr/${dir}/${file}.epak`);
      }
  */


  function geosPath(attr, type, offset) {
    var parts = gfsPathParts(attr, offset),
        date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](parts.date);
    var file = [parts.stamp, type, "geos.epak"].join("-");
    return geosUrl(parts.dir + "/" + file, date);
  }

  function camsDate(date, stride) {
    var _ref = date === "current" ? _utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()) : date,
        year = _ref.year,
        month = _ref.month,
        day = _ref.day,
        hour = _ref.hour;

    return {
      year: year,
      month: month,
      day: day,
      hour: Math.floor(hour / stride) * stride,
      minute: 0
    };
  }

  function camsStep(date, stride, step) {
    var offset = (step > 1 ? 8 : step < -1 ? -8 : step) * stride;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      hour: offset
    });
  }

  function camsPath(attr, param, stride) {
    var date = camsDate(attr.date, stride),
        isCurrent = attr.date === "current";
    var dir = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}/{MM}/{dd}");
    var stamp = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{hh}{mm}");
    return gaia("/data/cams/".concat(dir, "/").concat(stamp, "-").concat(param, "-cams.epak"));
  }

  function wave30mPath(attr, type, surface, level) {
    var parts = gfsPathParts(attr),
        date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](parts.date);
    var file = [parts.stamp, type, surface, level, "wave", "30m"].filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isValue"]).join("-") + ".epak";
    return ww3Url(parts.dir + "/" + file, date);
  }
  /**
   * Returns the file name for the most recent OSCAR data layer to the specified date. If offset is non-zero,
   * the file name that many entries from the most recent is returned.
   *
   * The result is undefined if there is no entry for the specified date and offset can be found.
   *
   * UNDONE: the catalog object itself should encapsulate this logic. GFS can also be a "virtual" catalog, and
   *         provide a mechanism for eliminating the need for /data/weather/current/* files.
   *
   * @param {Array} catalog array of file names, sorted and prefixed with yyyyMMdd. Last item is most recent.
   * @param {Object} date parts or "current"
   * @param {Number?} offset
   * @returns {String} file name
   */


  function lookupOscar(catalog, date, offset) {
    offset = +offset || 0;

    if (date === "current") {
      return catalog[catalog.length - 1 + offset];
    }

    var prefix = _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}{MM}{dd}");

    var i = underscore__WEBPACK_IMPORTED_MODULE_0__["sortedIndex"](catalog, prefix);

    i = (catalog[i] || "").indexOf(prefix) === 0 ? i : i - 1;
    return catalog[i + offset];
  }
  /**
   * @param catalog
   * @param date the date parts
   * @returns {Object} date parts
   */


  function oscarDate(catalog, date) {
    var file = lookupOscar(catalog, date);
    return file ? _utc__WEBPACK_IMPORTED_MODULE_3__["parse"](file, /(\d{4})(\d\d)(\d\d)/) : null;
  }
  /**
   * @param {Array} catalog array of file names, sorted and prefixed with yyyyMMdd. Last item is most recent.
   * @param {Object} date parts or the string "current".
   * @param {number} step
   * @returns {Object} the chronologically next or previous OSCAR data layer. How far forward or backward in
   * time to jump is determined by the step and the catalog of available layers. A step of ±1 moves to the
   * next/previous entry in the catalog (about 5 days), and a step of ±10 moves to the entry six positions away
   * (about 30 days).
   */


  function oscarStep(catalog, date, step) {
    var file = lookupOscar(catalog, date, step > 1 ? 6 : step < -1 ? -6 : step);
    return file ? _utc__WEBPACK_IMPORTED_MODULE_3__["parse"](file, /(\d{4})(\d\d)(\d\d)/) : null;
  }

  function oscarPath(catalog, attr) {
    var file = lookupOscar(catalog, attr.date);
    return file ? oscarUrl(file) : null;
  }

  function fetchOscarCatalog() {
    // The OSCAR catalog is an array of file names, sorted and prefixed with yyyyMMdd. Last item is the
    // most recent. For example: [ 20140101-abc.epak, 20140106-abc.epak, 20140112-abc.epak, ... ]
    return _micro__WEBPACK_IMPORTED_MODULE_2__["loadJsonOnce"](oscarUrl("oscar-catalog.json"));
  }

  function rtgDate(date) {
    var parts;

    if (date === "current") {
      // Each day, SST data for the previous day is made available. So "current" means yesterday.
      var now = underscore__WEBPACK_IMPORTED_MODULE_0__["pick"](_utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()), "year", "month", "day");

      parts = _utc__WEBPACK_IMPORTED_MODULE_3__["add"](now, {
        day: -1
      });
    } else {
      parts = underscore__WEBPACK_IMPORTED_MODULE_0__["clone"](date);
    }

    return parts;
  }
  /**
   * Returns a date for the chronologically next or previous RTG SST data layer. How far forward or backward in time
   * to jump is determined by the step. Steps of ±1 move in 1 day jumps, and steps of ±10 move in 5-day jumps.
   */


  function rtgStep(date, step) {
    var offset = step > 1 ? 5 : step < -1 ? -5 : step;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      day: offset
    });
  }
  /**
   * @param attr
   * @param {String} type
   * @param {String?} surface
   * @param {String?} level
   * @returns {String}
   */


  function rtgPath(attr, type, surface, level) {
    var date = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](rtgDate(attr.date));
    var dir = attr.date === "current" ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](attr.date, "{yyyy}/{MM}");
    var stamp = dir === "current" ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](attr.date, "{yyyy}{MM}{dd}");
    var file = [stamp, type, surface, level, "rtg", "0.5"].filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isValue"]).join("-") + ".epak";
    return rtgsstUrl(dir + "/" + file, date);
  }

  function ovationDate(date) {
    var _ref2 = date === "current" ? _utc__WEBPACK_IMPORTED_MODULE_3__["parts"](_clock__WEBPACK_IMPORTED_MODULE_4__["now"]()) : date,
        year = _ref2.year,
        month = _ref2.month,
        day = _ref2.day,
        hour = _ref2.hour,
        minute = _ref2.minute;

    return {
      year: year,
      month: month,
      day: day,
      hour: hour,
      minute: Math.floor(minute / 5) * 5
    };
  }

  function ovationStep(date, step) {
    var offset = step > 1 ? 12 : step < -1 ? -12 : step;
    return _utc__WEBPACK_IMPORTED_MODULE_3__["normalize"](_utc__WEBPACK_IMPORTED_MODULE_3__["add"](date, {
      minute: offset * 5
    }));
  }

  function ovationPath(attr) {
    var date = ovationDate(attr.date),
        isCurrent = attr.date === "current";
    var dir = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}/{MM}/{dd}");
    var stamp = isCurrent ? "current" : _utc__WEBPACK_IMPORTED_MODULE_3__["print"](date, "{yyyy}{MM}{dd}{hh}{mm}");
    return gaia("/data/ovation/".concat(dir, "/").concat(stamp, "-ovation.json"));
  }
  /*
      /!**
       * @param {Object} date the date parts or the string "current"
       * @returns {Object} the actual date parts
       *!/
      function argoDate(date) {
          const parts = date === "current" ?
              _.pick(utc.parts(clock.now()), "year", "month") :  // use current time
              _.clone(date);
          return utc.normalize(parts);
      }

      /!**
       * @param {Object} date the date parts
       * @param {number} step the number of steps away: ±1 or ±10
       *!/
      function argoStep(date, step) {
          return utc.add(date, {month: step < 0 ? -1 : 1});
      }

      function argoPath(date, type, pressureLevel) {
          date = argoDate(date);
          const dir = "https://data.scripps.earth/argo/" + utc.print(date, "{yyyy}/");
          // const dir = "/data/argo/" + utc.print(date, "{yyyy}/");
          const file = ["argo", utc.print(date, "{yyyy}{MM}"), type, pressureLevel, "1p0"].join("-") + ".json";
          return dir + file;
      }
  */


  function describeSurface(attr) {
    return attr.surface === "surface" ? "Surface" : _micro__WEBPACK_IMPORTED_MODULE_2__["capitalize"](attr.level);
  }

  function describeSurfaceJa(attr) {
    return attr.surface === "surface" ? "地上" : _micro__WEBPACK_IMPORTED_MODULE_2__["capitalize"](attr.level);
  }
  /**
   * Returns a function f(langCode) that, given table:
   *     {foo: {en: "A", ja: "あ"}, bar: {en: "I", ja: "い"}}
   * will return the following when called with "en":
   *     {foo: "A", bar: "I"}
   * or when called with "ja":
   *     {foo: "あ", bar: "い"}
   */


  function localize(table) {
    return function (langCode) {
      var result = {};

      underscore__WEBPACK_IMPORTED_MODULE_0__["each"](table, function (value, key) {
        result[key] = value[langCode] || value.en || value;
      });

      return result;
    };
  }

  function localizeString(table) {
    return table[_micro__WEBPACK_IMPORTED_MODULE_2__["siteLangCode"]()] || table.en;
  }

  var FACTORIES = {
    "wind": {
      matchesPrimary: function matchesPrimary() {
        return true;
      },
      // HACK: default matcher, must comes first.
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "wind"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "wind",
          descriptionHTML: localize({
            name: {
              en: "Wind",
              ja: "風速"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: "＠" + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "wind", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_gfs_wind__WEBPACK_IMPORTED_MODULE_11__["default"])(file);
          },
          units: [{
            label: "km/h",
            conversion: function conversion(x) {
              return x * 3.6;
            },
            precision: 0
          }, {
            label: "m/s",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }, {
            label: "kn",
            conversion: function conversion(x) {
              return x * 1.943844;
            },
            precision: 0
          }, {
            label: "mph",
            conversion: function conversion(x) {
              return x * 2.236936;
            },
            precision: 0
          }],
          scale: Object(_palette_wind__WEBPACK_IMPORTED_MODULE_24__["default"])(),
          particles: {
            velocityScale: 1 / 100,
            maxIntensity: 15
          }
        });
      }
    },
    "temp": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "temp"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "temp",
          descriptionHTML: localize({
            name: {
              en: "Temp",
              ja: "気温"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "temp", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Temperature_isobaric", "Temperature_height_above_ground"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Temperature/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Temperature"]);
          },
          units: [{
            label: "°C",
            conversion: function conversion(x) {
              return x - 273.15;
            },
            precision: 1
          }, {
            label: "°F",
            conversion: function conversion(x) {
              return x * 9 / 5 - 459.67;
            },
            precision: 1
          }, {
            label: "K",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          scale: Object(_palette_temp__WEBPACK_IMPORTED_MODULE_23__["default"])()
        });
      }
    },
    "relative_humidity": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "relative_humidity"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "relative_humidity",
          descriptionHTML: localize({
            name: {
              en: "Relative Humidity",
              ja: "相対湿度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "relative_humidity", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Relative_humidity_isobaric", "Relative_humidity_height_above_ground"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Relative_humidity/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "%",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 100], [[0, [230, 165, 30]], [25, [120, 100, 95]], [60, [40, 44, 92]], [75, [21, 13, 193]], [90, [75, 63, 235]], [100, [25, 255, 255]]], 1000)
        });
      }
    },
    "air_density": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "air_density"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "air_density",
          descriptionHTML: localize({
            name: {
              en: "Air Density",
              ja: "空気密度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "air_density", attr.surface, attr.level)],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /air_density/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "kg/m³",
            conversion: function conversion(x) {
              return x;
            },
            precision: 2
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 1.5], [[0, [0, 0, 0]], [1.5, [255, 255, 255]]], 10)
        });
      }
    },
    "wind_power_density": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "wind_power_density"
      }),
      create: function create(attr) {
        var windProduct = FACTORIES.wind.create(attr);
        var airdensProduct = FACTORIES.air_density.create(attr);
        return buildProduct({
          type: "wind_power_density",
          descriptionHTML: localize({
            name: {
              en: "Instant Wind Power Density",
              ja: "風力エネルギー密度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [windProduct.paths[0], airdensProduct.paths[0]],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(windFile, airdensFile) {
            return Object(_product_gfs_wpd__WEBPACK_IMPORTED_MODULE_12__["default"])(windFile, airdensFile);
          },
          units: [{
            label: "kW/m<sup>2</sup>",
            tooltip: "kW/m²",
            conversion: function conversion(x) {
              return x / 1000;
            },
            precision: 1
          }, {
            label: "W/m<sup>2</sup>",
            tooltip: "W/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 80000], [[0, [15, 4, 96]], [250, [30, 8, 180]], [1000, [121, 102, 2]], [2000, [118, 161, 66]], [4000, [50, 102, 219]], [8000, [19, 131, 193]], [16000, [59, 204, 227]], [64000, [241, 1, 45]], [80000, [243, 0, 241]]], 10000) // CONSIDER: convert to log scale

        });
      }
    },
    "misery_index": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "misery_index"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "misery_index",
          descriptionHTML: localize({
            name: {
              en: "Misery (Wind Chill & Heat Index)",
              ja: "体感温度"
            },
            qualifier: {
              en: " @ " + describeSurface(attr),
              ja: " @ " + describeSurfaceJa(attr)
            }
          }),
          paths: [gfsPath(attr, "misery_index")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /misery_index/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: function () {
            var perceived = localizeString({
              en: " (feels like)",
              ja: "（体感温度）"
            });
            return [{
              label: "°C" + perceived,
              conversion: function conversion(x) {
                return x - 273.15;
              },
              precision: 1
            }, {
              label: "°F" + perceived,
              conversion: function conversion(x) {
                return x * 9 / 5 - 459.67;
              },
              precision: 1
            }, {
              label: "K" + perceived,
              conversion: function conversion(x) {
                return x;
              },
              precision: 1
            }];
          }(),
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([236, 332], [[241, [255, 255, 255]], // -32 C, -25 F extreme frostbite
          [245.5, [6, 82, 255]], [250, [6, 82, 255]], // -23 C, -10 F frostbite
          [258, [46, 131, 255]], [266, [46, 131, 255]], // -7 C, 20 F hypothermia
          [280, [0, 0, 0]], // 7 C, 45 F begin suckage (cold)
          [300, [0, 0, 0]], // 27 C, 80 F begin caution (heat)
          [305, [247, 20, 35]], // 32 C, 90 F extreme caution
          [309.5, [247, 20, 35]], [314, [245, 210, 5]], // 41 C, 105 F danger
          [320.5, [245, 210, 5]], [327, [255, 255, 255]] // 54 C, 130 F extreme danger
          ], 1000)
        });
      }
    },
    "total_cloud_water": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "total_cloud_water"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "total_cloud_water",
          descriptionHTML: localize({
            name: {
              en: "Total Cloud Water",
              ja: "雲水量"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "total_cloud_water")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Cloud_water_entire_atmosphere", "Cloud_water_entire_atmosphere_single_layer"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Cloud_water/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Cloud_water"]);
          },
          units: [{
            label: "kg/m<sup>2</sup>",
            tooltip: "kg/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 3
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 1], [[0.0, [5, 5, 89]], [0.2, [170, 170, 230]], [1.0, [255, 255, 255]]], 1000)
        });
      }
    },
    "total_precipitable_water": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "total_precipitable_water"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "total_precipitable_water",
          descriptionHTML: localize({
            name: {
              en: "Total Precipitable Water",
              ja: "可降水量"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "total_precipitable_water")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Precipitable_water_entire_atmosphere", "Precipitable_water_entire_atmosphere_single_layer"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Precipitable_water/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Precipitable_water"]);
          },
          units: [{
            label: "kg/m<sup>2</sup>",
            tooltip: "kg/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 3
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 70], [[0, [230, 165, 30]], [10, [120, 100, 95]], [20, [40, 44, 92]], [30, [21, 13, 193]], [40, [75, 63, 235]], [60, [25, 255, 255]], [70, [150, 255, 255]]], 1000)
        });
      }
    },
    "mean_sea_level_pressure": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "mean_sea_level_pressure"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "mean_sea_level_pressure",
          descriptionHTML: localize({
            name: {
              en: "Mean Sea Level Pressure",
              ja: "海面更正気圧"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "mean_sea_level_pressure")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // Pressure_reduced_to_MSL_msl
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Pressure_reduced_to_MSL/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"], ["Pressure_reduced_to_MSL"]);
          },
          units: [{
            label: "hPa",
            conversion: function conversion(x) {
              return x / 100;
            },
            precision: 0
          }, {
            label: "mmHg",
            conversion: function conversion(x) {
              return x / 133.322387415;
            },
            precision: 0
          }, {
            label: "inHg",
            conversion: function conversion(x) {
              return x / 3386.389;
            },
            precision: 1
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([92000, 105000], [[92000, [40, 0, 0]], [95000, [187, 60, 31]], [96500, [137, 32, 30]], [98000, [16, 1, 43]], [100500, [36, 1, 93]], [101300, [241, 254, 18]], [103000, [228, 246, 223]], [105000, [255, 255, 255]]], 1000)
        });
      }
    },
    "precip_3hr": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "precip_3hr"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "precip_3hr",
          descriptionHTML: localize({
            name: {
              en: "Next 3-hr Precip Accumulation",
              ja: "3時間の降水量"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "precip_3hr")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /precip_accumulation_3hr/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "mm",
            tooltip: "mm",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }, {
            label: "in",
            tooltip: "in",
            conversion: function conversion(x) {
              return x / 25.4;
            },
            precision: 2
          }, {
            label: "kg/m<sup>2</sup>",
            tooltip: "kg/m²",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          alpha: {
            single: 160,
            animated: 160
          },
          scale: Object(_palette_precip__WEBPACK_IMPORTED_MODULE_20__["default"])()
        });
      }
    },
    "cape": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "cape"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "cape",
          descriptionHTML: localize({
            name: {
              en: "CAPE (Surface)",
              ja: "対流有効位置エネルギー（地上）"
            },
            qualifier: ""
          }),
          paths: [gfsPath(attr, "cape")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Convective_available_potential_energy_surface/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["gfs"]);
          },
          units: [{
            label: "J/kg",
            tooltip: "J/kg",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_cape__WEBPACK_IMPORTED_MODULE_14__["default"])()
        });
      }
    },
    "co2": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "co2"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "co2",
          descriptionHTML: localize({
            name: {
              en: "Carbon Dioxide Mixing Ratio",
              ja: "二酸化炭素混合比"
            },
            qualifier: ""
          }),
          paths: [geosPath(attr, "co2")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /CO2CL/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// CO2 Bulk Mixing Ratio (Column Mass/ps), units: mol/mol
          // {label: "ppmv", conversion: function(x) { return x * 1e6; }, precision: 1},
          {
            label: "µmol/mol",
            conversion: function conversion(x) {
              return x * 1e6;
            },
            precision: 1
          }],
          alpha: {
            single: 160,
            animated: 160
          },
          scale: Object(_palette_co2__WEBPACK_IMPORTED_MODULE_15__["default"])()
        });
      }
    },
    "cosc": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "cosc"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "cosc",
          descriptionHTML: localize({
            name: {
              en: "Carbon Monoxide Conc.",
              ja: "一酸化炭素濃度"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [geosPath(attr, "cosc")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /COSC/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// CO Surface Concentration in ppbv, units: 1e-9
          {
            label: "ppbv",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }, {
            label: "ppmv",
            conversion: function conversion(x) {
              return x / 1000;
            },
            precision: 2
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_cosc__WEBPACK_IMPORTED_MODULE_17__["default"])()
        });
      }
    },
    "so2smass": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "so2smass"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "so2smass",
          descriptionHTML: localize({
            name: {
              en: "Sulfur Dioxide Mass",
              ja: "二酸化硫黄質量"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [geosPath(attr, "so2smass")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /SO2SMASS/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// SO2 Surface Mass Concentration, units: kg/m3
          {
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 2
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_so2smass__WEBPACK_IMPORTED_MODULE_21__["default"])()
        });
      }
    },
    "duexttau": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "duexttau"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "duexttau",
          descriptionHTML: localize({
            name: {
              en: "Dust Extinction " + aotLink,
              ja: "粒子消散係数 " + aotLink
            },
            qualifier: ""
          }),
          paths: [geosPath(attr, "duexttau")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /DUEXTTAU/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// Dust Extinction AOT (aerosol optical thickness) [550 nm], units: τ
          {
            label: "τ",
            conversion: function conversion(x) {
              return x;
            },
            precision: 4
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_duexttau__WEBPACK_IMPORTED_MODULE_18__["default"])()
        });
      }
    },
    "suexttau": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "suexttau"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "suexttau",
          descriptionHTML: localize({
            name: {
              en: "Sulfate Extinction " + aotLink,
              ja: "硫酸塩消散係数 " + aotLink
            },
            qualifier: ""
          }),
          paths: [geosPath(attr, "suexttau")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /SUEXTTAU/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"]);
          },
          units: [// SO4 Extinction AOT (aerosol optical thickness) [550 nm], units: τ
          {
            label: "τ",
            conversion: function conversion(x) {
              return x;
            },
            precision: 3
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_suexttau__WEBPACK_IMPORTED_MODULE_22__["default"])()
        });
      }
    },
    "co2sc": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "co2sc"
      }),
      create: function create(attr) {
        var _date = gfsDate(attr.date, {
          minute: 90
        });

        var cutoff = _utc__WEBPACK_IMPORTED_MODULE_3__["date"]({
          year: 2017,
          month: 1,
          day: 24,
          hour: 4,
          minute: 30
        });
        var adjustmentRequired = _utc__WEBPACK_IMPORTED_MODULE_3__["date"](_date) < cutoff; // old version of GEOS-5 needs CO2 offset

        var Δ = adjustmentRequired ? 32 : 0;
        return buildProduct({
          type: "co2sc",
          descriptionHTML: localize({
            name: {
              en: "Carbon Dioxide Concentration",
              ja: "二酸化炭素濃度"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [geosPath(attr, "co2sc", {
            minute: 90
          })],
          date: function date() {
            return _date;
          },
          navigate: function navigate(step) {
            return gfsStep(this.date(), step);
          },
          navigateTo: function navigateTo(date) {
            return gfsDate(date, {
              minute: 90
            });
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /CO2SC/, adjustmentRequired ? _product_strings__WEBPACK_IMPORTED_MODULE_7__["geosAdjustedCO2"] : _product_strings__WEBPACK_IMPORTED_MODULE_7__["geos"], null, function (data) {
              for (var i = 0; i < data.length; i++) {
                data[i] += Δ;
              }
            });
          },
          units: [// CO2 Surface Concentration, units: ppmv
          {
            label: "ppmv",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          alpha: {
            single: 200,
            animated: 150
          },
          scale: Object(_palette_co2sc__WEBPACK_IMPORTED_MODULE_16__["default"])(adjustmentRequired ? -8 : 0)
        });
      }
    },
    // "hrrrwind": {
    //     matchesPrimary: _.matches({param: "hrrrwind"}),
    //     matchesOverlay: _.matches({param: "hrrrwind"}),
    //     create: function(attr) {
    //         return buildProduct({
    //             type: "wind",
    //             descriptionHTML: localize({
    //                 name: {en: "Wind", ja: "風速"},
    //                 qualifier: {en: " @ " + describeSurface(attr), ja: "＠" + describeSurfaceJa(attr)}
    //             }),
    //             paths: [hrrrPath(attr, "wind", attr.surface, attr.level)],
    //             date: function() {
    //                 return hrrrDate(attr.date);
    //             },
    //             /**
    //              * @param {number} step the number of steps away: ±1 or ±10
    //              * @returns {Object} the date parts for the specified number of steps away from this product's date.
    //              */
    //             navigate: function(step) {
    //                 return hrrrStep(this.date(), step);
    //             },
    //             /**
    //              * @param {Object} date the desired date parts or the string "current".
    //              * @returns {Object} the actual date parts.
    //              */
    //             navigateTo: function(date) {
    //                 return hrrrDate(date);
    //             },
    //             builder: function(file) {
    //                 return require("./product/hrrr-wind.js")(file);
    //             },
    //             units: [
    //                 {label: "km/h", conversion: function(x) { return x * 3.6; },      precision: 0},
    //                 {label: "m/s",  conversion: function(x) { return x; },            precision: 1},
    //                 {label: "kn",   conversion: function(x) { return x * 1.943844; }, precision: 0},
    //                 {label: "mph",  conversion: function(x) { return x * 2.236936; }, precision: 0}
    //             ],
    //             scale: require("./palette/wind.js")(),
    //             particles: {velocityScale: 1/200, maxIntensity: 15},
    //         });
    //     }
    // },
    //
    // "hrrrtemp": {
    //     matchesOverlay: _.matches({overlayType: "hrrrtemp"}),
    //      create: function(attr) {
    //          return buildProduct({
    //              type: "hrrrtemp",
    //              descriptionHTML: localize({
    //                  name: {en: "HRRR Temp", ja: ""},
    //                  qualifier: ""
    //              }),
    //              paths: [hrrrPath(attr, "temp", attr.surface, attr.level)],
    //              date: function() {
    //                  return hrrrDate(attr.date);
    //              },
    //              /**
    //               * @param {number} step the number of steps away: ±1 or ±10
    //               * @returns {Object} the date parts for the specified number of steps away from this product's date.
    //               */
    //              navigate: function(step) {
    //                  return hrrrStep(this.date(), step);
    //              },
    //              /**
    //               * @param {Object} date the desired date parts or the string "current".
    //               * @returns {Object} the actual date parts.
    //               */
    //              navigateTo: function(date) {
    //                  return hrrrDate(date);
    //              },
    //              builder: function(file) {
    //                  return require("./product/hrrr-scalar.js")(file, /Temperature_height_above_ground/);
    //              },
    //              units: [
    //                  {label: "°C", conversion: function(x) { return x - 273.15; },       precision: 1},
    //                  {label: "°F", conversion: function(x) { return x * 9/5 - 459.67; }, precision: 1},
    //                  {label: "K",  conversion: function(x) { return x; },                precision: 1}
    //              ],
    //              scale: require("./palette/temp.js")(),
    //          });
    //      }
    // },
    //
    // "hrrrradar": {
    //     matchesOverlay: _.matches({overlayType: "hrrrradar"}),
    //      create: function(attr) {
    //          return buildProduct({
    //              type: "hrrrradar",
    //              descriptionHTML: localize({
    //                  name: {en: "HRRR Radar", ja: ""},
    //                  qualifier: ""
    //              }),
    //              paths: [hrrrPath(attr, "composite_reflectivity")],
    //              date: function() {
    //                  return hrrrDate(attr.date);
    //              },
    //              /**
    //               * @param {number} step the number of steps away: ±1 or ±10
    //               * @returns {Object} the date parts for the specified number of steps away from this product's date.
    //               */
    //              navigate: function(step) {
    //                  return hrrrStep(this.date(), step);
    //              },
    //              /**
    //               * @param {Object} date the desired date parts or the string "current".
    //               * @returns {Object} the actual date parts.
    //               */
    //              navigateTo: function(date) {
    //                  return hrrrDate(date);
    //              },
    //              builder: function(file) {
    //                  return require("./product/hrrr-scalar.js")(file, /Composite_reflectivity_entire_atmosphere/);
    //              },
    //              units: [
    //                  {label: "dB", conversion: function(x) { return x; }, precision: 1}
    //              ],
    //              scale: palette.buildScaleFromSegments([-10, 64], [
    //                  [-10,  [  0,   0,   0]],
    //                  [ 64,  [255, 255, 255]]
    //                  // [0.4,  [ 24, 255,  93]],
    //                  // [0.65, [255, 233, 102]],
    //                  // [1.0,  [255, 233,  15]],
    //                  // [1.5,  [255,  15,  15]]
    //              ], 1000),
    //              // scale: {
    //              //     bounds: [-10, 64],
    //              //     gradient: µ.segmentedColorScale([
    //              //         [-10,     [255, 255, 255]],
    //              //         [ 64,     [0, 0, 0]]
    //              //     ])
    //              // },
    //          });
    //      }
    // },
    "currents": {
      matchesPrimary: function () {
        var a = underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
          surface: "surface",
          level: "currents"
        });

        var b = underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
          param: "argo",
          surface: "pressure"
        });

        return function (o) {
          return a(o) || b(o);
        };
      }(),
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "currents"
      }),
      create: function create(attr) {
        return fetchOscarCatalog().then(function (catalog) {
          return buildProduct({
            type: "currents",
            descriptionHTML: localize({
              name: {
                en: "Ocean Currents",
                ja: "海流"
              },
              qualifier: {
                en: " @ Surface",
                ja: "＠地上"
              }
            }),
            paths: [oscarPath(catalog, attr)],
            date: function date() {
              return oscarDate(catalog, attr.date);
            },
            navigate: function navigate(step) {
              return oscarStep(catalog, this.date(), step);
            },
            navigateTo: function navigateTo(date) {
              return oscarStep(catalog, date, 0);
            },
            builder: function builder(file) {
              return Object(_product_oscar__WEBPACK_IMPORTED_MODULE_9__["default"])(file);
            },
            units: [{
              label: "m/s",
              conversion: function conversion(x) {
                return x;
              },
              precision: 2
            }, {
              label: "km/h",
              conversion: function conversion(x) {
                return x * 3.6;
              },
              precision: 1
            }, {
              label: "kn",
              conversion: function conversion(x) {
                return x * 1.943844;
              },
              precision: 1
            }, {
              label: "mph",
              conversion: function conversion(x) {
                return x * 2.236936;
              },
              precision: 1
            }],
            scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 1.5], [[0, [10, 25, 68]], [0.15, [10, 25, 250]], [0.4, [24, 255, 93]], [0.65, [255, 233, 102]], [1.0, [255, 233, 15]], [1.5, [255, 15, 15]]], 1000),
            particles: {
              velocityScale: 1 / 7,
              maxIntensity: 0.7
            }
          });
        });
      }
    },
    "primary_waves": {
      matchesPrimary: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        param: "ocean",
        surface: "primary",
        level: "waves"
      }),
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "primary_waves"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "primary_waves",
          descriptionHTML: localize({
            name: {
              en: "Peak Wave Period",
              ja: "ピーク波周期"
            },
            qualifier: ""
          }),
          paths: [wave30mPath(attr, "primary")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            return Object(_product_ww3_primary__WEBPACK_IMPORTED_MODULE_10__["default"])(file);
          },
          units: [{
            label: "sec",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 25], [[0, [0, 0, 0]], [25, [21, 255, 255]]], 1000),
          particles: {
            velocityScale: 1 / 612,
            maxIntensity: 12,
            waves: true
          }
        });
      }
    },
    "sea_surface_temp": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "sea_surface_temp"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "sea_surface_temp",
          descriptionHTML: localize({
            name: {
              en: "Sea Surface Temp",
              ja: "海面水温"
            },
            qualifier: ""
          }),
          paths: [rtgPath(attr, "sea_surface_temp")],
          date: function date() {
            return rtgDate(attr.date);
          },
          navigate: function navigate(step) {
            return rtgStep(this.date(), step);
          },
          navigateTo: function navigateTo(date) {
            return rtgStep(date, 0);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Temperature_surface_sparse/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["rtgsst"]);
          },
          units: [{
            label: "°C",
            conversion: function conversion(x) {
              return x - 273.15;
            },
            precision: 1
          }, {
            label: "°F",
            conversion: function conversion(x) {
              return x * 9 / 5 - 459.67;
            },
            precision: 1
          }, {
            label: "K",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([270, 304.65], [[270, [255, 255, 255]], [271.25, [255, 255, 255]], // -1.9 C sea water freeze
          [271.30, [15, 4, 168]], [273.15, [15, 54, 208]], // 0 C fresh water freeze
          [273.25, [15, 54, 188]], [275.65, [15, 4, 168]], // lower boundary for cool currents
          [281.65, [24, 132, 14]], // upper boundary for cool currents
          [291.15, [247, 251, 59]], // lower boundary for warm currents
          [295, [235, 167, 0]], [299.65, [245, 0, 39]], // minimum needed for tropical cyclone formation
          [303, [87, 17, 0]], [304.65, [238, 0, 242]]], 1000)
        });
      }
    },

    /*
            "argo_mean_temp": {
                matchesOverlay: _.matches({overlayType: "argo_mean_temp"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_mean_temp",
                        descriptionHTML: function() {
                            return "Argo Ocean Mean Temp"
                        },
                        paths: [argoPath(attr.date, "temp", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "°C", conversion: function(x) { return x; },            precision: 1},
                            {label: "°F", conversion: function(x) { return x * 9/5 + 32; }, precision: 1},
                            {label: "K",  conversion: function(x) { return x + 273.15; },   precision: 1}
                        ],
                        scale: palette.buildScaleFromSegments([270-273.15, 304.65-273.15], [
                            [270   -273.15, [255, 255, 255]],
                            [271.25-273.15, [255, 255, 255]],  // -1.9 C sea water freeze
                            [271.30-273.15, [ 15,   4, 168]],
                            [273.15-273.15, [ 15,  54, 208]],  // 0 C fresh water freeze
                            [273.25-273.15, [ 15,  54, 188]],
                            [275.65-273.15, [ 15,   4, 168]],  // lower boundary for cool currents
                            [281.65-273.15, [ 24, 132,  14]],  // upper boundary for cool currents
                            [291.15-273.15, [247, 251,  59]],  // lower boundary for warm currents
                            [295   -273.15, [235, 167,   0]],
                            [299.65-273.15, [245,   0,  39]],  // minimum needed for tropical cyclone formation
                            [303   -273.15, [ 87,  17,   0]],
                            [304.65-273.15, [238,   0, 242]]
                        ], 1000),
                        // scale: palette.buildScaleFromSegments([-2, 30], [
                        //     [-2,  [0,0,255]],
                        //     [13,  [255,255,255]],
                        //     [18,  [255,255,0 ]],
                        //     [23,  [255,111,0]],
                        //     [28,  [255,0,0]]
                        // ], 1000),
                    });
                }
            },

            "argo_temp_anom": {
                matchesOverlay: _.matches({overlayType: "argo_temp_anom"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_temp_anom",
                        descriptionHTML: function() {
                            return "Argo Ocean Temp Anomaly"
                        },
                        paths: [argoPath(attr.date, "temp_anom", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "°C", conversion: function(x) { return x; },            precision: 1},
                            {label: "°F", conversion: function(x) { return x * 9/5 + 32; }, precision: 1},
                            {label: "K",  conversion: function(x) { return x + 273.15; },   precision: 1}
                        ],
                        scale: palette.buildScaleFromSegments([-10, 10], [
                            [-10,  [0,75,30]],
                            [-6,   [0,150,0]],
                            [-0.5, [161,217,155]],
                            [0,    [255,255,255]],
                            [0.5,  [255,175,100]],
                            [6,    [255,111,0]],
                            [10,   [166,50,0]]
                        ], 1000),
                    });
                }
            },

            "argo_mean_salinity": {
                matchesOverlay: _.matches({overlayType: "argo_mean_salinity"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_mean_salinity",
                        descriptionHTML: function() {
                            return "Argo Ocean Salinity"
                        },
                        paths: [argoPath(attr.date, "salinity", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "PSU", conversion: function(x) { return x; }, precision: 2},
                        ],
                        scale: palette.buildScaleFromSegments([32, 39], [
                            [ 32.0,  [66, 99, 51]],
                            [ 33.6,  [108, 145, 81]],
                            [ 35.2,  [149, 191, 110]],
                            [ 36.0,  [205, 154, 176]],
                            [ 37.6,  [173, 104, 132]],
                            [ 39.0,  [140, 55, 107]]
                        ], 1000),
                    });
                }
            },

            "argo_salinity_anom": {
                matchesOverlay: _.matches({overlayType: "argo_salinity_anom"}),
                create: function(attr) {
                    return buildProduct({
                        type: "argo_salinity_anom",
                        descriptionHTML: function() {
                            return "Argo Ocean Salinity Anomaly"
                        },
                        paths: [argoPath(attr.date, "salinity_anom", attr.level)],
                        date: function() {
                            return argoDate(attr.date);
                        },
                        navigate: function(step) {
                            return argoStep(this.date(), step);
                        },
                        navigateTo: function(date) {
                            return argoStep(date, 0);
                        },
                        builder: function(file) {
                            return simpleProduct(file);
                        },
                        units: [
                            {label: "PSU", conversion: function(x) { return x; }, precision: 2},
                        ],
                        scale: palette.buildScaleFromSegments([-0.8, 0.8], [
                            [ -0.8,  [7, 62, 94]],
                            [ -0.6/2,  [27, 88, 121]],
                            [ -0.4/2,  [47, 113, 148]],
                            [ -0.2/4,  [74, 138, 175 ]],
                            [ -0.1/4,  [101, 163, 201]],
                            [  0.1/4,  [249, 163, 120]],
                            [  0.2/4,  [222, 135, 100]],
                            [  0.4/2,  [194, 106, 80]],
                            [  0.6/2,  [166, 77, 40]],
                            [  0.8,  [138, 48, 0]]


                            // [ -0.8/4,  [169, 104, 54]],
                            // [ -0.6/4,  [183, 126, 82]],
                            // [ -0.4/4,  [198, 148, 109]],
                            // [ -0.2/4,  [212, 171, 137]],
                            // [ -0.1/4,  [227, 193, 165]],
                            // [ 0.1/4,  [179, 179, 255]],
                            // [ 0.2/4,  [128, 128, 255]],
                            // [ 0.4/4,  [77, 77, 255]],
                            // [ 0.6/4,  [49, 49, 255]],
                            // [ 0.8/4,  [20, 20, 255]]

                            // [-6.0,  [255, 255, 255]],
                            // [-3,    [  7, 252, 254]],
                            // [-1.5,  [ 66,  42, 253]],
                            // [-0.75, [ 34,  55, 134]],
                            // [ 0,    [  0,   0,   6]],
                            // [ 0.75, [134,  55,  34]],
                            // [ 1.5,  [253,  14,  16]],
                            // [ 3.0,  [254, 252,   0]],
                            // [ 6.0,  [255, 255, 255]]
                        ], 1000),
                    });
                }
            },
    */
    "sea_surface_temp_anomaly": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "sea_surface_temp_anomaly"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "sea_surface_temp_anomaly",
          descriptionHTML: localize({
            name: {
              en: "SST Anomaly",
              ja: "海面水温異常"
            },
            qualifier: ""
          }),
          paths: [rtgPath(attr, "sea_surface_temp_anomaly")],
          date: function date() {
            return rtgDate(attr.date);
          },
          navigate: function navigate(step) {
            return rtgStep(this.date(), step);
          },
          navigateTo: function navigateTo(date) {
            return rtgStep(date, 0);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Temperature_surface_anomaly_sparse/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["rtgsst"]);
          },
          units: [{
            label: "°C",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }, {
            label: "°F",
            conversion: function conversion(x) {
              return x * 9 / 5;
            },
            precision: 1
          }, {
            label: "K",
            conversion: function conversion(x) {
              return x;
            },
            precision: 1
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([-6, 6], [[-6.0, [255, 255, 255]], [-3, [7, 252, 254]], [-1.5, [66, 42, 253]], [-0.75, [34, 55, 134]], [0, [0, 0, 6]], [0.75, [134, 55, 34]], [1.5, [253, 14, 16]], [3.0, [254, 252, 0]], [6.0, [255, 255, 255]]], 1000)
        });
      }
    },
    "significant_wave_height": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "significant_wave_height"
      }),
      create: function create(attr) {
        return buildProduct({
          type: "significant_wave_height",
          descriptionHTML: localize({
            name: {
              en: "Significant Wave Height",
              ja: "有義波高"
            },
            qualifier: ""
          }),
          paths: [wave30mPath(attr, "sig_height")],
          date: function date() {
            return gfsDate(attr.date);
          },
          builder: function builder(file) {
            // "Significant_height_of_combined_wind_waves_and_swell_surface"
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /Significant_height/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["ww3"]);
          },
          units: [{
            label: "m",
            conversion: function conversion(x) {
              return x;
            },
            precision: 2
          }, {
            label: "ft",
            conversion: function conversion(x) {
              return x * 100 / 2.54 / 12;
            },
            precision: 1
          }],
          scale: _palette_palette__WEBPACK_IMPORTED_MODULE_8__["buildScaleFromSegments"]([0, 15], [[0, [8, 29, 88]], [1, [37, 52, 148]], [2, [34, 94, 168]], [3, [29, 145, 192]], [4, [65, 182, 196]], [5, [127, 205, 187]], [6, [199, 233, 180]], [7, [237, 248, 177]], [8, [254, 204, 92]], [10, [253, 141, 60]], [12, [240, 59, 32]], [14, [189, 0, 38]]], 1000)
        });
      }
    },
    "aurora": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "aurora"
      }),
      create: function create(attr) {
        // HACK: Because some time slots will be filled by older data (since the data source is not reliable),
        // we want to use the date in the URL as the basis of navigation rather than the date from the
        // downloaded header. The date() method is replaced by flatProduct to use the header date, so this
        // function can be used to avoid that.
        function dateFromAttributes() {
          return ovationDate(attr.date);
        }

        return buildProduct({
          type: "aurora",
          descriptionHTML: localize({
            name: {
              en: "Probability of Visible Aurora",
              ja: "オーロラが見える確率"
            },
            qualifier: ""
          }),
          paths: [ovationPath(attr)],
          date: dateFromAttributes,
          navigate: function navigate(step) {
            return ovationStep(dateFromAttributes(), step);
          },
          navigateTo: function navigateTo(date) {
            return ovationDate(date);
          },
          builder: function builder(file) {
            return underscore__WEBPACK_IMPORTED_MODULE_0__["extend"](Object(_product_flatProduct__WEBPACK_IMPORTED_MODULE_6__["default"])(file), {
              sourceHTML: _product_strings__WEBPACK_IMPORTED_MODULE_7__["ovation"]
            });
          },
          units: [{
            label: "% Visibility Chance",
            tooltip: "% Visibility Chance",
            conversion: function conversion(x) {
              return x;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_aurora__WEBPACK_IMPORTED_MODULE_13__["default"])()
        });
      }
    },
    "pm1": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "pm1"
      }),
      create: function create(attr) {
        var stride = 1;
        return buildProduct({
          type: "pm1",
          descriptionHTML: localize({
            name: {
              en: "Particulate Matter < 1 µm",
              ja: "粒子径1µm以下（PM<sub>1</sub>）"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [camsPath(attr, "pm1", stride)],
          date: function date() {
            return camsDate(attr.date, stride);
          },
          navigate: function navigate(step) {
            return camsStep(this.date(), stride, step);
          },
          navigateTo: function navigateTo(date) {
            return camsDate(date, stride);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /pm1/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["cams"]);
          },
          units: [{
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_pmx__WEBPACK_IMPORTED_MODULE_19__["default"])()
        });
      }
    },
    "pm2.5": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "pm2.5"
      }),
      create: function create(attr) {
        var stride = 1;
        return buildProduct({
          type: "pm2.5",
          descriptionHTML: localize({
            name: {
              en: "Particulate Matter < 2.5 µm",
              ja: "微小粒子状物質（PM<sub>2.5</sub>）"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [camsPath(attr, "pm2p5", stride)],
          date: function date() {
            return camsDate(attr.date, stride);
          },
          navigate: function navigate(step) {
            return camsStep(this.date(), stride, step);
          },
          navigateTo: function navigateTo(date) {
            return camsDate(date, stride);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /pm2p5/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["cams"]);
          },
          units: [{
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_pmx__WEBPACK_IMPORTED_MODULE_19__["default"])()
        });
      }
    },
    "pm10": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "pm10"
      }),
      create: function create(attr) {
        var stride = 1;
        return buildProduct({
          type: "pm10",
          descriptionHTML: localize({
            name: {
              en: "Particulate Matter < 10 µm",
              ja: "粒子径10µm以下（PM<sub>10</sub>）"
            },
            qualifier: {
              en: " @ Surface",
              ja: "＠地上"
            }
          }),
          paths: [camsPath(attr, "pm10", stride)],
          date: function date() {
            return camsDate(attr.date, stride);
          },
          navigate: function navigate(step) {
            return camsStep(this.date(), stride, step);
          },
          navigateTo: function navigateTo(date) {
            return camsDate(date, stride);
          },
          builder: function builder(file) {
            return Object(_product_scalarProduct__WEBPACK_IMPORTED_MODULE_5__["default"])(file, /pm10/, _product_strings__WEBPACK_IMPORTED_MODULE_7__["cams"]);
          },
          units: [{
            label: "µg/m<sup>3</sup>",
            tooltip: "µg/m³",
            conversion: function conversion(x) {
              return x * 1e9;
            },
            precision: 0
          }],
          alpha: {
            single: 160,
            animated: 140
          },
          scale: Object(_palette_pmx__WEBPACK_IMPORTED_MODULE_19__["default"])()
        });
      }
    },

    /*
            "co": {
                matchesOverlay: _.matches({overlayType: "co"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "co",
                        descriptionHTML: localize({
                            name: {en: "CO", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "co", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /co|VAR192.*!/, strings.cams, null, data => {
                                for (let i = 0; i < data.length; i++) {
                                    data[i] *= 1e9;
                                }
                            });
                        },
                        units: [  // CO Surface Concentration in ppbm, units: 1e-9
                            {label: "ppbm", conversion: function(x) { return x; }, precision: 0},
                            {label: "ppmm", conversion: function(x) { return x / 1000; }, precision: 2}
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: require("./palette/cosc")(),
                    });
                }
            },

            "o3": {
                matchesOverlay: _.matches({overlayType: "o3"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "o3",
                        descriptionHTML: localize({
                            name: {en: "O3", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "go3", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /go3/, strings.cams);
                        },
                        units: [
                            {label: "ppbm", conversion: function(x) { return x * 1e9; }, precision: 0},
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: palette.buildScaleFromSegments([0, 600e-9], [
                            [0,        [  0,   0,   0]],
                            [600e-9,   [255, 255, 255]]
                        ], 1000),
                    });
                }
            },

            "no2": {
                matchesOverlay: _.matches({overlayType: "no2"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "no2",
                        descriptionHTML: localize({
                            name: {en: "NO2", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "no2", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /no2/, strings.cams);
                        },
                        units: [
                            {label: "ppbm", conversion: function(x) { return x * 1e9; }, precision: 0},
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: palette.buildScaleFromSegments([0, 2000e-9], [
                            [0,       [  0,   0,   0]],
                            [2000e-9, [255, 255, 255]]
                        ], 1000),
                    });
                }
            },

            "so2": {
                matchesOverlay: _.matches({overlayType: "so2"}),
                create: function(attr) {
                    const stride = 3;
                    return buildProduct({
                        type: "so2",
                        descriptionHTML: localize({
                            name: {en: "SO2", ja: ""},
                            qualifier: ""
                        }),
                        paths: [camsPath(attr, "so2", stride)],
                        date: function() {
                            return camsDate(attr.date, stride);
                        },
                        navigate: function(step) {
                            return camsStep(this.date(), stride, step);
                        },
                        navigateTo: function(date) {
                            return camsDate(date, stride);
                        },
                        builder: function(file) {
                            return scalarProduct(file, /so2/, strings.cams);
                        },
                        units: [
                            {label: "µg/m<sup>3</sup>", tooltip: "µg/m³", conversion: x => x * 1e9 * 2.86, precision: 2},
                            {label: "ppbm", conversion: x => x * 1e9, precision: 0},
                        ],
                        alpha: {single: 160, animated: 140},
                        scale: require("./palette/so2ppb")(),
                    });
                }
            },
    */
    "off": {
      matchesOverlay: underscore__WEBPACK_IMPORTED_MODULE_0__["matches"]({
        overlayType: "off"
      }),
      create: function create() {
        return null;
      }
    }
  };

  products.productsFor = function (attributes) {
    var attr = underscore__WEBPACK_IMPORTED_MODULE_0__["clone"](attributes);

    var primary = null,
        overlay = null;

    underscore__WEBPACK_IMPORTED_MODULE_0__["values"](FACTORIES).forEach(function (factory) {
      if (underscore__WEBPACK_IMPORTED_MODULE_0__["isFunction"](factory.matchesPrimary) && factory.matchesPrimary(attr)) {
        primary = factory;
      }

      if (underscore__WEBPACK_IMPORTED_MODULE_0__["isFunction"](factory.matchesOverlay) && factory.matchesOverlay(attr) && factory !== primary) {
        overlay = factory;
      }
    });

    var results = []; // TIME-LAPSE

    if (primary
    /*&& attributes.animate*/
    ) results.push(primary.create(attr));
    if (overlay) results.push(overlay.create(attr));
    return results.filter(_micro__WEBPACK_IMPORTED_MODULE_2__["isTruthy"]);
  };

  products.overlayTypes = function () {
    return _d3__WEBPACK_IMPORTED_MODULE_1__["set"](Object.keys(FACTORIES));
  };

  products.argoUrl = argoUrl;
  return products;
});

/***/ }),

/***/ "./public/js/projection/orthographic.frag":
/*!************************************************!*\
  !*** ./public/js/projection/orthographic.frag ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\nuniform vec2 u_translate;   // screen coords translation (x0, y0)\nuniform float u_R2;         // scale R, squared\nuniform float u_lon0;       // origin longitude\nuniform float u_sinlat0;    // sin(lat0)\nuniform float u_Rcoslat0;   // R * cos(lat0)\nuniform float u_coslat0dR;  // cos(lat0) / R\nuniform float u_flip;       // 1.0 if lat0 in range [-90deg, +90deg], otherwise -1.0\n\n// Handbook of Mathematical Functions, M. Abramowitz and I.A. Stegun, Ed. For input on range [-1, +1]\n// http://http.developer.nvidia.com/Cg/asin.html\nfloat arcsin(in float v) {\n    float x = abs(v);\n    float ret = -0.0187293;\n    ret *= x;\n    ret += 0.0742610;\n    ret *= x;\n    ret -= 0.2121144;\n    ret *= x;\n    ret += 1.5707288;\n    ret = PI / 2.0 - sqrt(1.0 - x) * ret;\n    return sign(v) * ret;\n}\n\n/** @returns [lon, lat] in radians for the specified point [x, y], or [7e37, 7e37] if the point is unprojectable. */\nvec2 invert(in vec2 point) {\n    vec2 pt = (point - u_translate) * u_flip;\n    float d = 1.0 - dot(pt, pt) / u_R2;\n    if (d >= 0.0) {  // CONSIDER: step() to remove branch... worth it?\n        float cosc = sqrt(d);\n        float lon = u_lon0 + atan(pt.x, cosc * u_Rcoslat0 - pt.y * u_sinlat0);  // u_lon0 + [-pi/2, pi/2]\n        float lat = arcsin(cosc * u_sinlat0 + pt.y * u_coslat0dR);              // [-π/2, π/2] [-90°, +90°]\n        return vec2(lon, lat);\n    }\n    return vec2(7e37);  // outside of projection\n}\n"

/***/ }),

/***/ "./public/js/projection/orthographic.js":
/*!**********************************************!*\
  !*** ./public/js/projection/orthographic.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return orthographic; });
/* harmony import */ var _consts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../consts */ "./public/js/consts.mjs");
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ "./public/js/math.mjs");

/*
 * Orthographic projection. Adapted from:
 *    Map Projections: A Working Manual, Snyder, John P: pubs.er.usgs.gov/publication/pp1395
 *    See page 145.
 *
 * γ rotation is not yet supported.
 */



/**
 * @param {number} R radius of the sphere (i.e., scale)
 * @param {number} λ0 longitude of projection center (degrees)
 * @param {number} φ0 latitude of projection center (degrees)
 * @param {number} x0 translation along x axis
 * @param {number} y0 translation along y axis
 * @returns {Function} projection function f([λ, φ]) and f.invert([x, y]), just like D3.
 */

function orthographic(R, λ0, φ0, x0, y0) {
  // Check if φ0 is rotated far enough that the globe is upside down. If so, adjust the projection center and
  // flip the x,y space. For example, rotation of +100 is actually lat of 80 deg with lon on other side.
  var φnorm = Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(φ0 + 90, 360); // now on range [0, 360). Anything on range (180, 360) is flipped.

  var flip = 180 < φnorm ? -1 : 1;

  if (flip < 0) {
    φ0 = 270 - φnorm;
    λ0 += 180;
  } else {
    φ0 = φnorm - 90;
  }

  φ0 *= _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
  λ0 = (Object(_math__WEBPACK_IMPORTED_MODULE_1__["floorMod"])(λ0 + 180, 360) - 180) * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"]; // normalize to [-180, 180)

  var R2 = R * R;
  var sinφ0 = Math.sin(φ0);
  var cosφ0 = Math.cos(φ0);
  var Rcosφ0 = R * cosφ0;
  var cosφ0dR = cosφ0 / R;
  var center = [x0, y0];
  /**
   * @param {number[]} coord [λ, φ] in degrees
   * @returns {number[]} resulting [x, y] or [NaN, NaN] if the coordinates are not defined for the projection.
   */

  function project(coord) {
    var lon = coord[0];
    var lat = coord[1];

    if (lon !== lon || lat !== lat) {
      return [NaN, NaN];
    }

    var λ = lon * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
    var φ = lat * _consts__WEBPACK_IMPORTED_MODULE_0__["RAD"];
    var Δλ = λ - λ0;
    var sinΔλ = Math.sin(Δλ);
    var cosΔλ = Math.cos(Δλ);
    var sinφ = Math.sin(φ);
    var cosφ = Math.cos(φ);
    var Rcosφ = R * cosφ; // const cosc = sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ;  // test if clip angle > 90°
    // if (cosc < 0) return [NaN, NaN];

    var x = Rcosφ * sinΔλ;
    var y = Rcosφ * cosΔλ * sinφ0 - Rcosφ0 * sinφ; // negates y because it grows downward

    var px = x * flip + x0;
    var py = y * flip + y0;
    return [px, py];
  }
  /**
   * @param {number[]} point [x, y]
   * @returns {number[]} resulting [λ, φ] in degrees or [NaN, NaN] if the point is not defined for the projection.
   */


  function invert(point) {
    var px = point[0];
    var py = point[1];
    var x = (px - x0) * flip;
    var y = (y0 - py) * flip; // negate y because it grows downward
    // const ρ = Math.sqrt(x * x + y * y);   // positive number
    // const c = Math.asin(ρ / R);           // [0, π/2] or NaN when ρ > R (meaning the point is outside the globe)
    // const sinc = Math.sin(c);             // [0, 1] because c in range [0, π/2]
    // const cosc = Math.cos(c);             // [0, 1] because c in range [0, π/2]
    // const ysinc = y * sinc;
    // const λ = λ0 + Math.atan2(x * sinc, ρ * cosc * cosφ0 - ysinc * sinφ0);
    // const φ = ρ === 0 ? φ0 : Math.asin(cosc * sinφ0 + ysinc * cosφ0 / ρ);

    var ρ2 = x * x + y * y;
    var d = 1 - ρ2 / R2;

    if (d >= 0) {
      var cosc = Math.sqrt(d); // cos(asin(x)) == sqrt(1 - x*x)

      var λ = λ0 + Math.atan2(x, cosc * Rcosφ0 - y * sinφ0);
      var φ = Math.asin(cosc * sinφ0 + y * cosφ0dR);
      return [λ * _consts__WEBPACK_IMPORTED_MODULE_0__["DEG"], φ * _consts__WEBPACK_IMPORTED_MODULE_0__["DEG"]];
    }

    return [NaN, NaN]; // outside of projection
  }

  project.invert = invert;
  /**
   * @param {GLUStick} glu
   */

  function webgl(glu) {
    return {
      shaderSource: function shaderSource() {
        return __webpack_require__(/*! ./orthographic.frag */ "./public/js/projection/orthographic.frag");
      },
      textures: function textures() {
        return {};
      },
      uniforms: function uniforms() {
        return {
          u_translate: center,
          // screen coords translation (x0, y0)
          u_R2: R2,
          // scale R, squared
          u_lon0: λ0,
          // origin longitude
          u_sinlat0: sinφ0,
          // sin(lat0)
          u_Rcoslat0: Rcosφ0,
          // R * cos(lat0)
          u_coslat0dR: cosφ0dR,
          // cos(lat0) / R
          u_flip: flip // 1.0 if lat0 in range [-90deg, +90deg], otherwise -1.0

        };
      }
    };
  }

  project.webgl = webgl;
  return project;
}
/**
 * @param p d3 version of orthographic projection.
 * @returns {Function} projection function f([λ, φ]) and f.invert([x, y]), just like D3.
 */

orthographic.fromD3 = function (p) {
  var t = p.translate(),
      r = p.rotate();

  if (r[2] !== 0) {
    throw new Error("γ rotation not supported");
  }

  return orthographic(p.scale(), -r[0], -r[1], t[0], t[1]);
};

/***/ }),

/***/ "./public/js/utc.mjs":
/*!***************************!*\
  !*** ./public/js/utc.mjs ***!
  \***************************/
/*! exports provided: parts, localParts, date, normalize, add, compare, print, parse, printISO, largest, smallest, chop, carry, accumulate, range, dayOfYear */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parts", function() { return parts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "localParts", function() { return localParts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "date", function() { return date; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compare", function() { return compare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "print", function() { return print; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "printISO", function() { return printISO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "largest", function() { return largest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smallest", function() { return smallest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chop", function() { return chop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "carry", function() { return carry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "accumulate", function() { return accumulate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "range", function() { return range; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dayOfYear", function() { return dayOfYear; });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! underscore */ "./node_modules/underscore/underscore.js");
/**
 * utc: utilities for working with datetimes.
 *
 * CONSIDER: a datetime starts at year, a duration is a partial datetime. So is {year: 2015} a datetime or a duration?
 * How about {year: 2016, month: 2, day: 14}?
 */

var all = ["year", "month", "day", "hour", "minute", "second", "milli"];

function coalesce(a, b) {
  return a !== undefined && a !== null ? a : b;
}
/**
 * Returns the string representation of a number padded with leading characters to make
 * it at least "width" length.
 *
 * @param {Number} n the number to convert to a padded string
 * @param {Number} width the desired minimum width of the resulting string
 * @param {string} [char] the character to use for padding, default is "0"
 * @returns {string} the padded string
 */


function pad(n, width, char) {
  var s = n.toString();
  var i = Math.max(width - s.length, 0);
  return new Array(i + 1).join(char || "0") + s;
}
/**
 * @param {Date|String|Number} date a Date object, or parsable date string (Note: "yyyy-MM-ddThh:mm:ss" and its
 *        prefixes are interpreted in UTC zone.)
 * @returns {Date} a Date object
 */


function asDate(date) {
  date = coalesce(date, "");

  if (underscore__WEBPACK_IMPORTED_MODULE_0__.isString(date) || underscore__WEBPACK_IMPORTED_MODULE_0__.isNumber(date)) {
    date = new Date(date);
  }

  return date;
}
/**
 * @param {Date|String|Number} date a Date object, or parsable date string (Note: "yyyy-MM-ddThh:mm:ss" and its
 *        prefixes are interpreted in UTC zone.)
 * @returns {Object} all UTC parts of the date: "year", "month", "day", "hour", "minute", "second", "milli"
 */


function parts(date) {
  date = asDate(date);
  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    day: date.getUTCDate(),
    hour: date.getUTCHours(),
    minute: date.getUTCMinutes(),
    second: date.getUTCSeconds(),
    milli: date.getUTCMilliseconds()
  };
}
/**
 * @param {Date|String|Number} date a Date object, or parsable date string (Note: "yyyy-MM-ddThh:mm:ss" and its
 *        prefixes are interpreted in UTC zone.)
 * @returns {Object} all Local parts of the date: "year", "month", "day", "hour", "minute", "second", "milli"
 */

function localParts(date) {
  date = asDate(date);
  return {
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate(),
    hour: date.getHours(),
    minute: date.getMinutes(),
    second: date.getSeconds(),
    milli: date.getMilliseconds()
  };
}
/**
 * @param {Object} parts the UTC date parts.
 * @returns {Date} the Date representation of the specified parts.
 */

function date(parts) {
  var year = +coalesce(parts.year, 0);
  var result = new Date(Date.UTC(year, coalesce(parts.month, 1) - 1, coalesce(parts.day, 1), coalesce(parts.hour, 0), coalesce(parts.minute, 0), coalesce(parts.second, 0), coalesce(parts.milli, 0)));

  if (+result === +result && 0 <= year && year <= 99) {
    result.setUTCFullYear(year); // fix issue that two digit years are mapped to 1900-1999
  }

  return result;
}
/**
 * Adjusts UTC date parts so that they represent an actual date. Parts that overflow, like {hour: 36}, are
 * adjusted to their proper range by carrying-over to the next larger part. Missing parts are added.
 *
 * @param parts the UTC date parts to normalize.
 * @returns {{year: number, month: number, day: number, hour: number, minute: number, second: number, milli:
 *     number}} all UTC parts adjusted to represent an actual date.
 */

function normalize(parts) {
  return _parts(date(parts));
}
var _parts = parts;
/**
 * @param {Object} parts the UTC date parts.
 * @param {Object} delta the parts to add. For example: {hour: 1, minute: 30}.
 * @returns {{year: number, month: number, day: number, hour: number, minute: number, second: number, milli:
 *     number}} all UTC parts with the delta added.
 */

function add(parts, delta) {
  var result = underscore__WEBPACK_IMPORTED_MODULE_0__.clone(parts);

  underscore__WEBPACK_IMPORTED_MODULE_0__.intersection(underscore__WEBPACK_IMPORTED_MODULE_0__.keys(delta), all).forEach(function (key) {
    result[key] = +coalesce(result[key], 0) + +delta[key];
  });

  return result;
}
/**
 * @returns {Number} standard comparator result. Both arguments are converted to Unix millis then compared.
 *          Invalid dates are smaller/earlier than all valid dates.
 */

function compare(aParts, bParts) {
  var a = date(aParts).getTime();

  if (isNaN(a)) {
    a = -Infinity;
  }

  var b = date(bParts).getTime();

  if (isNaN(b)) {
    b = -Infinity;
  }

  return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * @param {Object} parts the UTC date parts.
 * @param {string} format the format specification. Example: "{yyyy}-{MM}-{dd}T{hh}:{mm}:{ss}.{SSS}"
 * @returns {string} the formatted date.
 */

function print(parts, format) {
  var builder = [];

  for (var i = 0; i < format.length; i++) {
    var c = format[i];

    if (c !== "{") {
      builder.push(c);
      continue;
    }

    var spec = "";

    for (i++; i < format.length; i++) {
      c = format[i];

      if (c !== "}") {
        spec += c;
        continue;
      }

      var value = NaN;

      switch (spec[0]) {
        case "y":
          value = +parts.year;
          break;

        case "M":
          value = +parts.month;
          break;

        case "d":
          value = +parts.day;
          break;

        case "h":
          value = +parts.hour;
          break;

        case "m":
          value = +parts.minute;
          break;

        case "s":
          value = +parts.second;
          break;

        case "S":
          value = +parts.milli;
          break;
      }

      if (value === value) {
        builder.push(pad(value, spec.length));
      } else {
        builder.push("{", spec, "}");
      }

      break;
    }
  }

  return builder.join("");
}
function parse(s, format, groups) {
  var parts = {};

  function assign(key, value) {
    if (value === value) {
      parts[key] = value;
    }
  }

  groups = groups || {
    year: 1,
    month: 2,
    day: 3,
    hour: 4,
    minute: 5,
    second: 6,
    milli: 7
  };
  var match = format.exec(s);

  if (match) {
    assign("year", +match[groups.year]);
    assign("month", +match[groups.month]);
    assign("day", +match[groups.day]);
    assign("hour", +match[groups.hour]);
    assign("minute", +match[groups.minute]);
    assign("second", +match[groups.second]);
    assign("milli", +match[groups.milli]);
  }

  return parts;
}
function printISO(parts) {
  return date(parts).toISOString();
}
function largest(parts) {
  for (var i = 0; i < all.length; i++) {
    if (all[i] in parts) {
      return all[i];
    }
  }

  return undefined;
}
function smallest(parts) {
  for (var i = all.length - 1; i >= 0; i--) {
    if (all[i] in parts) {
      return all[i];
    }
  }

  return undefined;
}
function chop(key, dt) {
  var result = {};

  for (var i = 0; i < all.length; i++) {
    var field = all[i];

    if (field in dt) {
      result[field] = dt[field];
    }

    if (field === key) {
      break;
    }
  }

  return result;
}
/**
 * Carry-over any overflowing field to the next biggest.
 *     {hour: 2, minute: 65}  ->  {hour: 3, minute: 5}
 *
 * Overflowing stops at the largest defined field, up to "day". For example:
 *              {minute: 65}  ->  {minute: 65}
 *     {hour: 0, minute: 65}  ->  {hour: 1, minute: 5}
 *
 * @param {Object} parts the UTC date parts.
 * @returns {Object} new UTC date parts where any overflow has been carried over to the next biggest field.
 */

function carry(parts) {
  // CONSIDER: normalize and carry are pretty similar, except that carry is meant for durations (stops at "day").
  var result = {};
  if (parts.year !== undefined) result.year = parts.year;
  if (parts.month !== undefined) result.month = parts.month;
  var stop = largest(parts);
  var day = parts.day;
  var hour = parts.hour;
  var minute = parts.minute;
  var second = parts.second;
  var milli = parts.milli;

  if (stop !== "milli") {
    if (milli >= 1000) {
      second = coalesce(second, 0) + Math.floor(milli / 1000);
      milli %= 1000;
    }

    if (stop !== "second") {
      if (second >= 60) {
        minute = coalesce(minute, 0) + Math.floor(second / 60);
        second %= 60;
      }

      if (stop !== "minute") {
        if (minute >= 60) {
          hour = coalesce(hour, 0) + Math.floor(minute / 60);
          minute %= 60;
        }

        if (stop !== "hour") {
          if (hour >= 24) {
            day = coalesce(day, 0) + Math.floor(hour / 24);
            hour %= 24;
          }
        }
      }
    }
  }

  if (day !== undefined) result.day = day;
  if (hour !== undefined) result.hour = hour;
  if (minute !== undefined) result.minute = minute;
  if (second !== undefined) result.second = second;
  if (milli !== undefined) result.milli = milli;
  return result;
}
/**
 * @param parts the input datetime.
 * @returns {Object} a datetime with all parts specified, filled in with zero when undefined.
 */

function fill(parts) {
  return {
    year: parts.year || 0,
    month: parts.month || 0,
    day: parts.day || 0,
    hour: parts.hour || 0,
    minute: parts.minute || 0,
    second: parts.second || 0,
    milli: parts.milli || 0
  };
}
/**
 * Accumulates the total duration of time into one part specified by key. Standard durations are used. Years and
 * months are ignored because they convert to a variable number of days.
 *
 *       "hour", {hour: 2, minute: 65}  ->  {hour: 3}
 *     "minute", {hour: 2, minute: 65}  ->  {minute: 185}
 *     "second", {hour: 2, minute: 65}  ->  {second: 11100}
 *
 * @param {string} key the part to accumulate time into.
 * @param {Object} parts the input duration.
 * @returns {Object} datetime with one part, {key: }, where all the time has been accumulated into it.
 */


function accumulate(key, parts) {
  var smoothed = carry(fill(parts));
  var accum = smoothed.day;

  if (key === "day") {
    return {
      day: accum
    };
  }

  accum = accum * 24 + smoothed.hour;

  if (key === "hour") {
    return {
      hour: accum
    };
  }

  accum = accum * 60 + smoothed.minute;

  if (key === "minute") {
    return {
      minute: accum
    };
  }

  accum = accum * 60 + smoothed.second;

  if (key === "second") {
    return {
      second: accum
    };
  }

  accum = accum * 1000 + smoothed.milli;

  if (key === "milli") {
    return {
      milli: accum
    };
  }

  var result = {};
  result[key] = undefined;
  return result;
}
/**
 * @param start the starting UTC parts, inclusive
 * @param end the ending UTC parts, inclusive
 * @param delta the UTC parts
 * @returns {Array} a range of UTC parts separated by delta
 */

function range(start, end, delta) {
  var results = [];

  for (var i = start; compare(i, end) <= 0; i = add(i, delta)) {
    results.push(carry(i));
  }

  return results;
}
/**
 * @param {Object} dt the datetime.
 * @returns {number} the ordinal number of days from Jan 1 of the input year, starting at 1.
 */

function dayOfYear(dt) {
  var d1 = date(dt),
      d0 = date({
    year: d1.getUTCFullYear()
  });
  return Math.floor((d1 - d0) / (24 * 60 * 60 * 1000)) + 1; // No daylight savings in UTC.
}

/***/ })

/******/ });
//# sourceMappingURL=bundle.js.map
